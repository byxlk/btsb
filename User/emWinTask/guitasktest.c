/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "guitasktest.h"
#include "bsp.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (GUI_ID_USER + 0x00)
#define ID_TEXT_0 (GUI_ID_USER + 0x01)
#define ID_EDIT_0 (GUI_ID_USER + 0x02)
#define ID_EDIT_1 (GUI_ID_USER + 0x03)
#define ID_EDIT_2 (GUI_ID_USER + 0x04)
#define ID_GRAPH_0 (GUI_ID_USER + 0x05)
#define ID_EDIT_3 (GUI_ID_USER + 0x06)
#define ID_EDIT_4 (GUI_ID_USER + 0x07)


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 240, 320, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Test Programe", ID_TEXT_0, 80, 20, 80, 20, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "TimeH", ID_EDIT_0, 20, 65, 80, 80, 0, 0x3, 0 },
  { EDIT_CreateIndirect, "TimeM", ID_EDIT_1, 140, 65, 80, 80, 0, 0x3, 0 },
  { EDIT_CreateIndirect, "Temp", ID_EDIT_2, 20, 290, 50, 20, 0, 0x3, 0 },
  { GRAPH_CreateIndirect, "MicGraph", ID_GRAPH_0, 20, 168, 200, 100, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "Lux", ID_EDIT_3, 90, 290, 50, 20, 0, 0x5, 0 },
  { EDIT_CreateIndirect, "Mic", ID_EDIT_4, 160, 290, 50, 20, 0, 0x5, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'TimeH'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
    EDIT_SetText(hItem, "12");
    //
    // Initialization of 'TimeM'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_1);
    EDIT_SetText(hItem, "00");
    //
    // Initialization of 'Temp'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_2);
    EDIT_SetText(hItem, "-20");
    //
    // Initialization of 'Lux'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_3);
    EDIT_SetText(hItem, "1000");
    //
    // Initialization of 'Mic'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_4);
    EDIT_SetText(hItem, "3300");
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_EDIT_0: // Notifications sent by 'TimeH'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_1: // Notifications sent by 'TimeM'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_2: // Notifications sent by 'Temp'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_3: // Notifications sent by 'Lux'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_4: // Notifications sent by 'Mic'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow(void);
WM_HWIN CreateWindow(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)

/*
*********************************************************************************************************
*	函 数 名: MainTask
*	功能说明: GUI主函数
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
void GuiTaskTest(void) 
{
	int Value = 0;
	WM_HWIN hDlgFrame;
	
	/* 初始化 */
	GUI_Init();
    //TOUCH_Calibration();
	//GUI_CURSOR_Show();
	//WM_SetCallback(WM_HBKWIN, _cbBkWindow);  
	WM_SetCreateFlags(WM_CF_MEMDEV);   
	hDlgFrame = 0;
	
	while(1) 
	{
		WM_HWIN hDlg, hText;
		char acText[3] = {0};
		
		GUI_Delay(100);
		/* 如果对话框被关闭就重新的将其再打开 */
		if (!WM_IsWindow(hDlgFrame)) 
		{
			Value = 0;
			hDlgFrame = CreateWindow();
		}
		
		Value = (Value + 1) % 100;
		acText[0] = '0' + Value / 10;
		acText[1] = '0' + Value % 10;
		hDlg = WM_GetClientWindow(hDlgFrame);
		hText = WM_GetDialogItem(hDlg, ID_EDIT_0);
		EDIT_SetText(hText, acText);
	}
}

// USER END

void bsp_RTC_Test(void)
{
        char TempDate[] = {'2','0','0','0','-','0','1','-','0','1',' ','0','8',':','0','0',':','0','0',' ','W','7'};
        GUI_Init();
        GUI_SetBkColor(CL_BLUE);

        GUI_Clear();
        GUI_SetFont(&GUI_Font8x16);

        //GUI_DispString("Hello World !");

        while(1)
        {
                GUI_Delay(10);
                GUI_GotoXY(0, 0);
                bsp_RTC_GetClock();
            #if 1
                TempDate[0] = '0' + g_tRTC.Year /1000;
                TempDate[1] = '0' + g_tRTC.Year /100 % 10;
                TempDate[2] = '0' + g_tRTC.Year /10 % 10;
                TempDate[3] = '0' + g_tRTC.Year % 10;
                
                TempDate[5] = '0' + g_tRTC.Mon / 10;
                TempDate[6] = '0' + g_tRTC.Mon % 10;
                
                TempDate[8] = '0' + g_tRTC.Day /10;
                TempDate[9] = '0' + g_tRTC.Day % 10;
                
                TempDate[21] = '0' + g_tRTC.Week;

                TempDate[11] = '0' + g_tRTC.Hour / 10;
                TempDate[12] = '0' + g_tRTC.Hour % 10;
                 
                TempDate[14] = '0' + g_tRTC.Min / 10;
                TempDate[15] = '0' + g_tRTC.Min % 10;

                TempDate[17] = '0' + g_tRTC.Sec / 10;
                TempDate[18] = '0' + g_tRTC.Sec % 10;
                
                GUI_DispString(TempDate);
                #else
                GUI_DispDecAt(g_tRTC.Year, 0, 0, 5);
                GUI_DispDecAt(g_tRTC.Mon, 48, 0, 3);
                GUI_DispDecAt(g_tRTC.Day, 80, 0, 3);
                GUI_DispDecAt(g_tRTC.Week, 112, 0, 2);
                
                GUI_DispDecAt(g_tRTC.Hour, 120, 0, 3);
                GUI_DispDecAt(g_tRTC.Min, 152, 0, 2);
                GUI_DispDecAt(g_tRTC.Sec, 184, 0, 3);
                #endif
        }
        
}

/*************************** End of file ****************************/

