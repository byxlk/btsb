; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_dcmi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_dcmi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_dcmi.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_dcmi.c]
                          THUMB

                          AREA ||i.DCMI_CROPCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CROPCmd PROC
;;;224      */
;;;225    void DCMI_CROPCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L1.16|
;;;226    {
;;;227      /* Check the parameters */
;;;228      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;229        
;;;230      if (NewState != DISABLE)
;;;231      {
;;;232        /* Enable the DCMI Crop feature */
;;;233        DCMI->CR |= (uint32_t)DCMI_CR_CROP;
000002  4907              LDR      r1,|L1.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410104          ORR      r1,r1,#4
00000a  4a05              LDR      r2,|L1.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;234      }
;;;235      else
;;;236      {
;;;237        /* Disable the DCMI Crop feature */
;;;238        DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
000010  4903              LDR      r1,|L1.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210104          BIC      r1,r1,#4
000018  4a01              LDR      r2,|L1.32|
00001a  6011              STR      r1,[r2,#0]
                  |L1.28|
;;;239      }
;;;240    }
00001c  4770              BX       lr
;;;241    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_CROPConfig||, CODE, READONLY, ALIGN=2

                  DCMI_CROPConfig PROC
;;;206      */
;;;207    void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
000000  8841              LDRH     r1,[r0,#2]
;;;208    {  
;;;209      /* Sets the CROP window coordinates */
;;;210      DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
000002  8802              LDRH     r2,[r0,#0]
000004  ea414102          ORR      r1,r1,r2,LSL #16
000008  4a04              LDR      r2,|L2.28|
00000a  6211              STR      r1,[r2,#0x20]
;;;211                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
;;;212    
;;;213      /* Sets the CROP window size */
;;;214      DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
00000c  88c1              LDRH     r1,[r0,#6]
00000e  8882              LDRH     r2,[r0,#4]
000010  ea414102          ORR      r1,r1,r2,LSL #16
000014  4a01              LDR      r2,|L2.28|
000016  6251              STR      r1,[r2,#0x24]
;;;215                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
;;;216    }
000018  4770              BX       lr
;;;217    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x50050000

                          AREA ||i.DCMI_CaptureCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CaptureCmd PROC
;;;323      */
;;;324    void DCMI_CaptureCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L3.16|
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;328        
;;;329      if (NewState != DISABLE)
;;;330      {
;;;331        /* Enable the DCMI Capture */
;;;332        DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
000002  4907              LDR      r1,|L3.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  4a05              LDR      r2,|L3.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L3.28|
                  |L3.16|
;;;333      }
;;;334      else
;;;335      {
;;;336        /* Disable the DCMI Capture */
;;;337        DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
000010  4903              LDR      r1,|L3.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210101          BIC      r1,r1,#1
000018  4a01              LDR      r2,|L3.32|
00001a  6011              STR      r1,[r2,#0]
                  |L3.28|
;;;338      }
;;;339    }
00001c  4770              BX       lr
;;;340    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearFlag||, CODE, READONLY, ALIGN=2

                  DCMI_ClearFlag PROC
;;;462      */
;;;463    void DCMI_ClearFlag(uint16_t DCMI_FLAG)
000000  4901              LDR      r1,|L4.8|
;;;464    {
;;;465      /* Check the parameters */
;;;466      assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
;;;467      
;;;468      /* Clear the flag by writing in the ICR register 1 in the corresponding 
;;;469      Flag position*/
;;;470      
;;;471      DCMI->ICR = DCMI_FLAG;
000002  6148              STR      r0,[r1,#0x14]
;;;472    }
000004  4770              BX       lr
;;;473    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DCMI_ClearITPendingBit PROC
;;;516      */
;;;517    void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
000000  4901              LDR      r1,|L5.8|
;;;518    {
;;;519      /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
;;;520      corresponding pending Bit position*/
;;;521      
;;;522      DCMI->ICR = DCMI_IT;
000002  6148              STR      r0,[r1,#0x14]
;;;523    }
000004  4770              BX       lr
;;;524    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_Cmd||, CODE, READONLY, ALIGN=2

                  DCMI_Cmd PROC
;;;300      */
;;;301    void DCMI_Cmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L6.16|
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;305      
;;;306      if (NewState != DISABLE)
;;;307      {
;;;308        /* Enable the DCMI by setting ENABLE bit */
;;;309        DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
000002  4907              LDR      r1,|L6.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4414180          ORR      r1,r1,#0x4000
00000a  4a05              LDR      r2,|L6.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L6.28|
                  |L6.16|
;;;310      }
;;;311      else
;;;312      {
;;;313        /* Disable the DCMI by clearing ENABLE bit */
;;;314        DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
000010  4903              LDR      r1,|L6.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4214180          BIC      r1,r1,#0x4000
000018  4a01              LDR      r2,|L6.32|
00001a  6011              STR      r1,[r2,#0]
                  |L6.28|
;;;315      }
;;;316    }
00001c  4770              BX       lr
;;;317    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_DeInit||, CODE, READONLY, ALIGN=2

                  DCMI_DeInit PROC
;;;127      */
;;;128    void DCMI_DeInit(void)
000000  2000              MOVS     r0,#0
;;;129    {
;;;130      DCMI->CR = 0x0;
000002  4905              LDR      r1,|L7.24|
000004  6008              STR      r0,[r1,#0]
;;;131      DCMI->IER = 0x0;
000006  60c8              STR      r0,[r1,#0xc]
;;;132      DCMI->ICR = 0x1F;
000008  201f              MOVS     r0,#0x1f
00000a  6148              STR      r0,[r1,#0x14]
;;;133      DCMI->ESCR = 0x0;
00000c  2000              MOVS     r0,#0
00000e  6188              STR      r0,[r1,#0x18]
;;;134      DCMI->ESUR = 0x0;
000010  61c8              STR      r0,[r1,#0x1c]
;;;135      DCMI->CWSTRTR = 0x0;
000012  6208              STR      r0,[r1,#0x20]
;;;136      DCMI->CWSIZER = 0x0;
000014  6248              STR      r0,[r1,#0x24]
;;;137    }
000016  4770              BX       lr
;;;138    
                          ENDP

                  |L7.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetFlagStatus PROC
;;;415      */
;;;416    FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
000000  b510              PUSH     {r4,lr}
;;;417    {
000002  4601              MOV      r1,r0
;;;418      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;419      uint32_t dcmireg, tempreg = 0;
000006  2300              MOVS     r3,#0
;;;420    
;;;421      /* Check the parameters */
;;;422      assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
;;;423      
;;;424      /* Get the DCMI register index */
;;;425      dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
000008  130a              ASRS     r2,r1,#12
;;;426      
;;;427      if (dcmireg == 0x00) /* The FLAG is in RISR register */
00000a  b912              CBNZ     r2,|L8.18|
;;;428      {
;;;429        tempreg= DCMI->RISR;
00000c  4c08              LDR      r4,|L8.48|
00000e  68a3              LDR      r3,[r4,#8]
000010  e006              B        |L8.32|
                  |L8.18|
;;;430      }
;;;431      else if (dcmireg == 0x02) /* The FLAG is in SR register */
000012  2a02              CMP      r2,#2
000014  d102              BNE      |L8.28|
;;;432      {
;;;433        tempreg = DCMI->SR;
000016  4c06              LDR      r4,|L8.48|
000018  6863              LDR      r3,[r4,#4]
00001a  e001              B        |L8.32|
                  |L8.28|
;;;434      }
;;;435      else /* The FLAG is in MISR register */
;;;436      {
;;;437        tempreg = DCMI->MISR;
00001c  4c04              LDR      r4,|L8.48|
00001e  6923              LDR      r3,[r4,#0x10]
                  |L8.32|
;;;438      }
;;;439      
;;;440      if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
000020  ea030401          AND      r4,r3,r1
000024  b10c              CBZ      r4,|L8.42|
;;;441      {
;;;442        bitstatus = SET;
000026  2001              MOVS     r0,#1
000028  e000              B        |L8.44|
                  |L8.42|
;;;443      }
;;;444      else
;;;445      {
;;;446        bitstatus = RESET;
00002a  2000              MOVS     r0,#0
                  |L8.44|
;;;447      }
;;;448      /* Return the DCMI_FLAG status */
;;;449      return  bitstatus;
;;;450    }
00002c  bd10              POP      {r4,pc}
;;;451    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetITStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetITStatus PROC
;;;484      */
;;;485    ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
000000  4601              MOV      r1,r0
;;;486    {
;;;487      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;488      uint32_t itstatus = 0;
000004  2200              MOVS     r2,#0
;;;489      
;;;490      /* Check the parameters */
;;;491      assert_param(IS_DCMI_GET_IT(DCMI_IT));
;;;492      
;;;493      itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
000006  4b04              LDR      r3,|L9.24|
000008  691b              LDR      r3,[r3,#0x10]
00000a  ea030201          AND      r2,r3,r1
;;;494      
;;;495      if ((itstatus != (uint16_t)RESET))
00000e  b10a              CBZ      r2,|L9.20|
;;;496      {
;;;497        bitstatus = SET;
000010  2001              MOVS     r0,#1
000012  e000              B        |L9.22|
                  |L9.20|
;;;498      }
;;;499      else
;;;500      {
;;;501        bitstatus = RESET;
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;502      }
;;;503      return bitstatus;
;;;504    }
000016  4770              BX       lr
;;;505    
                          ENDP

                  |L9.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_ITConfig||, CODE, READONLY, ALIGN=2

                  DCMI_ITConfig PROC
;;;378      */
;;;379    void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;380    {
;;;381      /* Check the parameters */
;;;382      assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
;;;383      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;384      
;;;385      if (NewState != DISABLE)
;;;386      {
;;;387        /* Enable the Interrupt sources */
;;;388        DCMI->IER |= DCMI_IT;
000002  4a07              LDR      r2,|L10.32|
000004  68d2              LDR      r2,[r2,#0xc]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L10.32|
00000a  60da              STR      r2,[r3,#0xc]
00000c  e006              B        |L10.28|
                  |L10.14|
;;;389      }
;;;390      else
;;;391      {
;;;392        /* Disable the Interrupt sources */
;;;393        DCMI->IER &= (uint16_t)(~DCMI_IT);
00000e  4a04              LDR      r2,|L10.32|
000010  68d2              LDR      r2,[r2,#0xc]
000012  43c3              MVNS     r3,r0
000014  b29b              UXTH     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L10.32|
00001a  60da              STR      r2,[r3,#0xc]
                  |L10.28|
;;;394      }  
;;;395    }
00001c  4770              BX       lr
;;;396    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_Init||, CODE, READONLY, ALIGN=2

                  DCMI_Init PROC
;;;144      */
;;;145    void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;146    {
;;;147      uint32_t temp = 0x0;
;;;148      
;;;149      /* Check the parameters */
;;;150      assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
;;;151      assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
;;;152      assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
;;;153      assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
;;;154      assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
;;;155      assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
;;;156      assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
;;;157    
;;;158      /* The DCMI configuration registers should be programmed correctly before 
;;;159      enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
;;;160      DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
000002  4a0e              LDR      r2,|L11.60|
000004  6812              LDR      r2,[r2,#0]
000006  f2440301          MOV      r3,#0x4001
00000a  439a              BICS     r2,r2,r3
00000c  4b0b              LDR      r3,|L11.60|
00000e  601a              STR      r2,[r3,#0]
;;;161       
;;;162      /* Reset the old DCMI configuration */
;;;163      temp = DCMI->CR;
000010  461a              MOV      r2,r3
000012  6811              LDR      r1,[r2,#0]
;;;164      
;;;165      temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
000014  f64072f2          MOV      r2,#0xff2
000018  4391              BICS     r1,r1,r2
;;;166                          DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
;;;167                          DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
;;;168                      
;;;169      /* Sets the new configuration of the DCMI peripheral */
;;;170      temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
00001a  8802              LDRH     r2,[r0,#0]
00001c  8843              LDRH     r3,[r0,#2]
00001e  431a              ORRS     r2,r2,r3
000020  8883              LDRH     r3,[r0,#4]
000022  431a              ORRS     r2,r2,r3
000024  88c3              LDRH     r3,[r0,#6]
000026  431a              ORRS     r2,r2,r3
000028  8903              LDRH     r3,[r0,#8]
00002a  431a              ORRS     r2,r2,r3
00002c  8943              LDRH     r3,[r0,#0xa]
00002e  431a              ORRS     r2,r2,r3
000030  8983              LDRH     r3,[r0,#0xc]
000032  431a              ORRS     r2,r2,r3
000034  4311              ORRS     r1,r1,r2
;;;171                         DCMI_InitStruct->DCMI_SynchroMode |
;;;172                         DCMI_InitStruct->DCMI_PCKPolarity |
;;;173                         DCMI_InitStruct->DCMI_VSPolarity |
;;;174                         DCMI_InitStruct->DCMI_HSPolarity |
;;;175                         DCMI_InitStruct->DCMI_CaptureRate |
;;;176                         DCMI_InitStruct->DCMI_ExtendedDataMode);
;;;177    
;;;178      DCMI->CR = temp;                              
000036  4a01              LDR      r2,|L11.60|
000038  6011              STR      r1,[r2,#0]
;;;179    }
00003a  4770              BX       lr
;;;180    
                          ENDP

                  |L11.60|
                          DCD      0x50050000

                          AREA ||i.DCMI_JPEGCmd||, CODE, READONLY, ALIGN=2

                  DCMI_JPEGCmd PROC
;;;262      */
;;;263    void DCMI_JPEGCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L12.16|
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;267     
;;;268      if (NewState != DISABLE)
;;;269      {
;;;270        /* Enable the DCMI JPEG format */
;;;271        DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
000002  4907              LDR      r1,|L12.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410108          ORR      r1,r1,#8
00000a  4a05              LDR      r2,|L12.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L12.28|
                  |L12.16|
;;;272      }
;;;273      else
;;;274      {
;;;275        /* Disable the DCMI JPEG format */
;;;276        DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
000010  4903              LDR      r1,|L12.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210108          BIC      r1,r1,#8
000018  4a01              LDR      r2,|L12.32|
00001a  6011              STR      r1,[r2,#0]
                  |L12.28|
;;;277      }
;;;278    }
00001c  4770              BX       lr
;;;279    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_ReadData||, CODE, READONLY, ALIGN=2

                  DCMI_ReadData PROC
;;;345      */
;;;346    uint32_t DCMI_ReadData(void)
000000  4801              LDR      r0,|L13.8|
;;;347    {
;;;348      return DCMI->DR;
000002  6a80              LDR      r0,[r0,#0x28]
;;;349    }
000004  4770              BX       lr
;;;350    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_SetEmbeddedSynchroCodes||, CODE, READONLY, ALIGN=2

                  DCMI_SetEmbeddedSynchroCodes PROC
;;;247      */
;;;248    void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
000000  7801              LDRB     r1,[r0,#0]
;;;249    {
;;;250      DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
000002  7842              LDRB     r2,[r0,#1]
000004  ea412102          ORR      r1,r1,r2,LSL #8
000008  7882              LDRB     r2,[r0,#2]
00000a  ea414102          ORR      r1,r1,r2,LSL #16
00000e  78c2              LDRB     r2,[r0,#3]
000010  ea416102          ORR      r1,r1,r2,LSL #24
000014  4a01              LDR      r2,|L14.28|
000016  6191              STR      r1,[r2,#0x18]
;;;251                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
;;;252                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
;;;253                              ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
;;;254    }
000018  4770              BX       lr
;;;255    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x50050000

                          AREA ||i.DCMI_StructInit||, CODE, READONLY, ALIGN=1

                  DCMI_StructInit PROC
;;;186      */
;;;187    void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;188    {
;;;189      /* Set the default configuration */
;;;190      DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
000002  8001              STRH     r1,[r0,#0]
;;;191      DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
000004  8041              STRH     r1,[r0,#2]
;;;192      DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
000006  8081              STRH     r1,[r0,#4]
;;;193      DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;194      DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
00000a  8101              STRH     r1,[r0,#8]
;;;195      DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
00000c  8141              STRH     r1,[r0,#0xa]
;;;196      DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
00000e  8181              STRH     r1,[r0,#0xc]
;;;197    }
000010  4770              BX       lr
;;;198    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_dcmi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_dcmi_c_3610e7fb____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_stm32f2xx_dcmi_c_3610e7fb____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_dcmi_c_3610e7fb____REVSH|
#line 402
|__asm___16_stm32f2xx_dcmi_c_3610e7fb____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_dcmi_c_3610e7fb____RRX|
#line 587
|__asm___16_stm32f2xx_dcmi_c_3610e7fb____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
