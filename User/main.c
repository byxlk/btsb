/*
*********************************************************************************************************
*
*	模块名称 : 主程序模块。
*	文件名称 : main.c
*	版    本 : V1.0
*	说    明 : 本实验主要实现FreeRTOS++STemWin+FatFS综合
*              实验目的：
*                1. 学习FreeRTOS++STemWin+FatFS综合
*              实验内容：
*                1. 按下按键K1可以通过串口打印任务执行情况（波特率115200，数据位8，奇偶校验位无，停止位1）
*                   =================================================
*                   任务名      任务状态 优先级   剩余栈 任务序号
*                   vTaskUserIF     R       2       270     2
*                   vTaskGUI        R       1       150     1
*                   IDLE            R       0       114     6
*                   vTaskLED        B       3       484     3
*                   vTaskStart      B       5       490     5
*                   vTaskMsgPro     S       4       480     4
*
*
*                   任务名       运行计数         使用率
*                   vTaskUserIF     4611            <1%
*                   vTaskGUI        152759          14%
*                   IDLE            884172          83%
*                   vTaskLED        0               <1%
*                   vTaskStart      16259           1%
*                   vTaskMsgPro     1               <1%
*                  串口软件建议使用SecureCRT（V4光盘里面有此软件）查看打印信息。
*                  各个任务实现的功能如下：
*                   vTaskGUI        任务: emWin任务
*                   vTaskTaskUserIF 任务: 接口消息处理
*                   vTaskLED        任务: LED闪烁
*                   vTaskMsgPro     任务: 实现截图功能，将图片以BMP格式保存到SD卡中
*                   vTaskStart      任务: 启动任务，也就是最高优先级任务，这里实现按键扫描和触摸检测
*                2. 任务运行状态的定义如下，跟上面串口打印字母B, R, D, S对应：
*                    #define tskBLOCKED_CHAR		( 'B' )  阻塞
*                    #define tskREADY_CHAR		    ( 'R' )  就绪
*                    #define tskDELETED_CHAR		( 'D' )  删除
*                    #define tskSUSPENDED_CHAR	    ( 'S' )  挂起
*                3. K2按键按下，实现截图功能，将图片以BMP格式保存到SD卡的PicSave文件夹中。
*              注意事项：
*                1. 本实验推荐使用串口软件SecureCRT，要不串口打印效果不整齐。此软件在
*                   V4开发板光盘里面有。
*                2. 务必将编辑器的缩进参数和TAB设置为4来阅读本文件，要不代码显示不整齐。
*
*	修改记录 :
*		版本号    日期         作者            说明
*       V1.0    2016-03-15   Eric2013    1. ST固件库到V3.6.1版本
*                                        2. BSP驱动包V1.2
*                                        3. FreeRTOS版本V8.2.3
*                                        4. FatFS版本V0.11
*                                        5. STemWin版本V5.28
*
*	Copyright (C), 2016-2020, 安富莱电子 www.armfly.com
*
*********************************************************************************************************
*/
#include <includes.h>
#include "FreeRTOS_CLI.h"
#include "MainTask.h"
#include "spi_flash_fatfs.h"

/* Dimentions a buffer to be used by the UART driver, if the UART driver uses a
buffer at all. */
#define cmdQUEUE_LENGTH			1024

/* DEL acts as a backspace. */
#define cmdASCII_DEL		    ( 0x7F )

/* The maximum time to wait for the mutex that guards the UART to become
available. */
#define cmdMAX_MUTEX_WAIT		pdMS_TO_TICKS( 300 )

/* Dimensions the buffer into which input characters are placed. */
#define cmdMAX_INPUT_SIZE		50

/* Misc defines. */
#define serINVALID_QUEUE		( ( QueueHandle_t ) 0 )
#define serNO_BLOCK				( ( TickType_t ) 0 )
#define serTX_BLOCK_TIME		( 40 / portTICK_PERIOD_MS )
/*
**********************************************************************************************************
											函数声明
**********************************************************************************************************
*/


/*
**********************************************************************************************************
											变量声明
**********************************************************************************************************
*/
static TaskHandle_t xHandleTaskUserKeyIF = NULL;
//static TaskHandle_t xHandleTaskFsDebug = NULL;
//static TaskHandle_t xHandleTaskMsgPro = NULL;
static TaskHandle_t xHandleTaskStart = NULL;
//static TaskHandle_t xHandleTaskAdcProc = NULL;

static SemaphoreHandle_t  xMutex = NULL;
static SemaphoreHandle_t  xSemaphore_key_interupt = NULL;

/* The queue used to hold received characters. */
static QueueHandle_t xRxedChars;
static QueueHandle_t xCharsForTx;

/* Used to guard access to the UART in case messages are sent to the UART from
more than one task. */
static SemaphoreHandle_t xTxMutex = NULL;

/* Const messages output by the command console. */
static const char * const pcWelcomeMessage1 = "FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n";
static const char * const pcWelcomeMessage2 = "[Press ENTER to execute the previous command again]\r\n\r\n";
static const char * const pcEndOfOutputMessage = "cli@FreeRTOS->";
static const char * const pcNewLine = "\r\n";

SLEEP_DATA_T gSleep_Data = {2017,1,1,7,12,0,0,0,0,0};

/*
*********************************************************************************************************
*	函 数 名: vTaskGUI
*	功能说明: emWin任务
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 1   (数值越小优先级越低，这个跟uCOS相反)
*********************************************************************************************************
*/
static void vTaskGUI(void *pvParameters)
{
    printf("Main GUI Thread start.\r\n");
	while (1)
	{
		MainTask();
		vTaskDelay(1000);
	}
    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。
    传入NULL参数表示删除 的是当前任务 */
    //vTaskDelete( NULL );

}

/*
*********************************************************************************************************
*	函 数 名: vTaskAdcProc
*	功能说明: AD转换处理
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 2
*********************************************************************************************************
*/
//static void vTaskAdcProc(void *pvParameters)
//{

    //float uwVBATVoltage;    /* 板载电子电压 */
    //float ufVoltage_PA0;    /* PA0引脚电压  */
    //float ufVoltage_PC0;    /* PC0引脚电压  */
    //printf("ADC capture Thread start.\r\n");
    //while(1)
    //{
    //    vTaskDelay(1000);
        //uwVBATVoltage = ADC_ConvertedValue[1] * 3.3 / 4095;
        //ufVoltage_PA0 = ADC_ConvertedValue[2] * 3.3 / 4095;
        //ufVoltage_PC0 = ADC_ConvertedValue[3] * 3.3 / 4095;
       // GetTemp(ADC_ConvertedValue[0]);
    //}

    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。
    传入NULL参数表示删除 的是当前任务 */
    //vTaskDelete( NULL );
//}

/*
*********************************************************************************************************
*	函 数 名: vTaskTaskUserIF
*	功能说明: 按键消息处理
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 2
*********************************************************************************************************
*/
static void vTaskUserKeyIF(void *pvParameters)
{
	uint8_t ucKeyCode;
	uint8_t pcWriteBuffer[500];
    BaseType_t xResult;
    const TickType_t xMaxBlockTime = pdMS_TO_TICKS(1000); /* 设置最大等待时间为 300ms */

    printf("User Key Process Thread start.\r\n");

    while(1)
    {
        xResult = xSemaphoreTake(xSemaphore_key_interupt, (TickType_t)xMaxBlockTime);
        if(xResult == pdFALSE)
            continue;

        bsp_TouchKeyCodeValueProcess();   /* 中断到来后读取按键的KeyCode值*/

        /* 按键滤波和检测由后台systick中断服务程序实现，我们只需要调用bsp_GetKey读取键值即可。 */
		ucKeyCode = bsp_GetKey();  /* bsp_GetKey()读取键值, 无键按下时返回 KEY_NONE = 0 */

		if (ucKeyCode != KEY_NONE)
		{
		    //printf("\r\nPress Key Value %04x   ",ucKeyCode);
			switch (ucKeyCode)
			{
				/* K1键按下 打印任务执行情况 */
                case KEY_DOWN_DEBUG_LONG:
                    printf("Press Key: DEBUG LONG \r\n");
                    //GUI_SendKeyMsg(GUI_KEY_F2, 1);
                    //break;
				case KEY_DOWN_DEBUG:
                    if(ucKeyCode == KEY_DOWN_DEBUG)
                        printf("Press Key: DEBUG \r\n");
					printf("=================================================\r\n");
					printf("任务名      任务状态 优先级   剩余栈 任务序号\r\n");
					vTaskList((char *)&pcWriteBuffer);
					printf("%s\r\n", pcWriteBuffer);

					printf("\r\n任务名       运行计数         使用率\r\n");
					vTaskGetRunTimeStats((char *)&pcWriteBuffer);
					printf("%s\r\n", pcWriteBuffer);
					printf("当前动态内存剩余大小 = %d字节\r\n", xPortGetFreeHeapSize());
                    //GUI_SendKeyMsg(GUI_KEY_F2, 1);
					break;

				case KEY_DOWN_MUX:/* 锁屏 */
                    printf("Press Key: MUX \r\n");
                    GUI_SendKeyMsg(GUI_KEY_LockScreen, 1);
                    break;

                case KEY_DOWN_MUX_LONG:/* 解锁 */
                    printf("Press Key: MUX LONG\r\n");
                    GUI_SendKeyMsg(GUI_KEY_UnLock, 1);
                    break;

				/* K2键按下，实现截图功能，将图片以BMP格式保存到SD卡中 */
				case KEY_DOWN_VOL_DOWN:
                    printf("Press Key: VOL- \r\n");
                    GUI_SendKeyMsg(GUI_KEY_Vol_Dec, 1);
                    break;

                case KEY_DOWN_VOL_UP:
                    printf("Press Key: VOL+ \r\n");
					GUI_SendKeyMsg(GUI_KEY_Vol_Plus, 1);
					break;

                case KEY_DOWN_PLAY_PAUSE:/* 播放、确认 */
                    printf("Press Key: PLAY/PAUSE \r\n");
                    GUI_SendKeyMsg(GUI_KEY_PlayPause, 1);
                    break;

                case KEY_DOWN_PLAY_PAUSE_LONG:/* 选择功能 */
                    printf("Press Key: PLAY/PAUSE LONG\r\n");
                    GUI_SendKeyMsg(GUI_KEY_PlayPause_Long, 1);
                    break;

                case KEY_DOWN_MENU:/* 菜单 */
                    printf("Press Key: MENU \r\n");
                    GUI_SendKeyMsg(GUI_KEY_Menu, 1);
                    break;

                case KEY_DOWN_MENU_LONG:/* 直接进入睡眠模式 */
                    printf("Press Key: MENU LONG\r\n");
                    GUI_SendKeyMsg(GUI_KEY_Menu_Long, 1);
                    break;

                case KEY_DOWN_UP:/* 上一曲 */
                    printf("Press Key: UP \r\n");
                    GUI_SendKeyMsg(GUI_KEY_Direction_Up, 1);
                    break;

                case KEY_DOWN_UP_LONG:/* 快退 */
                    printf("Press Key: UP LONG\r\n");
                    GUI_SendKeyMsg(GUI_KEY_Direction_Left, 1);
                    break;

                case KEY_DOWN_DOWN:/* 下一曲 */
                    printf("Press Key: DOWN \r\n");
                    GUI_SendKeyMsg(GUI_KEY_Direction_Down, 1);
                    break;

                case KEY_DOWN_DOWN_LONG:/* 快进 */
                    printf("Press Key: DOWN LONG\r\n");
                    GUI_SendKeyMsg(GUI_KEY_Direction_Right, 1);
                    break;

				/* 其他的键值不处理 */
				default:
				    printf("Press Key: UNKNOW \r\n");
					break;
			}
		}

		vTaskDelay(20);
	}

    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。
    传入NULL参数表示删除 的是当前任务 */
    //vTaskDelete( NULL );

}

/*
*********************************************************************************************************
*	函 数 名: vTaskStart
*	功能说明: 启动任务，也就是最高优先级任务。主要实现按键检测和触摸检测。
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 5
*********************************************************************************************************
*/
static void vTaskStart(void *pvParameters)
{
    TickType_t tick_current = 0;
    TickType_t tick_backup = 0;
    TickType_t td_tick_backup = 0;

    printf("vTaskStart Thread start.\r\n");

    tick_backup = xTaskGetTickCount();
    while(1)
    {
        tick_current = xTaskGetTickCount();
		/* 10ms一次按键检测 */

		if(tick_current - tick_backup >= 10)
		{
		    tick_backup = tick_current;

            //gSleep_Data.TempVal += getCurent_IntTempValue();
            gSleep_Data.TempVal = getCurent_ExtTempValue();
            gSleep_Data.LightVal = getLightVLuxValue();
            gSleep_Data.NoisVal = getMicAmp_dBValue();
		}

        if(tick_current - td_tick_backup >= 250)
		{
		    td_tick_backup = tick_current;

			bsp_RTC_GetClock();
            gSleep_Data.Year = g_tRTC.Year;
            gSleep_Data.Mon = g_tRTC.Mon;
            gSleep_Data.Day = g_tRTC.Day;
            gSleep_Data.Week = g_tRTC.Week;
            gSleep_Data.Hour = g_tRTC.Hour;
            gSleep_Data.Min = g_tRTC.Min;
            gSleep_Data.Sec = g_tRTC.Sec;
		}

		vTaskDelay(50);
	}

    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。
    传入NULL参数表示删除 的是当前任务 */
    //vTaskDelete( NULL );
}

/*
*********************************************************************************************************
*	函 数 名: vTaskFsDebug
*	功能说明: FatFs调试
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 2
*********************************************************************************************************
*/
//static void vTaskFsDebug(void *pvParameters)
//{
//    printf("vTaskFsDebug Thread start.\r\n");

//    DemoFatFS();

    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。
    传入NULL参数表示删除 的是当前任务 */
//    vTaskDelete( NULL );
//}

/*
*********************************************************************************************************
*	函 数 名: vTaskAdcProc
*	功能说明: AD转换处理
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 2
*********************************************************************************************************
*/
#if 0
static void vTaskTest(void *pvParameters)
{
    printf("vTaskTest Thread start.\r\n");

    while(1)
    {
        vTaskDelay(100);
  #ifdef LCD_DRIVER_TEST
        LCD_Fill_Rect(0, 0, 320, 240, CL_BLUE);
        vTaskDelay(1000);
        LCD_Fill_Rect(0, 0, 320, 240, CL_YELLOW);
  #endif
        //GuiTaskTest();
    }

    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。
    传入NULL参数表示删除 的是当前任务 */
    //vTaskDelete( NULL );
}
#endif

static signed portBASE_TYPE xSerialGetChar( signed char *pcRxedChar, TickType_t xBlockTime )
{
    /* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
	{
		return pdTRUE;
	}
	else
	{
		return pdFALSE;
	}
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE xSerialPutChar( signed char cOutChar, TickType_t xBlockTime )
{
    signed portBASE_TYPE xReturn;

	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) == pdPASS )
	{
		xReturn = pdPASS;
		USART_ITConfig( USART1, USART_IT_TXE, ENABLE );
	}
	else
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
/*-----------------------------------------------------------*/

static void vSerialPutString( const signed char * const pcString, unsigned short usStringLength )
{
    signed char *pxNext;

	/* A couple of parameters that this port does not use. */
	( void ) usStringLength;

	/* NOTE: This implementation does not handle the queue being full as no
	block time is used! */

    /* Send each character in the string, one at a time. */
	pxNext = ( signed char * ) pcString;
	while( *pxNext )
	{
		xSerialPutChar( *pxNext, serNO_BLOCK );
		pxNext++;
	}
}
/*-----------------------------------------------------------*/



/*
*********************************************************************************************************
*	函 数 名: vTaskCmdLineConsole
*	功能说明: Command Line Interface Thread
*	形    参: pvParameters 是在创建该任务时传递的形参
*	返 回 值: 无
*   优 先 级: 1
*********************************************************************************************************
*/

static void vTaskCmdLineConsole( void *pvParameters )
{
    signed char cRxedChar;
    uint8_t ucInputIndex = 0;
    char *pcOutputString;
    static char cInputString[cmdMAX_INPUT_SIZE], cLastInputString[cmdMAX_INPUT_SIZE];
    BaseType_t xReturned;

	( void ) pvParameters;

    vRegisterSampleCLICommands();

	/* Obtain the address of the output buffer.  Note there is no mutual
	exclusion on this buffer as it is assumed only one command console interface
	will be used at any one time. */
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();

	/* Initialise the UART. */
	//xPort = xSerialPortInitMinimal( configCLI_BAUD_RATE, cmdQUEUE_LENGTH );

	/* Send the welcome message. */
	vSerialPutString( ( signed char * ) pcWelcomeMessage1, ( unsigned short ) strlen( pcWelcomeMessage1 ) );
	vSerialPutString( ( signed char * ) pcWelcomeMessage2, ( unsigned short ) strlen( pcWelcomeMessage2 ) );

	for( ;; )
	{
		/* Wait for the next character.  The while loop is used in case
		INCLUDE_vTaskSuspend is not set to 1 - in which case portMAX_DELAY will
		be a genuine block time rather than an infinite block time. */
		while( xSerialGetChar( &cRxedChar, portMAX_DELAY ) != pdPASS );

		/* Ensure exclusive access to the UART Tx. */
		if( xSemaphoreTake( xTxMutex, cmdMAX_MUTEX_WAIT ) == pdPASS )
		{
			/* Echo the character back. */
			xSerialPutChar( cRxedChar, portMAX_DELAY );

			/* Was it the end of the line? */
			if( cRxedChar == '\n' || cRxedChar == '\r' )
			{
				/* Just to space the output from the input. */
				vSerialPutString( ( signed char * ) pcNewLine, ( unsigned short ) strlen( pcNewLine ) );

				/* See if the command is empty, indicating that the last command
				is to be executed again. */
				if( ucInputIndex == 0 )
				{
					/* Copy the last command back into the input string. */
					strcpy( cInputString, cLastInputString );
				}

				/* Pass the received command to the command interpreter.  The
				command interpreter is called repeatedly until it returns
				pdFALSE	(indicating there is no more output) as it might
				generate more than one string. */
				do
				{
					/* Get the next output string from the command interpreter. */
					xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );

					/* Write the generated string to the UART. */
					vSerialPutString( ( signed char * ) pcOutputString, ( unsigned short ) strlen( pcOutputString ) );

				} while( xReturned != pdFALSE );

				/* All the strings generated by the input command have been
				sent.  Clear the input string ready to receive the next command.
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy( cLastInputString, cInputString );
				ucInputIndex = 0;
				memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );

				vSerialPutString( ( signed char * ) pcEndOfOutputMessage, ( unsigned short ) strlen( pcEndOfOutputMessage ) );
			}
			else
			{
				if( cRxedChar == '\r' )
				{
					/* Ignore the character. */
				}
				else if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
				{
					/* Backspace was pressed.  Erase the last character in the
					string - if any. */
					if( ucInputIndex > 0 )
					{
						ucInputIndex--;
						cInputString[ ucInputIndex ] = '\0';
					}
				}
				else
				{
					/* A character was entered.  Add it to the string entered so
					far.  When a \n is entered the complete	string will be
					passed to the command interpreter. */
					if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
					{
						if( ucInputIndex < cmdMAX_INPUT_SIZE )
						{
							cInputString[ ucInputIndex ] = cRxedChar;
							ucInputIndex++;
						}
					}
				}
			}

			/* Must ensure to give the mutex back. */
			xSemaphoreGive( xTxMutex );
		}
	}
}
/*-----------------------------------------------------------*/

/*
*********************************************************************************************************
*	函 数 名: AppTaskCreate
*	功能说明: 创建应用任务
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void AppTaskCreate (void)
{
    /* Create that task that handles the console itself. */
	xTaskCreate((TaskFunction_t )vTaskCmdLineConsole,	/* The task that implements the command console. */
				 (const char*    )"CLI",						/* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
				 (uint16_t       )1024,				/* The size of the stack allocated to the task. */
				 (void*          )NULL,						/* The parameter is not used, so NULL is passed. */
				 (UBaseType_t    )3,					/* The priority allocated to the task. */
				 (TaskHandle_t*  )NULL );						/* A handle is not required, so just pass NULL. */

    /* 按键事件处理 */
    xTaskCreate((TaskFunction_t )vTaskUserKeyIF,    /* 任务函数  */
                (const char*    )"vTaskUserKeyIF",      /* 任务名    */
                (uint16_t       )512,                   /* 任务栈大小，单位word，也就是4字节 */
                (void*          )NULL,                  /* 任务参数  */
                (UBaseType_t    )4,                     /* 任务优先级*/
                (TaskHandle_t*  )&xHandleTaskUserKeyIF );  /* 任务句柄  */

    /* GUI 界面绘制 */
	xTaskCreate((TaskFunction_t )vTaskGUI,             /* 任务函数  */
                (const char*    )"vTaskGUI",           /* 任务名    */
                (uint16_t       )1024,                 /* 任务栈大小，单位word，也就是4字节 */
                (void*          )NULL,                 /* 任务参数  */
                (UBaseType_t    )3,                    /* 任务优先级*/
                (TaskHandle_t*  )NULL );               /* 任务句柄  */
#if 0
	xTaskCreate((TaskFunction_t )vTaskFsDebug,    		/* 任务函数  */
                (const char*    )"vTaskFsDebug",  		/* 任务名    */
                (uint16_t       )1024,         		/* stack大小，单位word，也就是4字节 */
                (void*          )NULL,        		/* 任务参数  */
                (UBaseType_t    )3,           		/* 任务优先级*/
                (TaskHandle_t*  )&xHandleTaskFsDebug ); /* 任务句柄  */
#endif
	/* 定时任务 */
	xTaskCreate((TaskFunction_t )vTaskStart,     		/* 任务函数  */
                (const char*    )"vTaskStart",   		/* 任务名    */
                (uint16_t       )512,            		/* 任务栈大小，单位word，也就是4字节 */
                (void*          )NULL,           		/* 任务参数  */
                (UBaseType_t    )3,              		/* 任务优先级*/
                (TaskHandle_t*  )&xHandleTaskStart );   /* 任务句柄  */

    /* ADC 处理函数 */
	//xTaskCreate((TaskFunction_t )vTaskAdcProc,     		/* 任务函数  */
    //            (const char*    )"vTaskAdcProc",   		/* 任务名    */
    //            (uint16_t       )512,            		/* 任务栈大小，单位word，也就是4字节 */
    //            (void*          )NULL,           		/* 任务参数  */
    //            (UBaseType_t    )4,              		/* 任务优先级*/
    //            (TaskHandle_t*  )&xHandleTaskAdcProc );   /* 任务句柄  */
#if 0
    /* vTaskTest */
    xTaskCreate((TaskFunction_t )vTaskTest,     		/* 任务函数  */
                (const char*    )"vTaskTest",   		/* 任务名    */
                (uint16_t       )512,            		/* 任务栈大小，单位word，也就是4字节 */
                (void*          )NULL,           		/* 任务参数  */
                (UBaseType_t    )1,              		/* 任务优先级*/
                (TaskHandle_t*  )NULL );                /* 任务句柄  */
#endif
}

/*
*********************************************************************************************************
*	函 数 名: AppObjCreate
*	功能说明: 创建任务通信机制
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
static void AppObjCreate (void)
{
	/* 创建互斥信号量 */
    xMutex = xSemaphoreCreateMutex();
    //configASSERT( xMutex );
	if(xMutex == NULL)
    {
        /* 没有创建成功，用户可以在这里加入创建失败的处理机制 */
    }

    xSemaphore_key_interupt = xSemaphoreCreateBinary();
    //configASSERT( xSemaphore_key_interupt );
    if(xSemaphore_key_interupt == NULL)
    {
         /* 没有创建成功，用户可以在这里加入创建失败的处理机制 */
    }

    /* Create the queues used to hold Rx/Tx characters. */
	xRxedChars = xQueueCreate( 512, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
	xCharsForTx = xQueueCreate( 512 + 1, ( unsigned portBASE_TYPE ) sizeof( signed char ) );

    /* Create the semaphore used to access the UART Tx. */
	xTxMutex = xSemaphoreCreateMutex();
	//configASSERT( xTxMutex );
}

/*
*********************************************************************************************************
*	函 数 名: main
*	功能说明: 标准c程序入口。
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
int main(void)
{
	/*
	  在启动调度前，为了防止初始化STM32外设时有中断服务程序执行，这里禁止全局中断(除了NMI和HardFault)。
	  这样做的好处是：
	  1. 防止执行的中断服务程序中有FreeRTOS的API函数。
	  2. 保证系统正常启动，不受别的中断影响。
	  3. 关于是否关闭全局中断，大家根据自己的实际情况设置即可。
	  在移植文件port.c中的函数prvStartFirstTask中会重新开启全局中断。通过指令cpsie i开启，__set_PRIMASK(1)
	  和cpsie i是等效的。
     */
    __set_PRIMASK(1);

    /* 硬件初始化 */
	bsp_Init();

	/* 1. 初始化一个定时器中断，精度高于滴答定时器中断，这样才可以获得准确的系统信息 仅供调试目的，实际项
		  目中不要使用，因为这个功能比较影响系统实时性。
	   2. 为了正确获取FreeRTOS的调试信息，可以考虑将上面的关闭中断指令__set_PRIMASK(1); 注释掉。
	*/
	//vSetupSysInfoTest();

    /* 创建任务通信机制 */
    AppObjCreate();

	/* 创建任务 */
	AppTaskCreate();

    /* 启动调度，开始执行任务 */
    vTaskStartScheduler();

	/*
	  如果系统正常启动是不会运行到这里的，运行到这里极有可能是用于定时器任务或者空闲任务的
	  heap空间不足造成创建失败，此要加大FreeRTOSConfig.h文件中定义的heap大小：
	  #define configTOTAL_HEAP_SIZE	      ( ( size_t ) ( 17 * 1024 ) )
	*/
	while(1);
}

/*
*********************************************************************************************************
*	函 数 名: EXTI2_IRQHandler
*	功能说明: 外部中断服务程序
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void EXTI1_IRQHandler(void)
{

	if(EXTI_GetITStatus(EXTI_Line1) != RESET)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;

        /* 发送同步信号 */
        xSemaphoreGiveFromISR(xSemaphore_key_interupt, &xHigherPriorityTaskWoken);

        /* 如果 xHigherPriorityTaskWoken = pdTRUE，那么退出中断后切到当前最高优先级任务执行 */
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);

		//EXTI->IMR&=~(1<<1);	                /* 关闭中断       */
		EXTI_ClearITPendingBit(EXTI_Line1); /* 清除中断标志位 */
	}

}

void Debug_Uart_Cli_Handle(void)
{
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    char cChar;

    if( USART_GetITStatus( USART1, USART_IT_TXE ) == SET )
    {
        /* The interrupt was caused by the THR becoming empty.  Are there any
        more characters to transmit? */
        if( xQueueReceiveFromISR( xCharsForTx, &cChar, &xHigherPriorityTaskWoken ) == pdTRUE )
        {
            /* A character was retrieved from the queue so can be sent to the THR now. */
            USART_SendData( USART1, cChar );
        }
    }

    if( USART_GetITStatus( USART1, USART_IT_RXNE ) == SET )
    {
        cChar = USART_ReceiveData( USART1 );
        xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    }

    portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );

}
/***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/
