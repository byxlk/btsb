; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_i2c.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;656      */
;;;657    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;658    {
;;;659      /* Check the parameters */
;;;660      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;661      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;662      if (NewState != DISABLE)
;;;663      {
;;;664        /* Enable the selected I2C ARP */
;;;665        I2Cx->CR1 |= I2C_CR1_ENARP;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420210          ORR      r2,r2,#0x10
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L1.22|
                  |L1.12|
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Disable the selected I2C ARP */
;;;670        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L1.22|
;;;671      }
;;;672    }
000016  4770              BX       lr
;;;673    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;416      */
;;;417    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422      if (NewState != DISABLE)
;;;423      {
;;;424        /* Enable the acknowledgement */
;;;425        I2Cx->CR1 |= I2C_CR1_ACK;
000002  8802              LDRH     r2,[r0,#0]
000004  f4426280          ORR      r2,r2,#0x400
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;426      }
;;;427      else
;;;428      {
;;;429        /* Disable the acknowledgement */
;;;430        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f33ff          MOV      r3,#0xfbff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L2.22|
;;;431      }
;;;432    }
000016  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;793      */
;;;794    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;795    {
;;;796      /* Check the parameters */
;;;797      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;798      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;799      if (NewState != DISABLE)
;;;800      {
;;;801        /* Enable the selected I2C PEC calculation */
;;;802        I2Cx->CR1 |= I2C_CR1_ENPEC;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420220          ORR      r2,r2,#0x20
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;803      }
;;;804      else
;;;805      {
;;;806        /* Disable the selected I2C PEC calculation */
;;;807        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L3.22|
;;;808      }
;;;809    }
000016  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1096     */
;;;1097   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;1098   {
000002  4602              MOV      r2,r0
;;;1099     uint32_t lastevent = 0;
000004  2400              MOVS     r4,#0
;;;1100     uint32_t flag1 = 0, flag2 = 0;
000006  2500              MOVS     r5,#0
000008  2300              MOVS     r3,#0
;;;1101     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1102   
;;;1103     /* Check the parameters */
;;;1104     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1105     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1106   
;;;1107     /* Read the I2Cx status register */
;;;1108     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1109     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1110     flag2 = flag2 << 16;
000010  041b              LSLS     r3,r3,#16
;;;1111   
;;;1112     /* Get the last event value from I2C status register */
;;;1113     lastevent = (flag1 | flag2) & FLAG_MASK;
000012  ea450603          ORR      r6,r5,r3
000016  f026447f          BIC      r4,r6,#0xff000000
;;;1114   
;;;1115     /* Check whether the last event contains the I2C_EVENT */
;;;1116     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00001a  ea040601          AND      r6,r4,r1
00001e  428e              CMP      r6,r1
000020  d101              BNE      |L4.38|
;;;1117     {
;;;1118       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1119       status = SUCCESS;
000022  2001              MOVS     r0,#1
000024  e000              B        |L4.40|
                  |L4.38|
;;;1120     }
;;;1121     else
;;;1122     {
;;;1123       /* ERROR: last event is different from I2C_EVENT */
;;;1124       status = ERROR;
000026  2000              MOVS     r0,#0
                  |L4.40|
;;;1125     }
;;;1126     /* Return status */
;;;1127     return status;
;;;1128   }
000028  bd70              POP      {r4-r6,pc}
;;;1129   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1276     */
;;;1277   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1278   {
;;;1279     uint32_t flagpos = 0;
;;;1280     /* Check the parameters */
;;;1281     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1282     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1283     /* Get the I2C flag position */
;;;1284     flagpos = I2C_FLAG & FLAG_MASK;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1285     /* Clear the selected I2C flag */
;;;1286     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1287   }
00000a  4770              BX       lr
;;;1288   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1370     */
;;;1371   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  2200              MOVS     r2,#0
;;;1372   {
;;;1373     uint32_t flagpos = 0;
;;;1374     /* Check the parameters */
;;;1375     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1376     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1377   
;;;1378     /* Get the I2C flag position */
;;;1379     flagpos = I2C_IT & FLAG_MASK;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1380   
;;;1381     /* Clear the selected I2C flag */
;;;1382     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1383   }
00000a  4770              BX       lr
;;;1384   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;313      */
;;;314    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L7.12|
;;;315    {
;;;316      /* Check the parameters */
;;;317      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;318      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;319      if (NewState != DISABLE)
;;;320      {
;;;321        /* Enable the selected I2C peripheral */
;;;322        I2Cx->CR1 |= I2C_CR1_PE;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L7.22|
                  |L7.12|
;;;323      }
;;;324      else
;;;325      {
;;;326        /* Disable the selected I2C peripheral */
;;;327        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L7.22|
;;;328      }
;;;329    }
000016  4770              BX       lr
;;;330    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;848      */
;;;849    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;850    {
;;;851      /* Check the parameters */
;;;852      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;853      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;854      if (NewState != DISABLE)
;;;855      {
;;;856        /* Enable the selected I2C DMA requests */
;;;857        I2Cx->CR2 |= I2C_CR2_DMAEN;
000002  8882              LDRH     r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;858      }
;;;859      else
;;;860      {
;;;861        /* Disable the selected I2C DMA requests */
;;;862        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;863      }
;;;864    }
000016  4770              BX       lr
;;;865    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;872      */
;;;873    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;877      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;878      if (NewState != DISABLE)
;;;879      {
;;;880        /* Next DMA transfer is the last transfer */
;;;881        I2Cx->CR2 |= I2C_CR2_LAST;
000002  8882              LDRH     r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L9.22|
                  |L9.12|
;;;882      }
;;;883      else
;;;884      {
;;;885        /* Next DMA transfer is not the last transfer */
;;;886        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L9.22|
;;;887      }
;;;888    }
000016  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;137      */
;;;138    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;139    {
000002  4604              MOV      r4,r0
;;;140      /* Check the parameters */
;;;141      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;142    
;;;143      if (I2Cx == I2C1)
000004  4813              LDR      r0,|L10.84|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L10.30|
;;;144      {
;;;145        /* Enable I2C1 reset state */
;;;146        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;147        /* Release I2C1 from reset state */
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
000012  2100              MOVS     r1,#0
000014  f44f1000          MOV      r0,#0x200000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e018              B        |L10.80|
                  |L10.30|
;;;149      }
;;;150      else if (I2Cx == I2C2)
00001e  480e              LDR      r0,|L10.88|
000020  4284              CMP      r4,r0
000022  d109              BNE      |L10.56|
;;;151      {
;;;152        /* Enable I2C2 reset state */
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0588              LSLS     r0,r1,#22
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154        /* Release I2C2 from reset state */
;;;155        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
00002c  2100              MOVS     r1,#0
00002e  f44f0080          MOV      r0,#0x400000
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
000036  e00b              B        |L10.80|
                  |L10.56|
;;;156      }
;;;157      else 
;;;158      {
;;;159        if (I2Cx == I2C3)
000038  4808              LDR      r0,|L10.92|
00003a  4284              CMP      r4,r0
00003c  d108              BNE      |L10.80|
;;;160        {
;;;161          /* Enable I2C3 reset state */
;;;162          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  05c8              LSLS     r0,r1,#23
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;163          /* Release I2C3 from reset state */
;;;164          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
000046  2100              MOVS     r1,#0
000048  f44f0000          MOV      r0,#0x800000
00004c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L10.80|
;;;165        }
;;;166      }
;;;167    }
000050  bd10              POP      {r4,pc}
;;;168    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0x40005400
                  |L10.88|
                          DCD      0x40005800
                  |L10.92|
                          DCD      0x40005c00

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;466      */
;;;467    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;468    {
;;;469      /* Check the parameters */
;;;470      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;471      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;472      if (NewState != DISABLE)
;;;473      {
;;;474        /* Enable dual addressing mode */
;;;475        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L11.22|
                  |L11.12|
;;;476      }
;;;477      else
;;;478      {
;;;479        /* Disable dual addressing mode */
;;;480        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L11.22|
;;;481      }
;;;482    }
000016  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;566      */
;;;567    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;568    {
;;;569      /* Check the parameters */
;;;570      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;571      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;572      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d005              BEQ      |L12.18|
;;;573      {
;;;574        /* I2C fast mode Tlow/Thigh=2 */
;;;575        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b82              LDRH     r2,[r0,#0x1c]
000008  f64b73ff          MOV      r3,#0xbfff
00000c  401a              ANDS     r2,r2,r3
00000e  8382              STRH     r2,[r0,#0x1c]
000010  e003              B        |L12.26|
                  |L12.18|
;;;576      }
;;;577      else
;;;578      {
;;;579        /* I2C fast mode Tlow/Thigh=16/9 */
;;;580        I2Cx->CCR |= I2C_DutyCycle_16_9;
000012  8b82              LDRH     r2,[r0,#0x1c]
000014  f4424280          ORR      r2,r2,#0x4000
000018  8382              STRH     r2,[r0,#0x1c]
                  |L12.26|
;;;581      }
;;;582    }
00001a  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;490      */
;;;491    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      if (NewState != DISABLE)
;;;497      {
;;;498        /* Enable generall call */
;;;499        I2Cx->CR1 |= I2C_CR1_ENGC;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420240          ORR      r2,r2,#0x40
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable generall call */
;;;504        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73bf          MOV      r3,#0xffbf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L13.22|
;;;505      }
;;;506    }
000016  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;337      */
;;;338    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L14.12|
;;;339    {
;;;340      /* Check the parameters */
;;;341      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;342      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;343      if (NewState != DISABLE)
;;;344      {
;;;345        /* Generate a START condition */
;;;346        I2Cx->CR1 |= I2C_CR1_START;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427280          ORR      r2,r2,#0x100
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L14.22|
                  |L14.12|
;;;347      }
;;;348      else
;;;349      {
;;;350        /* Disable the START condition generation */
;;;351        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f63ff          MOV      r3,#0xfeff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L14.22|
;;;352      }
;;;353    }
000016  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;361      */
;;;362    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;363    {
;;;364      /* Check the parameters */
;;;365      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;366      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;367      if (NewState != DISABLE)
;;;368      {
;;;369        /* Generate a STOP condition */
;;;370        I2Cx->CR1 |= I2C_CR1_STOP;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427200          ORR      r2,r2,#0x200
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L15.22|
                  |L15.12|
;;;371      }
;;;372      else
;;;373      {
;;;374        /* Disable the STOP condition generation */
;;;375        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f53ff          MOV      r3,#0xfdff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L15.22|
;;;376      }
;;;377    }
000016  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1199     */
;;;1200   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1201   {
000002  4602              MOV      r2,r0
;;;1202     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1203     __IO uint32_t i2creg = 0, i2cxbase = 0;
000006  2300              MOVS     r3,#0
000008  9301              STR      r3,[sp,#4]
00000a  9300              STR      r3,[sp,#0]
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1207     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1208   
;;;1209     /* Get the I2Cx peripheral base address */
;;;1210     i2cxbase = (uint32_t)I2Cx;
00000c  9200              STR      r2,[sp,#0]
;;;1211     
;;;1212     /* Read flag register index */
;;;1213     i2creg = I2C_FLAG >> 28;
00000e  0f0b              LSRS     r3,r1,#28
000010  9301              STR      r3,[sp,#4]
;;;1214     
;;;1215     /* Get bit[23:0] of the flag */
;;;1216     I2C_FLAG &= FLAG_MASK;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1217     
;;;1218     if(i2creg != 0)
000016  9b01              LDR      r3,[sp,#4]
000018  b11b              CBZ      r3,|L16.34|
;;;1219     {
;;;1220       /* Get the I2Cx SR1 register address */
;;;1221       i2cxbase += 0x14;
00001a  9b00              LDR      r3,[sp,#0]
00001c  3314              ADDS     r3,r3,#0x14
00001e  9300              STR      r3,[sp,#0]
000020  e003              B        |L16.42|
                  |L16.34|
;;;1222     }
;;;1223     else
;;;1224     {
;;;1225       /* Flag in I2Cx SR2 Register */
;;;1226       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000022  0c09              LSRS     r1,r1,#16
;;;1227       /* Get the I2Cx SR2 register address */
;;;1228       i2cxbase += 0x18;
000024  9b00              LDR      r3,[sp,#0]
000026  3318              ADDS     r3,r3,#0x18
000028  9300              STR      r3,[sp,#0]
                  |L16.42|
;;;1229     }
;;;1230     
;;;1231     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00002a  9b00              LDR      r3,[sp,#0]
00002c  681b              LDR      r3,[r3,#0]
00002e  400b              ANDS     r3,r3,r1
000030  b10b              CBZ      r3,|L16.54|
;;;1232     {
;;;1233       /* I2C_FLAG is set */
;;;1234       bitstatus = SET;
000032  2001              MOVS     r0,#1
000034  e000              B        |L16.56|
                  |L16.54|
;;;1235     }
;;;1236     else
;;;1237     {
;;;1238       /* I2C_FLAG is reset */
;;;1239       bitstatus = RESET;
000036  2000              MOVS     r0,#0
                  |L16.56|
;;;1240     }
;;;1241     
;;;1242     /* Return the I2C_FLAG status */
;;;1243     return  bitstatus;
;;;1244   }
000038  bd0c              POP      {r2,r3,pc}
;;;1245   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1310     */
;;;1311   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1312   {
000002  4602              MOV      r2,r0
;;;1313     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1314     uint32_t enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;1315   
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1318     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1319   
;;;1320     /* Check if the interrupt source is enabled or not */
;;;1321     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000008  8894              LDRH     r4,[r2,#4]
00000a  f00165e0          AND      r5,r1,#0x7000000
00000e  ea044315          AND      r3,r4,r5,LSR #16
;;;1322     
;;;1323     /* Get bit[23:0] of the flag */
;;;1324     I2C_IT &= FLAG_MASK;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1325   
;;;1326     /* Check the status of the specified I2C flag */
;;;1327     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000016  8a94              LDRH     r4,[r2,#0x14]
000018  400c              ANDS     r4,r4,r1
00001a  b114              CBZ      r4,|L17.34|
00001c  b10b              CBZ      r3,|L17.34|
;;;1328     {
;;;1329       /* I2C_IT is set */
;;;1330       bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L17.36|
                  |L17.34|
;;;1331     }
;;;1332     else
;;;1333     {
;;;1334       /* I2C_IT is reset */
;;;1335       bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L17.36|
;;;1336     }
;;;1337     /* Return the I2C_IT status */
;;;1338     return  bitstatus;
;;;1339   }
000024  bd30              POP      {r4,r5,pc}
;;;1340   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1144     */
;;;1145   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1146   {
000002  4601              MOV      r1,r0
;;;1147     uint32_t lastevent = 0;
000004  2000              MOVS     r0,#0
;;;1148     uint32_t flag1 = 0, flag2 = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;1149   
;;;1150     /* Check the parameters */
;;;1151     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1152   
;;;1153     /* Read the I2Cx status register */
;;;1154     flag1 = I2Cx->SR1;
00000a  8a8b              LDRH     r3,[r1,#0x14]
;;;1155     flag2 = I2Cx->SR2;
00000c  8b0a              LDRH     r2,[r1,#0x18]
;;;1156     flag2 = flag2 << 16;
00000e  0412              LSLS     r2,r2,#16
;;;1157   
;;;1158     /* Get the last event value from I2C status register */
;;;1159     lastevent = (flag1 | flag2) & FLAG_MASK;
000010  ea430402          ORR      r4,r3,r2
000014  f024407f          BIC      r0,r4,#0xff000000
;;;1160   
;;;1161     /* Return status */
;;;1162     return lastevent;
;;;1163   }
000018  bd10              POP      {r4,pc}
;;;1164   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;815      */
;;;816    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;817    {
;;;818      /* Check the parameters */
;;;819      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;820      /* Return the selected I2C PEC value */
;;;821      return ((I2Cx->SR2) >> 8);
000002  8b08              LDRH     r0,[r1,#0x18]
000004  1200              ASRS     r0,r0,#8
;;;822    }
000006  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1037     */
;;;1038   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;1039   {
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1042     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1043     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1044     
;;;1045     if (NewState != DISABLE)
;;;1046     {
;;;1047       /* Enable the selected I2C interrupts */
;;;1048       I2Cx->CR2 |= I2C_IT;
000002  8883              LDRH     r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  8083              STRH     r3,[r0,#4]
000008  e002              B        |L20.16|
                  |L20.10|
;;;1049     }
;;;1050     else
;;;1051     {
;;;1052       /* Disable the selected I2C interrupts */
;;;1053       I2Cx->CR2 &= (uint16_t)~I2C_IT;
00000a  8883              LDRH     r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  8083              STRH     r3,[r0,#4]
                  |L20.16|
;;;1054     }
;;;1055   }
000010  4770              BX       lr
;;;1056   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;180      */
;;;181    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;182    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;183      uint16_t tmpreg = 0, freqrange = 0;
000008  2600              MOVS     r6,#0
00000a  46b1              MOV      r9,r6
;;;184      uint16_t result = 0x04;
00000c  2704              MOVS     r7,#4
;;;185      uint32_t pclk1 = 8000000;
00000e  f8df80cc          LDR      r8,|L21.220|
;;;186      RCC_ClocksTypeDef  rcc_clocks;
;;;187      /* Check the parameters */
;;;188      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;189      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;190      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;191      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;192      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;193      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;194      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;195    
;;;196    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;197      /* Get the I2Cx CR2 value */
;;;198      tmpreg = I2Cx->CR2;
000012  88a6              LDRH     r6,[r4,#4]
;;;199      /* Clear frequency FREQ[5:0] bits */
;;;200      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
000014  f64f70c0          MOV      r0,#0xffc0
000018  4006              ANDS     r6,r6,r0
;;;201      /* Get pclk1 frequency value */
;;;202      RCC_GetClocksFreq(&rcc_clocks);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       RCC_GetClocksFreq
;;;203      pclk1 = rcc_clocks.PCLK1_Frequency;
000020  f8dd8008          LDR      r8,[sp,#8]
;;;204      /* Set frequency bits depending on pclk1 value */
;;;205      freqrange = (uint16_t)(pclk1 / 1000000);
000024  482e              LDR      r0,|L21.224|
000026  fbb8f0f0          UDIV     r0,r8,r0
00002a  fa1ff980          UXTH     r9,r0
;;;206      tmpreg |= freqrange;
00002e  ea460609          ORR      r6,r6,r9
;;;207      /* Write to I2Cx CR2 */
;;;208      I2Cx->CR2 = tmpreg;
000032  80a6              STRH     r6,[r4,#4]
;;;209    
;;;210    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;211      /* Disable the selected I2C peripheral to configure TRISE */
;;;212      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000034  8820              LDRH     r0,[r4,#0]
000036  f64f71fe          MOV      r1,#0xfffe
00003a  4008              ANDS     r0,r0,r1
00003c  8020              STRH     r0,[r4,#0]
;;;213      /* Reset tmpreg value */
;;;214      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;215      tmpreg = 0;
00003e  2600              MOVS     r6,#0
;;;216    
;;;217      /* Configure speed in standard mode */
;;;218      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000040  4928              LDR      r1,|L21.228|
000042  6828              LDR      r0,[r5,#0]
000044  4288              CMP      r0,r1
000046  d80c              BHI      |L21.98|
;;;219      {
;;;220        /* Standard mode speed calculate */
;;;221        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000048  6828              LDR      r0,[r5,#0]
00004a  0040              LSLS     r0,r0,#1
00004c  fbb8f0f0          UDIV     r0,r8,r0
000050  b287              UXTH     r7,r0
;;;222        /* Test if CCR value is under 0x4*/
;;;223        if (result < 0x04)
000052  2f04              CMP      r7,#4
000054  da00              BGE      |L21.88|
;;;224        {
;;;225          /* Set minimum allowed value */
;;;226          result = 0x04;  
000056  2704              MOVS     r7,#4
                  |L21.88|
;;;227        }
;;;228        /* Set speed value for standard mode */
;;;229        tmpreg |= result;	  
000058  433e              ORRS     r6,r6,r7
;;;230        /* Set Maximum Rise Time for standard mode */
;;;231        I2Cx->TRISE = freqrange + 1; 
00005a  f1090001          ADD      r0,r9,#1
00005e  8420              STRH     r0,[r4,#0x20]
000060  e027              B        |L21.178|
                  |L21.98|
;;;232      }
;;;233      /* Configure speed in fast mode */
;;;234      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;235         input clock) must be a multiple of 10 MHz */
;;;236      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;237      {
;;;238        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000062  88e8              LDRH     r0,[r5,#6]
000064  f64b71ff          MOV      r1,#0xbfff
000068  4288              CMP      r0,r1
00006a  d106              BNE      |L21.122|
;;;239        {
;;;240          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;241          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00006c  6828              LDR      r0,[r5,#0]
00006e  eb000040          ADD      r0,r0,r0,LSL #1
000072  fbb8f0f0          UDIV     r0,r8,r0
000076  b287              UXTH     r7,r0
000078  e009              B        |L21.142|
                  |L21.122|
;;;242        }
;;;243        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;244        {
;;;245          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;246          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00007a  6828              LDR      r0,[r5,#0]
00007c  eb0001c0          ADD      r1,r0,r0,LSL #3
000080  eb011000          ADD      r0,r1,r0,LSL #4
000084  fbb8f0f0          UDIV     r0,r8,r0
000088  b287              UXTH     r7,r0
;;;247          /* Set DUTY bit */
;;;248          result |= I2C_DutyCycle_16_9;
00008a  f4474780          ORR      r7,r7,#0x4000
                  |L21.142|
;;;249        }
;;;250    
;;;251        /* Test if CCR value is under 0x1*/
;;;252        if ((result & I2C_CCR_CCR) == 0)
00008e  f3c7000b          UBFX     r0,r7,#0,#12
000092  b908              CBNZ     r0,|L21.152|
;;;253        {
;;;254          /* Set minimum allowed value */
;;;255          result |= (uint16_t)0x0001;  
000094  f0470701          ORR      r7,r7,#1
                  |L21.152|
;;;256        }
;;;257        /* Set speed value and set F/S bit for fast mode */
;;;258        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
000098  f4474000          ORR      r0,r7,#0x8000
00009c  4306              ORRS     r6,r6,r0
;;;259        /* Set Maximum Rise Time for fast mode */
;;;260        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
00009e  f44f7096          MOV      r0,#0x12c
0000a2  fb09f000          MUL      r0,r9,r0
0000a6  f44f717a          MOV      r1,#0x3e8
0000aa  fb90f0f1          SDIV     r0,r0,r1
0000ae  1c40              ADDS     r0,r0,#1
0000b0  8420              STRH     r0,[r4,#0x20]
                  |L21.178|
;;;261      }
;;;262    
;;;263      /* Write to I2Cx CCR */
;;;264      I2Cx->CCR = tmpreg;
0000b2  83a6              STRH     r6,[r4,#0x1c]
;;;265      /* Enable the selected I2C peripheral */
;;;266      I2Cx->CR1 |= I2C_CR1_PE;
0000b4  8820              LDRH     r0,[r4,#0]
0000b6  f0400001          ORR      r0,r0,#1
0000ba  8020              STRH     r0,[r4,#0]
;;;267    
;;;268    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;269      /* Get the I2Cx CR1 value */
;;;270      tmpreg = I2Cx->CR1;
0000bc  8826              LDRH     r6,[r4,#0]
;;;271      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;272      tmpreg &= CR1_CLEAR_MASK;
0000be  f64f30f5          MOV      r0,#0xfbf5
0000c2  4006              ANDS     r6,r6,r0
;;;273      /* Configure I2Cx: mode and acknowledgement */
;;;274      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;275      /* Set ACK bit according to I2C_Ack value */
;;;276      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000c4  88a8              LDRH     r0,[r5,#4]
0000c6  8969              LDRH     r1,[r5,#0xa]
0000c8  4308              ORRS     r0,r0,r1
0000ca  4306              ORRS     r6,r6,r0
;;;277      /* Write to I2Cx CR1 */
;;;278      I2Cx->CR1 = tmpreg;
0000cc  8026              STRH     r6,[r4,#0]
;;;279    
;;;280    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;281      /* Set I2Cx Own Address1 and acknowledged address */
;;;282      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000ce  89a8              LDRH     r0,[r5,#0xc]
0000d0  8929              LDRH     r1,[r5,#8]
0000d2  4308              ORRS     r0,r0,r1
0000d4  8120              STRH     r0,[r4,#8]
;;;283    }
0000d6  e8bd87ff          POP      {r0-r10,pc}
;;;284    
                          ENDP

0000da  0000              DCW      0x0000
                  |L21.220|
                          DCD      0x007a1200
                  |L21.224|
                          DCD      0x000f4240
                  |L21.228|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;604      */
;;;605    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;606    {
;;;607      /* Check the parameters */
;;;608      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;609      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;610      
;;;611      /* Check the input parameter */
;;;612      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000004  d104              BNE      |L22.16|
;;;613      {
;;;614        /* Next byte in shift register is the last received byte */
;;;615        I2Cx->CR1 |= I2C_NACKPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L22.26|
                  |L22.16|
;;;616      }
;;;617      else
;;;618      {
;;;619        /* Current byte in shift register is the last received byte */
;;;620        I2Cx->CR1 &= I2C_NACKPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L22.26|
;;;621      }
;;;622    }
00001a  4770              BX       lr
;;;623    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;439      */
;;;440    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  460a              MOV      r2,r1
;;;441    {
;;;442      uint16_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;443    
;;;444      /* Check the parameters */
;;;445      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;446    
;;;447      /* Get the old register value */
;;;448      tmpreg = I2Cx->OAR2;
000004  8981              LDRH     r1,[r0,#0xc]
;;;449    
;;;450      /* Reset I2Cx Own address2 bit [7:1] */
;;;451      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
000006  f64f7301          MOV      r3,#0xff01
00000a  4019              ANDS     r1,r1,r3
;;;452    
;;;453      /* Set I2Cx Own address2 */
;;;454      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
00000c  f00203fe          AND      r3,r2,#0xfe
000010  4319              ORRS     r1,r1,r3
;;;455    
;;;456      /* Store the new register value */
;;;457      I2Cx->OAR2 = tmpreg;
000012  8181              STRH     r1,[r0,#0xc]
;;;458    }
000014  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;769      */
;;;770    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;771    {
;;;772      /* Check the parameters */
;;;773      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;774      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;775      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d104              BNE      |L24.16|
;;;776      {
;;;777        /* Next byte in shift register is PEC */
;;;778        I2Cx->CR1 |= I2C_PECPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L24.26|
                  |L24.16|
;;;779      }
;;;780      else
;;;781      {
;;;782        /* Current byte in shift register is PEC */
;;;783        I2Cx->CR1 &= I2C_PECPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L24.26|
;;;784      }
;;;785    }
00001a  4770              BX       lr
;;;786    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1010     */
;;;1011   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;1012   {
000002  4602              MOV      r2,r0
;;;1013     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1014   
;;;1015     /* Check the parameters */
;;;1016     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1017     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1018   
;;;1019     tmp = (uint32_t) I2Cx;
000008  9200              STR      r2,[sp,#0]
;;;1020     tmp += I2C_Register;
00000a  9800              LDR      r0,[sp,#0]
00000c  4408              ADD      r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;1021   
;;;1022     /* Return the selected register value */
;;;1023     return (*(__IO uint16_t *) tmp);
000010  9800              LDR      r0,[sp,#0]
000012  8800              LDRH     r0,[r0,#0]
;;;1024   }
000014  bd08              POP      {r3,pc}
;;;1025   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;707      */
;;;708    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;709    {
;;;710      /* Check the parameters */
;;;711      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;712      /* Return the data in the DR register */
;;;713      return (uint8_t)I2Cx->DR;
000002  8a08              LDRH     r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;714    }
000006  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;632      */
;;;633    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;634    {
;;;635      /* Check the parameters */
;;;636      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;637      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;638      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d104              BNE      |L27.16|
;;;639      {
;;;640        /* Drive the SMBusAlert pin Low */
;;;641        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000006  8802              LDRH     r2,[r0,#0]
000008  f4425200          ORR      r2,r2,#0x2000
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L27.26|
                  |L27.16|
;;;642      }
;;;643      else
;;;644      {
;;;645        /* Drive the SMBusAlert pin High  */
;;;646        I2Cx->CR1 &= I2C_SMBusAlert_High;
000010  8802              LDRH     r2,[r0,#0]
000012  f64d73ff          MOV      r3,#0xdfff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L27.26|
;;;647      }
;;;648    }
00001a  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;389      */
;;;390    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;391    {
;;;392      /* Check the parameters */
;;;393      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;394      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;395      /* Test on the direction to set/reset the read/write bit */
;;;396      if (I2C_Direction != I2C_Direction_Transmitter)
;;;397      {
;;;398        /* Set the address bit0 for read */
;;;399        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L28.12|
                  |L28.8|
;;;400      }
;;;401      else
;;;402      {
;;;403        /* Reset the address bit0 for write */
;;;404        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L28.12|
;;;405      }
;;;406      /* Send the address */
;;;407      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;408    }
00000e  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;694      */
;;;695    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;696    {
;;;697      /* Check the parameters */
;;;698      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;699      /* Write in the DR register the data to be sent */
;;;700      I2Cx->DR = Data;
;;;701    }
000002  4770              BX       lr
;;;702    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;516      */
;;;517    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L30.12|
;;;518    {
;;;519      /* Check the parameters */
;;;520      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;522      if (NewState != DISABLE)
;;;523      {
;;;524        /* Peripheral under reset */
;;;525        I2Cx->CR1 |= I2C_CR1_SWRST;
000002  8802              LDRH     r2,[r0,#0]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8002              STRH     r2,[r0,#0]
00000a  e003              B        |L30.20|
                  |L30.12|
;;;526      }
;;;527      else
;;;528      {
;;;529        /* Peripheral not under reset */
;;;530        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8002              STRH     r2,[r0,#0]
                  |L30.20|
;;;531      }
;;;532    }
000014  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;540      */
;;;541    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b921              CBNZ     r1,|L31.12|
;;;542    {
;;;543      /* Check the parameters */
;;;544      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;545      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;546      if (NewState == DISABLE)
;;;547      {
;;;548        /* Enable the selected I2C Clock stretching */
;;;549        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L31.22|
                  |L31.12|
;;;550      }
;;;551      else
;;;552      {
;;;553        /* Disable the selected I2C Clock stretching */
;;;554        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L31.22|
;;;555      }
;;;556    }
000016  4770              BX       lr
;;;557    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;289      */
;;;290    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;291    {
;;;292    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;293      /* initialize the I2C_ClockSpeed member */
;;;294      I2C_InitStruct->I2C_ClockSpeed = 5000;
000004  6001              STR      r1,[r0,#0]
;;;295      /* Initialize the I2C_Mode member */
;;;296      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;297      /* Initialize the I2C_DutyCycle member */
;;;298      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b71ff          MOV      r1,#0xbfff
00000e  80c1              STRH     r1,[r0,#6]
;;;299      /* Initialize the I2C_OwnAddress1 member */
;;;300      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  2100              MOVS     r1,#0
000012  8101              STRH     r1,[r0,#8]
;;;301      /* Initialize the I2C_Ack member */
;;;302      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000014  8141              STRH     r1,[r0,#0xa]
;;;303      /* Initialize the I2C_AcknowledgedAddress member */
;;;304      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000016  f44f4180          MOV      r1,#0x4000
00001a  8181              STRH     r1,[r0,#0xc]
;;;305    }
00001c  4770              BX       lr
;;;306    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;738      */
;;;739    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L33.12|
;;;740    {
;;;741      /* Check the parameters */
;;;742      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;743      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;744      if (NewState != DISABLE)
;;;745      {
;;;746        /* Enable the selected I2C PEC transmission */
;;;747        I2Cx->CR1 |= I2C_CR1_PEC;
000002  8802              LDRH     r2,[r0,#0]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L33.22|
                  |L33.12|
;;;748      }
;;;749      else
;;;750      {
;;;751        /* Disable the selected I2C PEC transmission */
;;;752        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L33.22|
;;;753      }
;;;754    }
000016  4770              BX       lr
;;;755    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_i2c_c_7174d409____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f2xx_i2c_c_7174d409____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_i2c_c_7174d409____REVSH|
#line 402
|__asm___15_stm32f2xx_i2c_c_7174d409____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_i2c_c_7174d409____RRX|
#line 587
|__asm___15_stm32f2xx_i2c_c_7174d409____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
