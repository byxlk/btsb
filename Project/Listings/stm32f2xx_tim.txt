; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_tim.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\User\bsp -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\FatFS\src -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_tim.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3196     */
;;;3197   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3198                          uint16_t TIM_ICFilter)
;;;3199   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3200     uint16_t tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;3201   
;;;3202     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3203     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;3204     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;3205     tmpccer = TIMx->CCER;
000016  8c02              LDRH     r2,[r0,#0x20]
;;;3206   
;;;3207     /* Select the Input and set the filter */
;;;3208     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
000018  f64f760c          MOV      r6,#0xff0c
00001c  4031              ANDS     r1,r1,r6
;;;3209     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4331              ORRS     r1,r1,r6
;;;3210   
;;;3211     /* Select the Polarity and set the CC1E Bit */
;;;3212     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000028  f64f76f5          MOV      r6,#0xfff5
00002c  4032              ANDS     r2,r2,r6
;;;3213     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
00002e  f0440601          ORR      r6,r4,#1
000032  4332              ORRS     r2,r2,r6
;;;3214   
;;;3215     /* Write to TIMx CCMR1 and CCER registers */
;;;3216     TIMx->CCMR1 = tmpccmr1;
000034  8301              STRH     r1,[r0,#0x18]
;;;3217     TIMx->CCER = tmpccer;
000036  8402              STRH     r2,[r0,#0x20]
;;;3218   }
000038  bdf0              POP      {r4-r7,pc}
;;;3219   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3237     */
;;;3238   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3239                          uint16_t TIM_ICFilter)
;;;3240   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3241     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3242   
;;;3243     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3244     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3245     tmpccmr1 = TIMx->CCMR1;
000018  8b01              LDRH     r1,[r0,#0x18]
;;;3246     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3247     tmp = (uint16_t)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;3248   
;;;3249     /* Select the Input and set the filter */
;;;3250     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3251     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  4339              ORRS     r1,r1,r7
;;;3252     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  4339              ORRS     r1,r1,r7
;;;3253   
;;;3254     /* Select the Polarity and set the CC2E Bit */
;;;3255     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00003e  f64f775f          MOV      r7,#0xff5f
000042  403a              ANDS     r2,r2,r7
;;;3256     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
000044  f0460710          ORR      r7,r6,#0x10
000048  433a              ORRS     r2,r2,r7
;;;3257   
;;;3258     /* Write to TIMx CCMR1 and CCER registers */
;;;3259     TIMx->CCMR1 = tmpccmr1 ;
00004a  8301              STRH     r1,[r0,#0x18]
;;;3260     TIMx->CCER = tmpccer;
00004c  8402              STRH     r2,[r0,#0x20]
;;;3261   }
00004e  bdf0              POP      {r4-r7,pc}
;;;3262   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;3279     */
;;;3280   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3281                          uint16_t TIM_ICFilter)
;;;3282   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3283     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3284   
;;;3285     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3286     TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3287     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3288     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3289     tmp = (uint16_t)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;3290   
;;;3291     /* Select the Input and set the filter */
;;;3292     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
000024  f64f770c          MOV      r7,#0xff0c
000028  4039              ANDS     r1,r1,r7
;;;3293     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  4339              ORRS     r1,r1,r7
;;;3294   
;;;3295     /* Select the Polarity and set the CC3E Bit */
;;;3296     tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000036  f24f57ff          MOV      r7,#0xf5ff
00003a  403a              ANDS     r2,r2,r7
;;;3297     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
00003c  f4467780          ORR      r7,r6,#0x100
000040  433a              ORRS     r2,r2,r7
;;;3298   
;;;3299     /* Write to TIMx CCMR2 and CCER registers */
;;;3300     TIMx->CCMR2 = tmpccmr2;
000042  8381              STRH     r1,[r0,#0x1c]
;;;3301     TIMx->CCER = tmpccer;
000044  8402              STRH     r2,[r0,#0x20]
;;;3302   }
000046  bdf0              POP      {r4-r7,pc}
;;;3303   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;3320     */
;;;3321   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3322                          uint16_t TIM_ICFilter)
;;;3323   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;3324     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;3325   
;;;3326     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3327     TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;3328     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;3329     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;3330     tmp = (uint16_t)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;3331   
;;;3332     /* Select the Input and set the filter */
;;;3333     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;3334     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  4339              ORRS     r1,r1,r7
;;;3335     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea073703          AND      r7,r7,r3,LSL #12
00003c  4339              ORRS     r1,r1,r7
;;;3336   
;;;3337     /* Select the Polarity and set the CC4E Bit */
;;;3338     tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
00003e  f64577ff          MOV      r7,#0x5fff
000042  403a              ANDS     r2,r2,r7
;;;3339     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
000044  f4465780          ORR      r7,r6,#0x1000
000048  433a              ORRS     r2,r2,r7
;;;3340   
;;;3341     /* Write to TIMx CCMR2 and CCER registers */
;;;3342     TIMx->CCMR2 = tmpccmr2;
00004a  8381              STRH     r1,[r0,#0x1c]
;;;3343     TIMx->CCER = tmpccer ;
00004c  8402              STRH     r2,[r0,#0x20]
;;;3344   }
00004e  bdf0              POP      {r4-r7,pc}
;;;3345   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;521      */
;;;522    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527    
;;;528      if (NewState != DISABLE)
;;;529      {
;;;530        /* Set the ARR Preload Bit */
;;;531        TIMx->CR1 |= TIM_CR1_ARPE;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Reset the ARR Preload Bit */
;;;536        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;537      }
;;;538    }
000016  4770              BX       lr
;;;539    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;2216     */
;;;2217   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;2218   {
;;;2219     /* Check the parameters */
;;;2220     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2221     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2222     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2223     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2224     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2225     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2226     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2227   
;;;2228     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2229        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2230     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;2231                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2232                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2233                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2234   }
00001e  4770              BX       lr
;;;2235   
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;2241     */
;;;2242   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;2243   {
;;;2244     /* Set the default configuration */
;;;2245     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;2246     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;2247     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;2248     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;2249     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;2250     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;2251     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;2252   }
000010  4770              BX       lr
;;;2253   
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;2310     */
;;;2311   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;2312   { 
;;;2313     /* Check the parameters */
;;;2314     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2315     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2316     if (NewState != DISABLE)
;;;2317     {
;;;2318       /* Set the CCPC Bit */
;;;2319       TIMx->CR2 |= TIM_CR2_CCPC;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;2320     }
;;;2321     else
;;;2322     {
;;;2323       /* Reset the CCPC Bit */
;;;2324       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;2325     }
;;;2326   }
000016  4770              BX       lr
;;;2327   /**
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1783     */
;;;1784   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b530              PUSH     {r4,r5,lr}
;;;1785   {
;;;1786     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1787   
;;;1788     /* Check the parameters */
;;;1789     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1790     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1791     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1792   
;;;1793     tmp = CCER_CCE_SET << TIM_Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1794   
;;;1795     /* Reset the CCxE Bit */
;;;1796     TIMx->CCER &= (uint16_t)~ tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1797   
;;;1798     /* Set or reset the CCxE Bit */ 
;;;1799     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1800   }
00001c  bd30              POP      {r4,r5,pc}
;;;1801   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1813     */
;;;1814   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b530              PUSH     {r4,r5,lr}
;;;1815   {
;;;1816     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1817   
;;;1818     /* Check the parameters */
;;;1819     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1820     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1821     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1822   
;;;1823     tmp = CCER_CCNE_SET << TIM_Channel;
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1824   
;;;1825     /* Reset the CCxNE Bit */
;;;1826     TIMx->CCER &= (uint16_t) ~tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1827   
;;;1828     /* Set or reset the CCxNE Bit */ 
;;;1829     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1830   }
00001c  bd30              POP      {r4,r5,pc}
;;;1831   /**
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2480     */
;;;2481   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2482   {  
;;;2483     /* Check the parameters */
;;;2484     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2485      
;;;2486     /* Clear the flags */
;;;2487     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2488   }
000004  4770              BX       lr
;;;2489   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2549     */
;;;2550   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2551   {
;;;2552     /* Check the parameters */
;;;2553     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2554   
;;;2555     /* Clear the IT pending Bit */
;;;2556     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2557   }
000004  4770              BX       lr
;;;2558   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1473     */
;;;1474   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1475   {
;;;1476     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1477   
;;;1478     /* Check the parameters */
;;;1479     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1480     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1481   
;;;1482     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1483   
;;;1484     /* Reset the OC1CE Bit */
;;;1485     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1486   
;;;1487     /* Enable or Disable the Output Compare Clear Bit */
;;;1488     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1489   
;;;1490     /* Write to TIMx CCMR1 register */
;;;1491     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1492   }
000010  4770              BX       lr
;;;1493   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1503     */
;;;1504   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1505   {
;;;1506     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1507   
;;;1508     /* Check the parameters */
;;;1509     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1510     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1511   
;;;1512     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1513   
;;;1514     /* Reset the OC2CE Bit */
;;;1515     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1516   
;;;1517     /* Enable or Disable the Output Compare Clear Bit */
;;;1518     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1519   
;;;1520     /* Write to TIMx CCMR1 register */
;;;1521     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;1522   }
000016  4770              BX       lr
;;;1523   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1532     */
;;;1533   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1534   {
;;;1535     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1536   
;;;1537     /* Check the parameters */
;;;1538     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1539     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1540   
;;;1541     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1542   
;;;1543     /* Reset the OC3CE Bit */
;;;1544     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1545   
;;;1546     /* Enable or Disable the Output Compare Clear Bit */
;;;1547     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1548   
;;;1549     /* Write to TIMx CCMR2 register */
;;;1550     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1551   }
000010  4770              BX       lr
;;;1552   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1561     */
;;;1562   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1563   {
;;;1564     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1565   
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1568     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1569   
;;;1570     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1571   
;;;1572     /* Reset the OC4CE Bit */
;;;1573     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1574   
;;;1575     /* Enable or Disable the Output Compare Clear Bit */
;;;1576     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1577   
;;;1578     /* Write to TIMx CCMR2 register */
;;;1579     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;1580   }
000016  4770              BX       lr
;;;1581   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;591      */
;;;592    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;596      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;597      
;;;598      if (NewState != DISABLE)
;;;599      {
;;;600        /* Enable the TIM Counter */
;;;601        TIMx->CR1 |= TIM_CR1_CEN;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;602      }
;;;603      else
;;;604      {
;;;605        /* Disable the TIM Counter */
;;;606        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;607      }
;;;608    }
000016  4770              BX       lr
;;;609    /**
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;382      */
;;;383    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;384    {
;;;385      uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;386    
;;;387      /* Check the parameters */
;;;388      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;389      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;390    
;;;391      tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;392    
;;;393      /* Reset the CMS and DIR Bits */
;;;394      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;395    
;;;396      /* Set the Counter Mode */
;;;397      tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;398    
;;;399      /* Write to TIMx CR1 register */
;;;400      TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;401    }
000010  4770              BX       lr
;;;402    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;2260     */
;;;2261   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;2262   {
;;;2263     /* Check the parameters */
;;;2264     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266   
;;;2267     if (NewState != DISABLE)
;;;2268     {
;;;2269       /* Enable the TIM Main Output */
;;;2270       TIMx->BDTR |= TIM_BDTR_MOE;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable the TIM Main Output */
;;;2275       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;2276     }  
;;;2277   }
00001c  4770              BX       lr
;;;2278   
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2613     */
;;;2614   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;2615   { 
;;;2616     /* Check the parameters */
;;;2617     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2618     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2619     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2620     
;;;2621     if (NewState != DISABLE)
;;;2622     {
;;;2623       /* Enable the DMA sources */
;;;2624       TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;2625     }
;;;2626     else
;;;2627     {
;;;2628       /* Disable the DMA sources */
;;;2629       TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;2630     }
;;;2631   }
000010  4770              BX       lr
;;;2632   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2586     */
;;;2587   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;2588   {
;;;2589     /* Check the parameters */
;;;2590     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2591     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2592     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2593   
;;;2594     /* Set the DMA Base and the DMA Burst Length */
;;;2595     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;2596   }
000008  4770              BX       lr
;;;2597   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;199      */
;;;200    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;201    {
000002  4604              MOV      r4,r0
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;204     
;;;205      if (TIMx == TIM1)
000004  4855              LDR      r0,|L22.348|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L22.28|
;;;206      {
;;;207        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;208        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e09d              B        |L22.344|
                  |L22.28|
;;;209      } 
;;;210      else if (TIMx == TIM2) 
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L22.52|
;;;211      {     
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e091              B        |L22.344|
                  |L22.52|
;;;214      }  
;;;215      else if (TIMx == TIM3)
000034  484a              LDR      r0,|L22.352|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L22.76|
;;;216      { 
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e085              B        |L22.344|
                  |L22.76|
;;;219      }  
;;;220      else if (TIMx == TIM4)
00004c  4845              LDR      r0,|L22.356|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L22.100|
;;;221      { 
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e079              B        |L22.344|
                  |L22.100|
;;;224      }  
;;;225      else if (TIMx == TIM5)
000064  4840              LDR      r0,|L22.360|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L22.124|
;;;226      {      
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e06d              B        |L22.344|
                  |L22.124|
;;;229      }  
;;;230      else if (TIMx == TIM6)  
00007c  483b              LDR      r0,|L22.364|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L22.148|
;;;231      {    
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e061              B        |L22.344|
                  |L22.148|
;;;234      }  
;;;235      else if (TIMx == TIM7)
000094  4836              LDR      r0,|L22.368|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L22.172|
;;;236      {      
;;;237        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;238        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e055              B        |L22.344|
                  |L22.172|
;;;239      }  
;;;240      else if (TIMx == TIM8)
0000ac  4831              LDR      r0,|L22.372|
0000ae  4284              CMP      r4,r0
0000b0  d108              BNE      |L22.196|
;;;241      {      
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  2002              MOVS     r0,#2
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;243        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000ba  2100              MOVS     r1,#0
0000bc  2002              MOVS     r0,#2
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000c2  e049              B        |L22.344|
                  |L22.196|
;;;244      }  
;;;245      else if (TIMx == TIM9)
0000c4  482c              LDR      r0,|L22.376|
0000c6  4284              CMP      r4,r0
0000c8  d109              BNE      |L22.222|
;;;246      {      
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  0408              LSLS     r0,r1,#16
0000ce  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;248        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000d2  2100              MOVS     r1,#0
0000d4  f44f3080          MOV      r0,#0x10000
0000d8  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000dc  e03c              B        |L22.344|
                  |L22.222|
;;;249       }  
;;;250      else if (TIMx == TIM10)
0000de  4827              LDR      r0,|L22.380|
0000e0  4284              CMP      r4,r0
0000e2  d109              BNE      |L22.248|
;;;251      {      
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  0448              LSLS     r0,r1,#17
0000e8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;253        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000ec  2100              MOVS     r1,#0
0000ee  f44f3000          MOV      r0,#0x20000
0000f2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000f6  e02f              B        |L22.344|
                  |L22.248|
;;;254      }  
;;;255      else if (TIMx == TIM11) 
0000f8  4821              LDR      r0,|L22.384|
0000fa  4284              CMP      r4,r0
0000fc  d109              BNE      |L22.274|
;;;256      {     
;;;257        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  0488              LSLS     r0,r1,#18
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;258        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
000106  2100              MOVS     r1,#0
000108  f44f2080          MOV      r0,#0x40000
00010c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000110  e022              B        |L22.344|
                  |L22.274|
;;;259      }  
;;;260      else if (TIMx == TIM12)
000112  481c              LDR      r0,|L22.388|
000114  4284              CMP      r4,r0
000116  d108              BNE      |L22.298|
;;;261      {      
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000118  2101              MOVS     r1,#1
00011a  2040              MOVS     r0,#0x40
00011c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;263        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000120  2100              MOVS     r1,#0
000122  2040              MOVS     r0,#0x40
000124  f7fffffe          BL       RCC_APB1PeriphResetCmd
000128  e016              B        |L22.344|
                  |L22.298|
;;;264      }  
;;;265      else if (TIMx == TIM13) 
00012a  4817              LDR      r0,|L22.392|
00012c  4284              CMP      r4,r0
00012e  d108              BNE      |L22.322|
;;;266      {       
;;;267        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
000130  2101              MOVS     r1,#1
000132  2080              MOVS     r0,#0x80
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;268        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  2080              MOVS     r0,#0x80
00013c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000140  e00a              B        |L22.344|
                  |L22.322|
;;;269      }  
;;;270      else
;;;271      { 
;;;272        if (TIMx == TIM14) 
000142  4812              LDR      r0,|L22.396|
000144  4284              CMP      r4,r0
000146  d107              BNE      |L22.344|
;;;273        {     
;;;274          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000148  2101              MOVS     r1,#1
00014a  1580              ASRS     r0,r0,#22
00014c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;275          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
000150  2100              MOVS     r1,#0
000152  15a0              ASRS     r0,r4,#22
000154  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L22.344|
;;;276        }   
;;;277      }
;;;278    }
000158  bd10              POP      {r4,pc}
;;;279    
                          ENDP

00015a  0000              DCW      0x0000
                  |L22.348|
                          DCD      0x40010000
                  |L22.352|
                          DCD      0x40000400
                  |L22.356|
                          DCD      0x40000800
                  |L22.360|
                          DCD      0x40000c00
                  |L22.364|
                          DCD      0x40001000
                  |L22.368|
                          DCD      0x40001400
                  |L22.372|
                          DCD      0x40010400
                  |L22.376|
                          DCD      0x40014000
                  |L22.380|
                          DCD      0x40014400
                  |L22.384|
                          DCD      0x40014800
                  |L22.388|
                          DCD      0x40001800
                  |L22.392|
                          DCD      0x40001c00
                  |L22.396|
                          DCD      0x40002000

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2769     */
;;;2770   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2771                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2772   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;2773     uint16_t tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;2774   
;;;2775     /* Check the parameters */
;;;2776     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2777     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2778     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2779     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2780     /* Configure the ETR Clock source */
;;;2781     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;2782     
;;;2783     /* Get the TIMx SMCR register value */
;;;2784     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;2785   
;;;2786     /* Reset the SMS Bits */
;;;2787     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;2788   
;;;2789     /* Select the External clock mode1 */
;;;2790     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;2791   
;;;2792     /* Select the Trigger selection : ETRF */
;;;2793     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;2794     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;2795   
;;;2796     /* Write to TIMx SMCR */
;;;2797     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;2798   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;2799   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2816     */
;;;2817   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;2818                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2819   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2820     /* Check the parameters */
;;;2821     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2822     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2823     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2824     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2825   
;;;2826     /* Configure the ETR Clock source */
;;;2827     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;2828   
;;;2829     /* Enable the External clock mode2 */
;;;2830     TIMx->SMCR |= TIM_SMCR_ECE;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;2831   }
00001e  bdf0              POP      {r4-r7,pc}
;;;2832   /**
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;3004     */
;;;3005   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;3006                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3007   {
000002  460c              MOV      r4,r1
;;;3008     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;3009   
;;;3010     /* Check the parameters */
;;;3011     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3012     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3013     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3014     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3015   
;;;3016     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;3017   
;;;3018     /* Reset the ETR Bits */
;;;3019     tmpsmcr &= SMCR_ETR_MASK;
000008  b2c9              UXTB     r1,r1
;;;3020   
;;;3021     /* Set the Prescaler, the Filter value and the Polarity */
;;;3022     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00000a  f64f75ff          MOV      r5,#0xffff
00000e  ea052503          AND      r5,r5,r3,LSL #8
000012  4315              ORRS     r5,r5,r2
000014  4325              ORRS     r5,r5,r4
000016  4329              ORRS     r1,r1,r5
;;;3023   
;;;3024     /* Write to TIMx SMCR */
;;;3025     TIMx->SMCR = tmpsmcr;
000018  8101              STRH     r1,[r0,#8]
;;;3026   }
00001a  bd30              POP      {r4,r5,pc}
;;;3027   /**
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3062     */
;;;3063   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3064                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3065   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;3066     uint16_t tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;3067     uint16_t tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;3068     uint16_t tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;3069       
;;;3070     /* Check the parameters */
;;;3071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3072     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3073     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3074     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3075   
;;;3076     /* Get the TIMx SMCR register value */
;;;3077     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;3078   
;;;3079     /* Get the TIMx CCMR1 register value */
;;;3080     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;3081   
;;;3082     /* Get the TIMx CCER register value */
;;;3083     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;3084   
;;;3085     /* Set the encoder Mode */
;;;3086     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;3087     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;3088   
;;;3089     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3090     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;3091     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;3092   
;;;3093     /* Set the TI1 and the TI2 Polarities */
;;;3094     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;3095     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;3096   
;;;3097     /* Write to TIMx SMCR */
;;;3098     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;3099   
;;;3100     /* Write to TIMx CCMR1 */
;;;3101     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;3102   
;;;3103     /* Write to TIMx CCER */
;;;3104     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;3105   }
000040  bdf0              POP      {r4-r7,pc}
;;;3106   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1121     */
;;;1122   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1123   {
;;;1124     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1125   
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1128     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1129     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1130   
;;;1131     /* Reset the OC1M Bits */
;;;1132     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1133   
;;;1134     /* Configure The Forced output Mode */
;;;1135     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1136   
;;;1137     /* Write to TIMx CCMR1 register */
;;;1138     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1139   }
000010  4770              BX       lr
;;;1140   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1150     */
;;;1151   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1152   {
;;;1153     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1154   
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1157     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1158     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1159   
;;;1160     /* Reset the OC2M Bits */
;;;1161     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1162   
;;;1163     /* Configure The Forced output Mode */
;;;1164     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1165   
;;;1166     /* Write to TIMx CCMR1 register */
;;;1167     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1168   }
000018  4770              BX       lr
;;;1169   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1178     */
;;;1179   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1180   {
;;;1181     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1182   
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1185     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1186   
;;;1187     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1188   
;;;1189     /* Reset the OC1M Bits */
;;;1190     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1191   
;;;1192     /* Configure The Forced output Mode */
;;;1193     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1194   
;;;1195     /* Write to TIMx CCMR2 register */
;;;1196     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1197   }
000010  4770              BX       lr
;;;1198   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1207     */
;;;1208   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1209   {
;;;1210     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1211   
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1214     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1215     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1216   
;;;1217     /* Reset the OC2M Bits */
;;;1218     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1219   
;;;1220     /* Configure The Forced output Mode */
;;;1221     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1222   
;;;1223     /* Write to TIMx CCMR2 register */
;;;1224     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1225   }
000018  4770              BX       lr
;;;1226   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2405     */
;;;2406   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;2407   { 
;;;2408     /* Check the parameters */
;;;2409     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2410     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2411    
;;;2412     /* Set the event sources */
;;;2413     TIMx->EGR = TIM_EventSource;
;;;2414   }
000002  4770              BX       lr
;;;2415   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2027     */
;;;2028   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2029   {
;;;2030     /* Check the parameters */
;;;2031     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2032   
;;;2033     /* Get the Capture 1 Register value */
;;;2034     return TIMx->CCR1;
000002  6b48              LDR      r0,[r1,#0x34]
;;;2035   }
000004  4770              BX       lr
;;;2036   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2042     */
;;;2043   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2044   {
;;;2045     /* Check the parameters */
;;;2046     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2047   
;;;2048     /* Get the Capture 2 Register value */
;;;2049     return TIMx->CCR2;
000002  6b88              LDR      r0,[r1,#0x38]
;;;2050   }
000004  4770              BX       lr
;;;2051   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2056     */
;;;2057   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2058   {
;;;2059     /* Check the parameters */
;;;2060     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2061   
;;;2062     /* Get the Capture 3 Register value */
;;;2063     return TIMx->CCR3;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;2064   }
000004  4770              BX       lr
;;;2065   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2070     */
;;;2071   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2072   {
;;;2073     /* Check the parameters */
;;;2074     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2075   
;;;2076     /* Get the Capture 4 Register value */
;;;2077     return TIMx->CCR4;
000002  6c08              LDR      r0,[r1,#0x40]
;;;2078   }
000004  4770              BX       lr
;;;2079   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;437      */
;;;438    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;439    {
;;;440      /* Check the parameters */
;;;441      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;442    
;;;443      /* Get the Counter Register value */
;;;444      return TIMx->CNT;
000002  6a48              LDR      r0,[r1,#0x24]
;;;445    }
000004  4770              BX       lr
;;;446    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2438     */
;;;2439   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2440   { 
;;;2441     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2444     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2445   
;;;2446     
;;;2447     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;2448     {
;;;2449       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2450     }
;;;2451     else
;;;2452     {
;;;2453       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2454     }
;;;2455     return bitstatus;
;;;2456   }
000010  4770              BX       lr
;;;2457   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2508     */
;;;2509   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2510   {
000002  4602              MOV      r2,r0
;;;2511     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2512     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2515     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2516      
;;;2517     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2518     
;;;2519     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2520     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2521     {
;;;2522       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2523     }
;;;2524     else
;;;2525     {
;;;2526       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2527     }
;;;2528     return bitstatus;
;;;2529   }
000020  bd30              POP      {r4,r5,pc}
;;;2530   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;451      */
;;;452    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;456    
;;;457      /* Get the Prescaler Register value */
;;;458      return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;459    }
000004  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1895     */
;;;1896   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1897   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1898     /* Check the parameters */     
;;;1899     assert_param(IS_TIM_LIST1_PERIPH(TIMx));   
;;;1900     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1901     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1902     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1903     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1904     
;;;1905     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;1906     {
;;;1907       /* TI1 Configuration */
;;;1908       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;1909                  TIM_ICInitStruct->TIM_ICSelection,
;;;1910                  TIM_ICInitStruct->TIM_ICFilter);
;;;1911       /* Set the Input Capture Prescaler value */
;;;1912       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;1913     }
;;;1914     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;1915     {
;;;1916       /* TI2 Configuration */
;;;1917       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1918       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;1919                  TIM_ICInitStruct->TIM_ICSelection,
;;;1920                  TIM_ICInitStruct->TIM_ICFilter);
;;;1921       /* Set the Input Capture Prescaler value */
;;;1922       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;1923     }
;;;1924     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;1925     {
;;;1926       /* TI3 Configuration */
;;;1927       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1928       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;1929                  TIM_ICInitStruct->TIM_ICSelection,
;;;1930                  TIM_ICInitStruct->TIM_ICFilter);
;;;1931       /* Set the Input Capture Prescaler value */
;;;1932       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;1933     }
;;;1934     else
;;;1935     {
;;;1936       /* TI4 Configuration */ 
;;;1937       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1938       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;1939                  TIM_ICInitStruct->TIM_ICSelection,
;;;1940                  TIM_ICInitStruct->TIM_ICFilter);
;;;1941       /* Set the Input Capture Prescaler value */
;;;1942       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;1943     }
;;;1944   }
00006c  bd70              POP      {r4-r6,pc}
;;;1945   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1951     */
;;;1952   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1953   {
;;;1954     /* Set the default configuration */
;;;1955     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1956     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1957     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;1958     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;1959     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;1960   }
000010  4770              BX       lr
;;;1961   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2367     */
;;;2368   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;2369   {  
;;;2370     /* Check the parameters */
;;;2371     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2372     assert_param(IS_TIM_IT(TIM_IT));
;;;2373     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2374     
;;;2375     if (NewState != DISABLE)
;;;2376     {
;;;2377       /* Enable the Interrupt sources */
;;;2378       TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;2379     }
;;;2380     else
;;;2381     {
;;;2382       /* Disable the Interrupt sources */
;;;2383       TIMx->DIER &= (uint16_t)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;2384     }
;;;2385   }
000010  4770              BX       lr
;;;2386   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2699     */
;;;2700   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;2701   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2702     /* Check the parameters */
;;;2703     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2704     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2705   
;;;2706     /* Select the Internal Trigger */
;;;2707     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2708   
;;;2709     /* Select the External clock mode1 */
;;;2710     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;2711   }
000016  bd30              POP      {r4,r5,pc}
;;;2712   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2678     */
;;;2679   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2680   {
;;;2681     /* Check the parameters */
;;;2682     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2683   
;;;2684     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2685     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;2686   }
00000a  4770              BX       lr
;;;2687   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1352     */
;;;1353   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1354   {
;;;1355     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1356   
;;;1357     /* Check the parameters */
;;;1358     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1359     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1360   
;;;1361     /* Get the TIMx CCMR1 register value */
;;;1362     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1363   
;;;1364     /* Reset the OC1FE Bit */
;;;1365     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1366   
;;;1367     /* Enable or Disable the Output Compare Fast Bit */
;;;1368     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1369   
;;;1370     /* Write to TIMx CCMR1 */
;;;1371     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1372   }
000010  4770              BX       lr
;;;1373   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;670      */
;;;671    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;672    {
;;;673      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;674       
;;;675      /* Check the parameters */
;;;676      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;677      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;678      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;679      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;680    
;;;681      /* Disable the Channel 1: Reset the CC1E Bit */
;;;682      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;683      
;;;684      /* Get the TIMx CCER register value */
;;;685      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;686      /* Get the TIMx CR2 register value */
;;;687      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;688      
;;;689      /* Get the TIMx CCMR1 register value */
;;;690      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;691        
;;;692      /* Reset the Output Compare Mode Bits */
;;;693      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;694      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
00001e  1eb5              SUBS     r5,r6,#2
000020  402c              ANDS     r4,r4,r5
;;;695      /* Select the Output Compare Mode */
;;;696      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000022  880d              LDRH     r5,[r1,#0]
000024  432c              ORRS     r4,r4,r5
;;;697      
;;;698      /* Reset the Output Polarity level */
;;;699      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
000026  1e75              SUBS     r5,r6,#1
000028  402a              ANDS     r2,r2,r5
;;;700      /* Set the Output Compare Polarity */
;;;701      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00002a  898d              LDRH     r5,[r1,#0xc]
00002c  432a              ORRS     r2,r2,r5
;;;702      
;;;703      /* Set the Output State */
;;;704      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002e  884d              LDRH     r5,[r1,#2]
000030  432a              ORRS     r2,r2,r5
;;;705        
;;;706      if((TIMx == TIM1) || (TIMx == TIM8))
000032  4d10              LDR      r5,|L46.116|
000034  42a8              CMP      r0,r5
000036  d002              BEQ      |L46.62|
000038  4d0f              LDR      r5,|L46.120|
00003a  42a8              CMP      r0,r5
00003c  d113              BNE      |L46.102|
                  |L46.62|
;;;707      {
;;;708        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;709        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;710        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;711        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;712        
;;;713        /* Reset the Output N Polarity level */
;;;714        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
00003e  f64f75f7          MOV      r5,#0xfff7
000042  402a              ANDS     r2,r2,r5
;;;715        /* Set the Output N Polarity */
;;;716        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000044  89cd              LDRH     r5,[r1,#0xe]
000046  432a              ORRS     r2,r2,r5
;;;717        /* Reset the Output N State */
;;;718        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
000048  f64f75fb          MOV      r5,#0xfffb
00004c  402a              ANDS     r2,r2,r5
;;;719        
;;;720        /* Set the Output N State */
;;;721        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004e  888d              LDRH     r5,[r1,#4]
000050  432a              ORRS     r2,r2,r5
;;;722        /* Reset the Output Compare and Output Compare N IDLE State */
;;;723        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
000052  f64f65ff          MOV      r5,#0xfeff
000056  402b              ANDS     r3,r3,r5
;;;724        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
000058  f64f55ff          MOV      r5,#0xfdff
00005c  402b              ANDS     r3,r3,r5
;;;725        /* Set the Output Idle state */
;;;726        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  8a0d              LDRH     r5,[r1,#0x10]
000060  432b              ORRS     r3,r3,r5
;;;727        /* Set the Output N Idle state */
;;;728        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  8a4d              LDRH     r5,[r1,#0x12]
000064  432b              ORRS     r3,r3,r5
                  |L46.102|
;;;729      }
;;;730      /* Write to TIMx CR2 */
;;;731      TIMx->CR2 = tmpcr2;
000066  8083              STRH     r3,[r0,#4]
;;;732      
;;;733      /* Write to TIMx CCMR1 */
;;;734      TIMx->CCMR1 = tmpccmrx;
000068  8304              STRH     r4,[r0,#0x18]
;;;735      
;;;736      /* Set the Capture Compare Register value */
;;;737      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00006a  688d              LDR      r5,[r1,#8]
00006c  6345              STR      r5,[r0,#0x34]
;;;738      
;;;739      /* Write to TIMx CCER */
;;;740      TIMx->CCER = tmpccer;
00006e  8402              STRH     r2,[r0,#0x20]
;;;741    }
000070  bd70              POP      {r4-r6,pc}
;;;742    
                          ENDP

000072  0000              DCW      0x0000
                  |L46.116|
                          DCD      0x40010000
                  |L46.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1617     */
;;;1618   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1619   {
;;;1620     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1621     /* Check the parameters */
;;;1622     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1623     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1624      
;;;1625     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1626   
;;;1627     /* Set or Reset the CC1NP Bit */
;;;1628     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1629     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1630   
;;;1631     /* Write to TIMx CCER register */
;;;1632     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1633   }
000010  4770              BX       lr
;;;1634   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1590     */
;;;1591   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1592   {
;;;1593     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1594   
;;;1595     /* Check the parameters */
;;;1596     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1597     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1598   
;;;1599     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1600   
;;;1601     /* Set or Reset the CC1P Bit */
;;;1602     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;1603     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1604   
;;;1605     /* Write to TIMx CCER register */
;;;1606     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1607   }
000010  4770              BX       lr
;;;1608   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1235     */
;;;1236   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1237   {
;;;1238     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1239   
;;;1240     /* Check the parameters */
;;;1241     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1242     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1243   
;;;1244     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1245   
;;;1246     /* Reset the OC1PE Bit */
;;;1247     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1248   
;;;1249     /* Enable or Disable the Output Compare Preload feature */
;;;1250     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1251   
;;;1252     /* Write to TIMx CCMR1 register */
;;;1253     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1254   }
000010  4770              BX       lr
;;;1255   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1383     */
;;;1384   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1385   {
;;;1386     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1387   
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1390     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1391   
;;;1392     /* Get the TIMx CCMR1 register value */
;;;1393     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1394   
;;;1395     /* Reset the OC2FE Bit */
;;;1396     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1397   
;;;1398     /* Enable or Disable the Output Compare Fast Bit */
;;;1399     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1400   
;;;1401     /* Write to TIMx CCMR1 */
;;;1402     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1403   }
000018  4770              BX       lr
;;;1404   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;751      */
;;;752    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;753    {
;;;754      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;755       
;;;756      /* Check the parameters */
;;;757      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;758      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;759      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;760      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;761    
;;;762      /* Disable the Channel 2: Reset the CC2E Bit */
;;;763      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;764      
;;;765      /* Get the TIMx CCER register value */  
;;;766      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;767      /* Get the TIMx CR2 register value */
;;;768      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;769      
;;;770      /* Get the TIMx CCMR1 register value */
;;;771      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;772        
;;;773      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;774      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;775      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
00001e  f64f45ff          MOV      r5,#0xfcff
000022  402c              ANDS     r4,r4,r5
;;;776      
;;;777      /* Select the Output Compare Mode */
;;;778      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000024  880d              LDRH     r5,[r1,#0]
000026  f64f76ff          MOV      r6,#0xffff
00002a  ea062505          AND      r5,r6,r5,LSL #8
00002e  432c              ORRS     r4,r4,r5
;;;779      
;;;780      /* Reset the Output Polarity level */
;;;781      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
000030  f64f75df          MOV      r5,#0xffdf
000034  402a              ANDS     r2,r2,r5
;;;782      /* Set the Output Compare Polarity */
;;;783      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000036  898d              LDRH     r5,[r1,#0xc]
000038  ea061505          AND      r5,r6,r5,LSL #4
00003c  432a              ORRS     r2,r2,r5
;;;784      
;;;785      /* Set the Output State */
;;;786      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00003e  884d              LDRH     r5,[r1,#2]
000040  ea061505          AND      r5,r6,r5,LSL #4
000044  432a              ORRS     r2,r2,r5
;;;787        
;;;788      if((TIMx == TIM1) || (TIMx == TIM8))
000046  4d15              LDR      r5,|L51.156|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L51.82|
00004c  4d14              LDR      r5,|L51.160|
00004e  42a8              CMP      r0,r5
000050  d11d              BNE      |L51.142|
                  |L51.82|
;;;789      {
;;;790        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;791        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;792        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;793        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;794        
;;;795        /* Reset the Output N Polarity level */
;;;796        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000052  f64f757f          MOV      r5,#0xff7f
000056  402a              ANDS     r2,r2,r5
;;;797        /* Set the Output N Polarity */
;;;798        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000058  89cd              LDRH     r5,[r1,#0xe]
00005a  f64f76ff          MOV      r6,#0xffff
00005e  ea061505          AND      r5,r6,r5,LSL #4
000062  432a              ORRS     r2,r2,r5
;;;799        /* Reset the Output N State */
;;;800        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
000064  f64f75bf          MOV      r5,#0xffbf
000068  402a              ANDS     r2,r2,r5
;;;801        
;;;802        /* Set the Output N State */
;;;803        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
00006a  888d              LDRH     r5,[r1,#4]
00006c  ea061505          AND      r5,r6,r5,LSL #4
000070  432a              ORRS     r2,r2,r5
;;;804        /* Reset the Output Compare and Output Compare N IDLE State */
;;;805        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
000072  f64f35ff          MOV      r5,#0xfbff
000076  402b              ANDS     r3,r3,r5
;;;806        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
000078  f24f75ff          MOV      r5,#0xf7ff
00007c  402b              ANDS     r3,r3,r5
;;;807        /* Set the Output Idle state */
;;;808        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00007e  8a0d              LDRH     r5,[r1,#0x10]
000080  ea060585          AND      r5,r6,r5,LSL #2
000084  432b              ORRS     r3,r3,r5
;;;809        /* Set the Output N Idle state */
;;;810        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000086  8a4d              LDRH     r5,[r1,#0x12]
000088  ea060585          AND      r5,r6,r5,LSL #2
00008c  432b              ORRS     r3,r3,r5
                  |L51.142|
;;;811      }
;;;812      /* Write to TIMx CR2 */
;;;813      TIMx->CR2 = tmpcr2;
00008e  8083              STRH     r3,[r0,#4]
;;;814      
;;;815      /* Write to TIMx CCMR1 */
;;;816      TIMx->CCMR1 = tmpccmrx;
000090  8304              STRH     r4,[r0,#0x18]
;;;817      
;;;818      /* Set the Capture Compare Register value */
;;;819      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000092  688d              LDR      r5,[r1,#8]
000094  6385              STR      r5,[r0,#0x38]
;;;820      
;;;821      /* Write to TIMx CCER */
;;;822      TIMx->CCER = tmpccer;
000096  8402              STRH     r2,[r0,#0x20]
;;;823    }
000098  bd70              POP      {r4-r6,pc}
;;;824    
                          ENDP

00009a  0000              DCW      0x0000
                  |L51.156|
                          DCD      0x40010000
                  |L51.160|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1671     */
;;;1672   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1673   {
;;;1674     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1675   
;;;1676     /* Check the parameters */
;;;1677     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1678     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1679     
;;;1680     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1681   
;;;1682     /* Set or Reset the CC2NP Bit */
;;;1683     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1684     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1685   
;;;1686     /* Write to TIMx CCER register */
;;;1687     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1688   }
000018  4770              BX       lr
;;;1689   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1644     */
;;;1645   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1646   {
;;;1647     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1648   
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1651     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1652   
;;;1653     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1654   
;;;1655     /* Set or Reset the CC2P Bit */
;;;1656     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;1657     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1658   
;;;1659     /* Write to TIMx CCER register */
;;;1660     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1661   }
000018  4770              BX       lr
;;;1662   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1265     */
;;;1266   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1267   {
;;;1268     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1269   
;;;1270     /* Check the parameters */
;;;1271     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1272     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1273   
;;;1274     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1275   
;;;1276     /* Reset the OC2PE Bit */
;;;1277     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1278   
;;;1279     /* Enable or Disable the Output Compare Preload feature */
;;;1280     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1281   
;;;1282     /* Write to TIMx CCMR1 register */
;;;1283     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1284   }
000018  4770              BX       lr
;;;1285   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1413     */
;;;1414   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1415   {
;;;1416     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1417     
;;;1418     /* Check the parameters */
;;;1419     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1420     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1421   
;;;1422     /* Get the TIMx CCMR2 register value */
;;;1423     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1424   
;;;1425     /* Reset the OC3FE Bit */
;;;1426     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1427   
;;;1428     /* Enable or Disable the Output Compare Fast Bit */
;;;1429     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1430   
;;;1431     /* Write to TIMx CCMR2 */
;;;1432     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1433   }
000010  4770              BX       lr
;;;1434   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;832      */
;;;833    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;834    {
;;;835      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;836       
;;;837      /* Check the parameters */
;;;838      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;839      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;840      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;841      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;842    
;;;843      /* Disable the Channel 3: Reset the CC2E Bit */
;;;844      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;845      
;;;846      /* Get the TIMx CCER register value */
;;;847      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;848      /* Get the TIMx CR2 register value */
;;;849      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;850      
;;;851      /* Get the TIMx CCMR2 register value */
;;;852      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;853        
;;;854      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;855      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;856      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
00001e  f64f75fc          MOV      r5,#0xfffc
000022  402c              ANDS     r4,r4,r5
;;;857      /* Select the Output Compare Mode */
;;;858      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000024  880d              LDRH     r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
;;;859      
;;;860      /* Reset the Output Polarity level */
;;;861      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000028  f64f55ff          MOV      r5,#0xfdff
00002c  402a              ANDS     r2,r2,r5
;;;862      /* Set the Output Compare Polarity */
;;;863      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00002e  898d              LDRH     r5,[r1,#0xc]
000030  f64f76ff          MOV      r6,#0xffff
000034  ea062505          AND      r5,r6,r5,LSL #8
000038  432a              ORRS     r2,r2,r5
;;;864      
;;;865      /* Set the Output State */
;;;866      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00003a  884d              LDRH     r5,[r1,#2]
00003c  ea062505          AND      r5,r6,r5,LSL #8
000040  432a              ORRS     r2,r2,r5
;;;867        
;;;868      if((TIMx == TIM1) || (TIMx == TIM8))
000042  4d15              LDR      r5,|L56.152|
000044  42a8              CMP      r0,r5
000046  d002              BEQ      |L56.78|
000048  4d14              LDR      r5,|L56.156|
00004a  42a8              CMP      r0,r5
00004c  d11d              BNE      |L56.138|
                  |L56.78|
;;;869      {
;;;870        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;871        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;872        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;873        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;874        
;;;875        /* Reset the Output N Polarity level */
;;;876        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
00004e  f24f75ff          MOV      r5,#0xf7ff
000052  402a              ANDS     r2,r2,r5
;;;877        /* Set the Output N Polarity */
;;;878        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000054  89cd              LDRH     r5,[r1,#0xe]
000056  f64f76ff          MOV      r6,#0xffff
00005a  ea062505          AND      r5,r6,r5,LSL #8
00005e  432a              ORRS     r2,r2,r5
;;;879        /* Reset the Output N State */
;;;880        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
000060  f64f35ff          MOV      r5,#0xfbff
000064  402a              ANDS     r2,r2,r5
;;;881        
;;;882        /* Set the Output N State */
;;;883        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000066  888d              LDRH     r5,[r1,#4]
000068  ea062505          AND      r5,r6,r5,LSL #8
00006c  432a              ORRS     r2,r2,r5
;;;884        /* Reset the Output Compare and Output Compare N IDLE State */
;;;885        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
00006e  f64e75ff          MOV      r5,#0xefff
000072  402b              ANDS     r3,r3,r5
;;;886        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
000074  f64d75ff          MOV      r5,#0xdfff
000078  402b              ANDS     r3,r3,r5
;;;887        /* Set the Output Idle state */
;;;888        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
00007a  8a0d              LDRH     r5,[r1,#0x10]
00007c  ea061505          AND      r5,r6,r5,LSL #4
000080  432b              ORRS     r3,r3,r5
;;;889        /* Set the Output N Idle state */
;;;890        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000082  8a4d              LDRH     r5,[r1,#0x12]
000084  ea061505          AND      r5,r6,r5,LSL #4
000088  432b              ORRS     r3,r3,r5
                  |L56.138|
;;;891      }
;;;892      /* Write to TIMx CR2 */
;;;893      TIMx->CR2 = tmpcr2;
00008a  8083              STRH     r3,[r0,#4]
;;;894      
;;;895      /* Write to TIMx CCMR2 */
;;;896      TIMx->CCMR2 = tmpccmrx;
00008c  8384              STRH     r4,[r0,#0x1c]
;;;897      
;;;898      /* Set the Capture Compare Register value */
;;;899      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00008e  688d              LDR      r5,[r1,#8]
000090  63c5              STR      r5,[r0,#0x3c]
;;;900      
;;;901      /* Write to TIMx CCER */
;;;902      TIMx->CCER = tmpccer;
000092  8402              STRH     r2,[r0,#0x20]
;;;903    }
000094  bd70              POP      {r4-r6,pc}
;;;904    
                          ENDP

000096  0000              DCW      0x0000
                  |L56.152|
                          DCD      0x40010000
                  |L56.156|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1725     */
;;;1726   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1727   {
;;;1728     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1729    
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1733       
;;;1734     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1735   
;;;1736     /* Set or Reset the CC3NP Bit */
;;;1737     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1738     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1739   
;;;1740     /* Write to TIMx CCER register */
;;;1741     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1742   }
000018  4770              BX       lr
;;;1743   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1698     */
;;;1699   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1700   {
;;;1701     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1702   
;;;1703     /* Check the parameters */
;;;1704     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1705     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1706   
;;;1707     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1708   
;;;1709     /* Set or Reset the CC3P Bit */
;;;1710     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;1711     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1712   
;;;1713     /* Write to TIMx CCER register */
;;;1714     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1715   }
000018  4770              BX       lr
;;;1716   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1294     */
;;;1295   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1296   {
;;;1297     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1298   
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1301     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1302   
;;;1303     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1304   
;;;1305     /* Reset the OC3PE Bit */
;;;1306     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1307   
;;;1308     /* Enable or Disable the Output Compare Preload feature */
;;;1309     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1310   
;;;1311     /* Write to TIMx CCMR2 register */
;;;1312     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1313   }
000010  4770              BX       lr
;;;1314   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1443     */
;;;1444   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1445   {
;;;1446     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1447   
;;;1448     /* Check the parameters */
;;;1449     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1450     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1451   
;;;1452     /* Get the TIMx CCMR2 register value */
;;;1453     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1454   
;;;1455     /* Reset the OC4FE Bit */
;;;1456     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1457   
;;;1458     /* Enable or Disable the Output Compare Fast Bit */
;;;1459     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1460   
;;;1461     /* Write to TIMx CCMR2 */
;;;1462     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1463   }
000018  4770              BX       lr
;;;1464   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;912      */
;;;913    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;914    {
;;;915      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;916       
;;;917      /* Check the parameters */
;;;918      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;919      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;920      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;921      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;922    
;;;923      /* Disable the Channel 4: Reset the CC4E Bit */
;;;924      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;925      
;;;926      /* Get the TIMx CCER register value */
;;;927      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;928      /* Get the TIMx CR2 register value */
;;;929      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;930      
;;;931      /* Get the TIMx CCMR2 register value */
;;;932      tmpccmrx = TIMx->CCMR2;
000016  8b82              LDRH     r2,[r0,#0x1c]
;;;933        
;;;934      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;935      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402a              ANDS     r2,r2,r5
;;;936      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
00001e  f64f45ff          MOV      r5,#0xfcff
000022  402a              ANDS     r2,r2,r5
;;;937      
;;;938      /* Select the Output Compare Mode */
;;;939      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000024  880d              LDRH     r5,[r1,#0]
000026  f64f76ff          MOV      r6,#0xffff
00002a  ea062505          AND      r5,r6,r5,LSL #8
00002e  432a              ORRS     r2,r2,r5
;;;940      
;;;941      /* Reset the Output Polarity level */
;;;942      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000030  f64d75ff          MOV      r5,#0xdfff
000034  402b              ANDS     r3,r3,r5
;;;943      /* Set the Output Compare Polarity */
;;;944      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000036  898d              LDRH     r5,[r1,#0xc]
000038  ea063505          AND      r5,r6,r5,LSL #12
00003c  432b              ORRS     r3,r3,r5
;;;945      
;;;946      /* Set the Output State */
;;;947      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00003e  884d              LDRH     r5,[r1,#2]
000040  ea063505          AND      r5,r6,r5,LSL #12
000044  432b              ORRS     r3,r3,r5
;;;948      
;;;949      if((TIMx == TIM1) || (TIMx == TIM8))
000046  4d0a              LDR      r5,|L61.112|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L61.82|
00004c  4d09              LDR      r5,|L61.116|
00004e  42a8              CMP      r0,r5
000050  d108              BNE      |L61.100|
                  |L61.82|
;;;950      {
;;;951        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;952        /* Reset the Output Compare IDLE State */
;;;953        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
000052  f64b75ff          MOV      r5,#0xbfff
000056  402c              ANDS     r4,r4,r5
;;;954        /* Set the Output Idle state */
;;;955        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000058  8a0d              LDRH     r5,[r1,#0x10]
00005a  f64f76ff          MOV      r6,#0xffff
00005e  ea061585          AND      r5,r6,r5,LSL #6
000062  432c              ORRS     r4,r4,r5
                  |L61.100|
;;;956      }
;;;957      /* Write to TIMx CR2 */
;;;958      TIMx->CR2 = tmpcr2;
000064  8084              STRH     r4,[r0,#4]
;;;959      
;;;960      /* Write to TIMx CCMR2 */  
;;;961      TIMx->CCMR2 = tmpccmrx;
000066  8382              STRH     r2,[r0,#0x1c]
;;;962        
;;;963      /* Set the Capture Compare Register value */
;;;964      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000068  688d              LDR      r5,[r1,#8]
00006a  6405              STR      r5,[r0,#0x40]
;;;965      
;;;966      /* Write to TIMx CCER */
;;;967      TIMx->CCER = tmpccer;
00006c  8403              STRH     r3,[r0,#0x20]
;;;968    }
00006e  bd70              POP      {r4-r6,pc}
;;;969    
                          ENDP

                  |L61.112|
                          DCD      0x40010000
                  |L61.116|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1752     */
;;;1753   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1754   {
;;;1755     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1756   
;;;1757     /* Check the parameters */
;;;1758     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1759     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1760   
;;;1761     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1762   
;;;1763     /* Set or Reset the CC4P Bit */
;;;1764     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;1765     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;1766   
;;;1767     /* Write to TIMx CCER register */
;;;1768     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1769   }
000018  4770              BX       lr
;;;1770   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1323     */
;;;1324   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1325   {
;;;1326     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1327   
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1330     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1331   
;;;1332     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1333   
;;;1334     /* Reset the OC4PE Bit */
;;;1335     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1336   
;;;1337     /* Enable or Disable the Output Compare Preload feature */
;;;1338     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1339   
;;;1340     /* Write to TIMx CCMR2 register */
;;;1341     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1342   }
000018  4770              BX       lr
;;;1343   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;975      */
;;;976    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;977    {
;;;978      /* Set the default configuration */
;;;979      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;980      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;981      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;982      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
000008  6081              STR      r1,[r0,#8]
;;;983      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8181              STRH     r1,[r0,#0xc]
;;;984      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;985      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;986      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;987    }
000012  4770              BX       lr
;;;988    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1970     */
;;;1971   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1972   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1973     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;1974     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;1975   
;;;1976     /* Check the parameters */
;;;1977     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1978   
;;;1979     /* Select the Opposite Input Polarity */
;;;1980     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;1981     {
;;;1982       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;1983     }
;;;1984     else
;;;1985     {
;;;1986       icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;1987     }
;;;1988     /* Select the Opposite Input */
;;;1989     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;1990     {
;;;1991       icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;1992     }
;;;1993     else
;;;1994     {
;;;1995       icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;1996     }
;;;1997     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;1998     {
;;;1999       /* TI1 Configuration */
;;;2000       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;2001                  TIM_ICInitStruct->TIM_ICFilter);
;;;2002       /* Set the Input Capture Prescaler value */
;;;2003       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;2004       /* TI2 Configuration */
;;;2005       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;2006       /* Set the Input Capture Prescaler value */
;;;2007       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;2008     }
;;;2009     else
;;;2010     { 
;;;2011       /* TI2 Configuration */
;;;2012       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;2013                  TIM_ICInitStruct->TIM_ICFilter);
;;;2014       /* Set the Input Capture Prescaler value */
;;;2015       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2016       /* TI1 Configuration */
;;;2017       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;2018       /* Set the Input Capture Prescaler value */
;;;2019       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;2020     }
;;;2021   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;2022   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;359      */
;;;360    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;364      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;365      /* Set the Prescaler value */
;;;366      TIMx->PSC = Prescaler;
;;;367      /* Set or reset the UG Bit */
;;;368      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;369    }
000004  4770              BX       lr
;;;370    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;3165     */
;;;3166   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  f8a01050          STRH     r1,[r0,#0x50]
;;;3167   {
;;;3168    /* Check the parameters */
;;;3169     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3170     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3171   
;;;3172     /* Set the Timer remapping configuration */
;;;3173     TIMx->OR =  TIM_Remap;
;;;3174   }
000004  4770              BX       lr
;;;3175   /**
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2639     */
;;;2640   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;2641   {
;;;2642     /* Check the parameters */
;;;2643     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2644     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2645   
;;;2646     if (NewState != DISABLE)
;;;2647     {
;;;2648       /* Set the CCDS Bit */
;;;2649       TIMx->CR2 |= TIM_CR2_CCDS;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;2650     }
;;;2651     else
;;;2652     {
;;;2653       /* Reset the CCDS Bit */
;;;2654       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;2655     }
;;;2656   }
000016  4770              BX       lr
;;;2657   /**
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;2285     */
;;;2286   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2287   {
;;;2288     /* Check the parameters */
;;;2289     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2290     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2291   
;;;2292     if (NewState != DISABLE)
;;;2293     {
;;;2294       /* Set the COM Bit */
;;;2295       TIMx->CR2 |= TIM_CR2_CCUS;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2296     }
;;;2297     else
;;;2298     {
;;;2299       /* Reset the COM Bit */
;;;2300       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2301     }
;;;2302   }
000016  4770              BX       lr
;;;2303   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3114     */
;;;3115   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L70.12|
;;;3116   {
;;;3117     /* Check the parameters */
;;;3118     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3119     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3120   
;;;3121     if (NewState != DISABLE)
;;;3122     {
;;;3123       /* Set the TI1S Bit */
;;;3124       TIMx->CR2 |= TIM_CR2_TI1S;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L70.22|
                  |L70.12|
;;;3125     }
;;;3126     else
;;;3127     {
;;;3128       /* Reset the TI1S Bit */
;;;3129       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L70.22|
;;;3130     }
;;;3131   }
000016  4770              BX       lr
;;;3132   /**
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2884     */
;;;2885   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;2886   {
;;;2887     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;2888   
;;;2889     /* Check the parameters */
;;;2890     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2891     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2892   
;;;2893     /* Get the TIMx SMCR register value */
;;;2894     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;2895   
;;;2896     /* Reset the TS Bits */
;;;2897     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;2898   
;;;2899     /* Set the Input Trigger source */
;;;2900     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;2901   
;;;2902     /* Write to TIMx SMCR */
;;;2903     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;2904   }
000010  4770              BX       lr
;;;2905   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2974     */
;;;2975   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2976   {
;;;2977     /* Check the parameters */
;;;2978     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2979     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2980   
;;;2981     /* Reset the MSM Bit */
;;;2982     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2983     
;;;2984     /* Set or Reset the MSM Bit */
;;;2985     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2986   }
000010  4770              BX       lr
;;;2987   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;1011     */
;;;1012   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1013   {
000002  4603              MOV      r3,r0
;;;1014     uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;1015     uint16_t tmp1 = 0;
000006  2400              MOVS     r4,#0
;;;1016   
;;;1017     /* Check the parameters */
;;;1018     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1019     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1020     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1021   
;;;1022     tmp = (uint32_t) TIMx;
000008  4618              MOV      r0,r3
;;;1023     tmp += CCMR_OFFSET;
00000a  3018              ADDS     r0,r0,#0x18
;;;1024   
;;;1025     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  b2ac              UXTH     r4,r5
;;;1026   
;;;1027     /* Disable the Channel: Reset the CCxE Bit */
;;;1028     TIMx->CCER &= (uint16_t) ~tmp1;
000012  8c1d              LDRH     r5,[r3,#0x20]
000014  43a5              BICS     r5,r5,r4
000016  841d              STRH     r5,[r3,#0x20]
;;;1029   
;;;1030     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  b109              CBZ      r1,|L73.30|
00001a  2908              CMP      r1,#8
00001c  d10a              BNE      |L73.52|
                  |L73.30|
;;;1031     {
;;;1032       tmp += (TIM_Channel>>1);
00001e  eb000061          ADD      r0,r0,r1,ASR #1
;;;1033   
;;;1034       /* Reset the OCxM bits in the CCMRx register */
;;;1035       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
000022  6805              LDR      r5,[r0,#0]
000024  f64f768f          MOV      r6,#0xff8f
000028  4035              ANDS     r5,r5,r6
00002a  6005              STR      r5,[r0,#0]
;;;1036      
;;;1037       /* Configure the OCxM bits in the CCMRx register */
;;;1038       *(__IO uint32_t *) tmp |= TIM_OCMode;
00002c  6805              LDR      r5,[r0,#0]
00002e  4315              ORRS     r5,r5,r2
000030  6005              STR      r5,[r0,#0]
000032  e00f              B        |L73.84|
                  |L73.52|
;;;1039     }
;;;1040     else
;;;1041     {
;;;1042       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000034  1f0d              SUBS     r5,r1,#4
000036  f3c5054e          UBFX     r5,r5,#1,#15
00003a  4428              ADD      r0,r0,r5
;;;1043   
;;;1044       /* Reset the OCxM bits in the CCMRx register */
;;;1045       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
00003c  6805              LDR      r5,[r0,#0]
00003e  f64876ff          MOV      r6,#0x8fff
000042  4035              ANDS     r5,r5,r6
000044  6005              STR      r5,[r0,#0]
;;;1046       
;;;1047       /* Configure the OCxM bits in the CCMRx register */
;;;1048       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000046  6805              LDR      r5,[r0,#0]
000048  f64f76ff          MOV      r6,#0xffff
00004c  ea062602          AND      r6,r6,r2,LSL #8
000050  4335              ORRS     r5,r5,r6
000052  6005              STR      r5,[r0,#0]
                  |L73.84|
;;;1049     }
;;;1050   }
000054  bd70              POP      {r4-r6,pc}
;;;1051   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;548      */
;;;549    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;550    {
;;;551      /* Check the parameters */
;;;552      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;553      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;554    
;;;555      /* Reset the OPM Bit */
;;;556      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000002  f64f73f7          MOV      r3,#0xfff7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;557    
;;;558      /* Configure the OPM Mode */
;;;559      TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;560    }
000010  4770              BX       lr
;;;561    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2927     */
;;;2928   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2929   {
;;;2930     /* Check the parameters */
;;;2931     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2932     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2933   
;;;2934     /* Reset the MMS Bits */
;;;2935     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2936     /* Select the TRGO source */
;;;2937     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2938   }
000010  4770              BX       lr
;;;2939   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2951     */
;;;2952   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2953   {
;;;2954     /* Check the parameters */
;;;2955     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2956     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2957   
;;;2958     /* Reset the SMS Bits */
;;;2959     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2960   
;;;2961     /* Select the Slave Mode */
;;;2962     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2963   }
000010  4770              BX       lr
;;;2964   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;423      */
;;;424    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;428      
;;;429      /* Set the Autoreload Register value */
;;;430      TIMx->ARR = Autoreload;
;;;431    }
000002  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;571      */
;;;572    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;573    {
;;;574      /* Check the parameters */
;;;575      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;576      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;577    
;;;578      /* Reset the CKD Bits */
;;;579      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
000002  f64f43ff          MOV      r3,#0xfcff
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;580    
;;;581      /* Set the CKD value */
;;;582      TIMx->CR1 |= TIM_CKD;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;583    }
000010  4770              BX       lr
;;;584    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1057     */
;;;1058   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1059   {
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1062   
;;;1063     /* Set the Capture Compare1 Register value */
;;;1064     TIMx->CCR1 = Compare1;
;;;1065   }
000002  4770              BX       lr
;;;1066   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1073     */
;;;1074   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1075   {
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1078   
;;;1079     /* Set the Capture Compare2 Register value */
;;;1080     TIMx->CCR2 = Compare2;
;;;1081   }
000002  4770              BX       lr
;;;1082   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1088     */
;;;1089   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1090   {
;;;1091     /* Check the parameters */
;;;1092     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1093   
;;;1094     /* Set the Capture Compare3 Register value */
;;;1095     TIMx->CCR3 = Compare3;
;;;1096   }
000002  4770              BX       lr
;;;1097   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1103     */
;;;1104   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1105   {
;;;1106     /* Check the parameters */
;;;1107     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1108   
;;;1109     /* Set the Capture Compare4 Register value */
;;;1110     TIMx->CCR4 = Compare4;
;;;1111   }
000002  4770              BX       lr
;;;1112   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;408      */
;;;409    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;410    {
;;;411      /* Check the parameters */
;;;412       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;413    
;;;414      /* Set the Counter Register value */
;;;415      TIMx->CNT = Counter;
;;;416    }
000002  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2090     */
;;;2091   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2092   {
;;;2093     /* Check the parameters */
;;;2094     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2095     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2096   
;;;2097     /* Reset the IC1PSC Bits */
;;;2098     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2099   
;;;2100     /* Set the IC1PSC value */
;;;2101     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2102   }
000010  4770              BX       lr
;;;2103   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2115     */
;;;2116   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2117   {
;;;2118     /* Check the parameters */
;;;2119     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2120     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2121   
;;;2122     /* Reset the IC2PSC Bits */
;;;2123     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2124   
;;;2125     /* Set the IC2PSC value */
;;;2126     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2127   }
000018  4770              BX       lr
;;;2128   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2139     */
;;;2140   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2141   {
;;;2142     /* Check the parameters */
;;;2143     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2144     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2145   
;;;2146     /* Reset the IC3PSC Bits */
;;;2147     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2148   
;;;2149     /* Set the IC3PSC value */
;;;2150     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2151   }
000010  4770              BX       lr
;;;2152   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2163     */
;;;2164   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2165   {  
;;;2166     /* Check the parameters */
;;;2167     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2168     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2169   
;;;2170     /* Reset the IC4PSC Bits */
;;;2171     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2172   
;;;2173     /* Set the IC4PSC value */
;;;2174     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2175   }
000018  4770              BX       lr
;;;2176   /**
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2729     */
;;;2730   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2731                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2732   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2733     /* Check the parameters */
;;;2734     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2735     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2736     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2737   
;;;2738     /* Configure the Timer Input Clock Source */
;;;2739     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L88.30|
;;;2740     {
;;;2741       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L88.42|
                  |L88.30|
;;;2742     }
;;;2743     else
;;;2744     {
;;;2745       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L88.42|
;;;2746     }
;;;2747     /* Select the Trigger source */
;;;2748     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;2749     /* Select the External clock mode1 */
;;;2750     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;2751   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;2752   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;287      */
;;;288    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  2200              MOVS     r2,#0
;;;289    {
;;;290      uint16_t tmpcr1 = 0;
;;;291    
;;;292      /* Check the parameters */
;;;293      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;294      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;295      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;296    
;;;297      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;298    
;;;299      if((TIMx == TIM1) || (TIMx == TIM8)||
000004  4b18              LDR      r3,|L89.104|
000006  4298              CMP      r0,r3
000008  d00e              BEQ      |L89.40|
00000a  4b18              LDR      r3,|L89.108|
00000c  4298              CMP      r0,r3
00000e  d00b              BEQ      |L89.40|
;;;300         (TIMx == TIM2) || (TIMx == TIM3)||
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L89.40|
000016  4b16              LDR      r3,|L89.112|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L89.40|
;;;301         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4b15              LDR      r3,|L89.116|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L89.40|
000022  4b15              LDR      r3,|L89.120|
000024  4298              CMP      r0,r3
000026  d104              BNE      |L89.50|
                  |L89.40|
;;;302      {
;;;303        /* Select the Counter Mode */
;;;304        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000028  f64f738f          MOV      r3,#0xff8f
00002c  401a              ANDS     r2,r2,r3
;;;305        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002e  884b              LDRH     r3,[r1,#2]
000030  431a              ORRS     r2,r2,r3
                  |L89.50|
;;;306      }
;;;307     
;;;308      if((TIMx != TIM6) && (TIMx != TIM7))
000032  4b12              LDR      r3,|L89.124|
000034  4298              CMP      r0,r3
000036  d007              BEQ      |L89.72|
000038  4b11              LDR      r3,|L89.128|
00003a  4298              CMP      r0,r3
00003c  d004              BEQ      |L89.72|
;;;309      {
;;;310        /* Set the clock division */
;;;311        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
00003e  f64f43ff          MOV      r3,#0xfcff
000042  401a              ANDS     r2,r2,r3
;;;312        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000044  890b              LDRH     r3,[r1,#8]
000046  431a              ORRS     r2,r2,r3
                  |L89.72|
;;;313      }
;;;314    
;;;315      TIMx->CR1 = tmpcr1;
000048  8002              STRH     r2,[r0,#0]
;;;316    
;;;317      /* Set the Autoreload value */
;;;318      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
00004a  684b              LDR      r3,[r1,#4]
00004c  62c3              STR      r3,[r0,#0x2c]
;;;319     
;;;320      /* Set the Prescaler value */
;;;321      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004e  880b              LDRH     r3,[r1,#0]
000050  8503              STRH     r3,[r0,#0x28]
;;;322        
;;;323      if ((TIMx == TIM1) || (TIMx == TIM8))  
000052  4b05              LDR      r3,|L89.104|
000054  4298              CMP      r0,r3
000056  d002              BEQ      |L89.94|
000058  4b04              LDR      r3,|L89.108|
00005a  4298              CMP      r0,r3
00005c  d101              BNE      |L89.98|
                  |L89.94|
;;;324      {
;;;325        /* Set the Repetition Counter value */
;;;326        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00005e  7a8b              LDRB     r3,[r1,#0xa]
000060  8603              STRH     r3,[r0,#0x30]
                  |L89.98|
;;;327      }
;;;328    
;;;329      /* Generate an update event to reload the Prescaler 
;;;330         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;331      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000062  2301              MOVS     r3,#1
000064  8283              STRH     r3,[r0,#0x14]
;;;332    }
000066  4770              BX       lr
;;;333    
                          ENDP

                  |L89.104|
                          DCD      0x40010000
                  |L89.108|
                          DCD      0x40010400
                  |L89.112|
                          DCD      0x40000400
                  |L89.116|
                          DCD      0x40000800
                  |L89.120|
                          DCD      0x40000c00
                  |L89.124|
                          DCD      0x40001000
                  |L89.128|
                          DCD      0x40001400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;339      */
;;;340    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;341    {
;;;342      /* Set the default configuration */
;;;343      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
000004  6041              STR      r1,[r0,#4]
;;;344      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;345      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;346      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;347      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;348    }
000010  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;467      */
;;;468    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L91.12|
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473    
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Set the Update Disable Bit */
;;;477        TIMx->CR1 |= TIM_CR1_UDIS;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Reset the Update Disable Bit */
;;;482        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;483      }
;;;484    }
000016  4770              BX       lr
;;;485    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;496      */
;;;497    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L92.12|
;;;498    {
;;;499      /* Check the parameters */
;;;500      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;501      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;502    
;;;503      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;504      {
;;;505        /* Set the URS Bit */
;;;506        TIMx->CR1 |= TIM_CR1_URS;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L92.22|
                  |L92.12|
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Reset the URS Bit */
;;;511        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L92.22|
;;;512      }
;;;513    }
000016  4770              BX       lr
;;;514    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_tim_c_c458916b____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f2xx_tim_c_c458916b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_tim_c_c458916b____REVSH|
#line 402
|__asm___15_stm32f2xx_tim_c_c458916b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_tim_c_c458916b____RRX|
#line 587
|__asm___15_stm32f2xx_tim_c_c458916b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
