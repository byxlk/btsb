L 1 "..\User\emWinTask\MainTask.c"
N/*
N*********************************************************************************************************
N*	                                  
N*	模块名称 : GUI界面主函数
N*	文件名称 : MainTask.c
N*	版    本 : V1.0
N*	说    明 : 创建一个简单的GUI界面，使用的是官方实例，方便客户检测触摸。
N*	修改记录 :
N*		版本号   日期         作者          说明
N*		v1.0    2015-08-05  Eric2013  	    首版    
N*                                     
N*	Copyright (C), 2015-2020, 安富莱电子 www.armfly.com
N*
N*********************************************************************************************************
N*/
N#include "MainTask.h"
L 1 "..\User\emWinTask\MainTask.h" 1
N/*
N*********************************************************************************************************
N*	                                  
N*	模块名称 : GUI界面主函数
N*	文件名称 : MainTask.c
N*	版    本 : V1.0
N*	说    明 : GUI界面主函数
N*		版本号   日期         作者            说明
N*		v1.0    2015-08-05  Eric2013  	      首版
N
N*	Copyright (C), 2015-2020, 安富莱电子 www.armfly.com
N*
N*********************************************************************************************************
N*/
N
N#ifndef __MainTask_H
N#define __MainTask_H
N
N#include "GUI.h"
L 1 "..\STemWin\inc\GUI.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef  GUI_H
N#define  GUI_H
N
N#include "GUI_ConfDefaults.h"
L 1 "..\STemWin\inc\GUI_ConfDefaults.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\STemWin\Config\GUIConf.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures emWins abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N 
N#ifndef GUICONF_H
N#define GUICONF_H
N
N/*********************************************************************
N*
N*       Multi layer/display support
N*/
N#define GUI_NUM_LAYERS            2    // Maximum number of available layers
N
N/*********************************************************************
N*
N*       Multi tasking support
N*/
N#ifdef OS_SUPPORT
S #define GUI_OS                    (1)  // Compile with multitasking support
N#else
N #define GUI_OS                    (0)
N#endif
N
N/*********************************************************************
N*
N*       Configuration of touch support
N*/
N#ifndef   GUI_SUPPORT_TOUCH
N  #define GUI_SUPPORT_TOUCH       (0)  // Support touchscreen
N#endif
N
N/*********************************************************************
N*
N*       Default font
N*/
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N#define GUI_SUPPORT_MOUSE             (1)    /* Support a mouse */
N#define GUI_WINSUPPORT                (1)    /* Use window manager */
N#define GUI_SUPPORT_MEMDEV            (1)    /* Memory device package available */
N#define GUI_SUPPORT_DEVICES           (1)    /* Enable use of device pointers */
N
N#endif  /* Avoid multiple inclusion */
L 62 "..\STemWin\inc\GUI_ConfDefaults.h" 2
N
N#ifndef   LCD_MAX_LOG_COLORS
N  #define LCD_MAX_LOG_COLORS 256
N#else
S  #if (LCD_MAX_LOG_COLORS > 256)
S    #error The value of LCD_MAX_LOG_COLORS must be <= 256!
S  #endif
N#endif
N
N#define LCD_PIXELINDEX U32
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* ATTENTION: This define swaps the meaning of a logical color from
N   ABGR to ARGB.
N   
N   It further swaps the meaning of a transparent pixel:
N   ABGR: 0x00 means opaque, 0xFF means transparent (default)
N   ARGB: 0x00 means transparent, 0xFF means opaque
N*/
N//#ifndef GUI_USE_ARGB
N//  #define GUI_USE_ARGB 1
N//#endif
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR /* Remains only for compatibility purpose, no longer used in emWin */
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 1
N#endif
N
N#ifndef GUI_BIDI_MAX_CHARS_PER_LINE
N  #define GUI_BIDI_MAX_CHARS_PER_LINE 80
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
S  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_NUM_LAYERS
S  #define GUI_NUM_LAYERS      1
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef   GUI_CURSOR_LAYER
N  #define GUI_CURSOR_LAYER 0
N#endif
N
N#ifndef GUI_MEMCPY
N  #define GUI_MEMCPY(pDest, pSrc, NumBytes) memcpy(pDest, pSrc, NumBytes)
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #define GUI_SUPPORT_ROTATION 1
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) (void)para
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#define GUI_ALLOC_DATATYPE   I32
N#define GUI_ALLOC_DATATYPE_U U32
N
N#ifndef   GUI_MAX_XBF_BYTES
N  #define GUI_MAX_XBF_BYTES 200
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET GUI__memset
N#endif
N
N/* Optional custom drawing of memory devices */
N#ifndef   GUI_MEMDEV_SUPPORT_CUSTOMDRAW
N  #define GUI_MEMDEV_SUPPORT_CUSTOMDRAW 1
N#endif
N
N/* Clip static memory devices to parent borders */
N#ifndef   GUI_MEMDEV_CLIP_AT_PARENT
N  #define GUI_MEMDEV_CLIP_AT_PARENT 0
N#endif
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N
N/*************************** End of file ****************************/
L 58 "..\STemWin\inc\GUI.h" 2
N#include "GUI_Type.h"
L 1 "..\STemWin\inc\GUI_Type.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUI_Type.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\STemWin\inc\LCD.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_CONST_STORAGE */
N#include "Global.h"
L 1 "..\STemWin\inc\Global.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile    : GLOBAL.h
NPurpose : Global types etc.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#ifndef   U8
N  #define U8  unsigned char
N#endif
N#ifndef   U16
N  #define U16 unsigned short
N#endif
N#ifndef   U32
N  #define U32 unsigned long
N#endif
N#ifndef   I8
N  #define I8  signed char
N#endif
N#ifndef   I16
N  #define I16 signed short
N#endif
N#ifndef   I32
N  #define I32 signed long
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 59 "..\STemWin\inc\LCD.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N* The follwing are defines for types used in the LCD-driver and the
N* GUI layers on top of that. Since "C" does not provide data types of
N* fixed length which are identical on all platforms, this is done here.
N* For most 16/32 controllers, the settings will work fine. However, if
N* you have similar defines in other sections of your program, you might
N* want to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*********************************************************************
N*
N*       Settings for windows simulation
N*
N* Some settings in the configuration may conflict with the values required
N* in the Simulation. This is why we ignore the target settings for data
N* types and use the correct settings for the simulation.
N* (U32 could be defined as long, which would yield a 64 bit type on
N* the PC)
N*/
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif
N
N/*********************************************************************
N*
N*       Constants
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*********************************************************************
N*
N*       Drawing modes
N*/
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N/*********************************************************************
N*
N*       Typedefs
N*/
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N/*********************************************************************
N*
N*       Data structures
N*/
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N
Ntypedef struct {
N  int              NumEntries;
N  char             HasTrans;
N  const LCD_COLOR * pPalEntries;
N} LCD_LOGPALETTE;
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
Ntypedef struct {
N  int               NumEntries;
N  const LCD_COLOR * pPalEntries;
N} LCD_PHYSPALETTE;
N
N/*********************************************************************
N*
N*       LCD_L0_... color conversion
N*/
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (unsigned Index);
Ntypedef unsigned int   tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef unsigned int   tLCDDEV_GetIndexMask (void);
N
Ntypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, unsigned long NumItems, unsigned char SizeOfIndex);
Ntypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, unsigned long NumItems, unsigned char SizeOfIndex);
N
N/*********************************************************************
N*
N*       Color conversion API tables
N*/
Ntypedef struct {
N  tLCDDEV_Color2Index  * pfColor2Index;
N  tLCDDEV_Index2Color  * pfIndex2Color;
N  tLCDDEV_GetIndexMask * pfGetIndexMask;
N  int NoAlpha;
N  tLCDDEV_Color2IndexBulk * pfColor2IndexBulk;
N  tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_0;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_24;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_6;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1616I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_822216;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_84444;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_88666I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M1555I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M4444I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888I;
N
N#define GUICC_0         &LCD_API_ColorConv_0
N#define GUICC_1         &LCD_API_ColorConv_1
N#define GUICC_1_2       &LCD_API_ColorConv_1_2
N#define GUICC_1_4       &LCD_API_ColorConv_1_4
N#define GUICC_1_5       &LCD_API_ColorConv_1_5
N#define GUICC_1_8       &LCD_API_ColorConv_1_8
N#define GUICC_1_16      &LCD_API_ColorConv_1_16
N#define GUICC_1_24      &LCD_API_ColorConv_1_24
N#define GUICC_2         &LCD_API_ColorConv_2
N#define GUICC_4         &LCD_API_ColorConv_4
N#define GUICC_5         &LCD_API_ColorConv_5
N#define GUICC_6         &LCD_API_ColorConv_6
N#define GUICC_8         &LCD_API_ColorConv_8
N#define GUICC_16        &LCD_API_ColorConv_16
N#define GUICC_1616I     &LCD_API_ColorConv_1616I
N#define GUICC_111       &LCD_API_ColorConv_111
N#define GUICC_222       &LCD_API_ColorConv_222
N#define GUICC_233       &LCD_API_ColorConv_233
N#define GUICC_323       &LCD_API_ColorConv_323
N#define GUICC_332       &LCD_API_ColorConv_332
N#define GUICC_M4444I    &LCD_API_ColorConv_M4444I
N#define GUICC_444_12    &LCD_API_ColorConv_444_12
N#define GUICC_444_12_1  &LCD_API_ColorConv_444_12_1
N#define GUICC_444_16    &LCD_API_ColorConv_444_16
N#define GUICC_555       &LCD_API_ColorConv_555
N#define GUICC_565       &LCD_API_ColorConv_565
N#define GUICC_556       &LCD_API_ColorConv_556
N#define GUICC_655       &LCD_API_ColorConv_655
N#define GUICC_666       &LCD_API_ColorConv_666
N#define GUICC_666_9     &LCD_API_ColorConv_666_9
N#define GUICC_822216    &LCD_API_ColorConv_822216
N#define GUICC_84444     &LCD_API_ColorConv_84444
N#define GUICC_8666      &LCD_API_ColorConv_8666
N#define GUICC_8666_1    &LCD_API_ColorConv_8666_1
N#define GUICC_88666I    &LCD_API_ColorConv_88666I
N#define GUICC_888       &LCD_API_ColorConv_888
N#define GUICC_8888      &LCD_API_ColorConv_8888
N#define GUICC_M111      &LCD_API_ColorConv_M111
N#define GUICC_M1555I    &LCD_API_ColorConv_M1555I
N#define GUICC_M222      &LCD_API_ColorConv_M222
N#define GUICC_M233      &LCD_API_ColorConv_M233
N#define GUICC_M323      &LCD_API_ColorConv_M323
N#define GUICC_M332      &LCD_API_ColorConv_M332
N#define GUICC_M444_12   &LCD_API_ColorConv_M444_12
N#define GUICC_M444_12_1 &LCD_API_ColorConv_M444_12_1
N#define GUICC_M444_16   &LCD_API_ColorConv_M444_16
N#define GUICC_M555      &LCD_API_ColorConv_M555
N#define GUICC_M565      &LCD_API_ColorConv_M565
N#define GUICC_M556      &LCD_API_ColorConv_M556
N#define GUICC_M655      &LCD_API_ColorConv_M655
N#define GUICC_M666      &LCD_API_ColorConv_M666
N#define GUICC_M666_9    &LCD_API_ColorConv_M666_9
N#define GUICC_M8565     &LCD_API_ColorConv_M8565
N#define GUICC_M888      &LCD_API_ColorConv_M888
N#define GUICC_M8888     &LCD_API_ColorConv_M8888
N#define GUICC_M8888I    &LCD_API_ColorConv_M8888I
N
Nvoid GUICC_M1555I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M565_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M4444I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M888_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M8888I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
N
N/*********************************************************************
N*
N*       Compatibility defines for older versions
N*/
N#define GUI_COLOR_CONV_1    GUICC_1
N#define GUI_COLOR_CONV_2    GUICC_2
N#define GUI_COLOR_CONV_4    GUICC_4
N#define GUI_COLOR_CONV_8666 GUICC_8666
N#define GUI_COLOR_CONV_888  GUICC_888
N#define GUI_COLOR_CONV_8888 GUICC_8888
N#define GUI_COLOR_CONV_565  GUICC_565
N#define GUI_COLOR_CONV_M565 GUICC_M565
N
N/*********************************************************************
N*
N*       LCDDEV function table
N*
N*  Below the routines which need to in an LCDDEV routine table are
N*  defined. All of these routines have to be in the low-level driver
N*  (LCD_L0) or in the memory device which can be used to replace the
N*  driver.
N*  The one exception to this is the SetClipRect routine, which would
N*  be identical for all drivers and is therefor contained in the
N*  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawPixel    (int x, int y);
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT * pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
Ntypedef I32          tLCDDEV_GetDevProp   (int Index);
Xtypedef signed long          tLCDDEV_GetDevProp   (int Index);
Ntypedef void         tLCDDEV_SetOrg       (int x, int y);
N
N/*********************************************************************
N*
N*       Memory device API tables
N*/
Ntypedef struct GUI_DEVICE     GUI_DEVICE;
Ntypedef struct GUI_DEVICE_API GUI_DEVICE_API;
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 * pData, int Diff,
X                       const unsigned char * pData, int Diff,
N                       const void * pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings */
N#define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV_DEVICE_1
N#define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV_DEVICE_8
N#define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV_DEVICE_16
N#define GUI_MEMDEV_APILIST_32 &GUI_MEMDEV_DEVICE_32
N
N/*********************************************************************
N*
N*       Defines for device capabilities
N*
N* The following is the list of device capabilities which can, but do
N* not have to be implemented in the driver. This way the driver can be
N* enhanced in the future without affecting the driver interface,
N* keeping older drivers compatible.
N* More DevCaps can always be added in the future, as older drivers
N* are guaranteed to return 0 for all unimplemented features or queries.
N*
N* The values below define the legal parameters to the LCD_GetDeviceCaps
N* and the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_XSIZE             0x01    /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE             0x02    /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE            0x03    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE            0x04    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG              0x05    /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG              0x06    /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER        0x07    /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL      0x08    /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMCOLORS         0x09    /* Quest number of colors */
N#define LCD_DEVCAP_XMAG              0x0A
N#define LCD_DEVCAP_YMAG              0x0B
N#define LCD_DEVCAP_MIRROR_X          0x0C
N#define LCD_DEVCAP_MIRROR_Y          0x0D
N#define LCD_DEVCAP_SWAP_XY           0x0E
N#define LCD_DEVCAP_SWAP_RB           0x0F
N
Nint LCD_GetXSizeMax(void);
Nint LCD_GetYSizeMax(void);
Nint LCD_GetVXSizeMax(void);
Nint LCD_GetVYSizeMax(void);
Nint LCD_GetBitsPerPixelMax(void);
Nvoid LCD_SetDisplaySize(int xSizeDisplay, int ySizeDisplay);
Nint LCD_GetXSizeDisplay(void);
Nint LCD_GetYSizeDisplay(void);
N
Nint LCD_GetXSizeEx          (int LayerIndex);
Nint LCD_GetYSizeEx          (int LayerIndex);
Nint LCD_GetVXSizeEx         (int LayerIndex);
Nint LCD_GetVYSizeEx         (int LayerIndex);
Nint LCD_GetBitsPerPixelEx   (int LayerIndex);
NU32 LCD_GetNumColorsEx      (int LayerIndex);
Xunsigned long LCD_GetNumColorsEx      (int LayerIndex);
Nint LCD_GetXMagEx           (int LayerIndex);
Nint LCD_GetYMagEx           (int LayerIndex);
Nint LCD_GetMirrorXEx        (int LayerIndex);
Nint LCD_GetMirrorYEx        (int LayerIndex);
Nint LCD_GetSwapXYEx         (int LayerIndex);
Nint LCD_GetReversLUTEx      (int LayerIndex);
Nint LCD_GetPhysColorsInRAMEx(int LayerIndex);
N
Nint LCD_GetXSize            (void);
Nint LCD_GetYSize            (void);
Nint LCD_GetVXSize           (void);
Nint LCD_GetVYSize           (void);
Nint LCD_GetBitsPerPixel     (void);
NU32 LCD_GetNumColors        (void);
Xunsigned long LCD_GetNumColors        (void);
Nint LCD_GetXMag             (void);
Nint LCD_GetYMag             (void);
Nint LCD_GetMirrorX          (void);
Nint LCD_GetMirrorY          (void);
Nint LCD_GetSwapXY           (void);
Nint LCD_GetReversLUT        (void);
Nint LCD_GetPhysColorsInRAM  (void);
N
NI32 LCD__GetBPP      (U32 IndexMask);
Xsigned long LCD__GetBPP      (unsigned long IndexMask);
NI32 LCD__GetBPPDevice(U32 IndexMask);
Xsigned long LCD__GetBPPDevice(unsigned long IndexMask);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * LCD_GetpfColor2IndexEx(int LayerIndex);
N
NtLCDDEV_Color2Index * LCD_GetpfColor2Index(void);
N
Nint LCD_GetNumLayers(void);
N
NLCD_COLOR * LCD_GetPalette  (void);
NLCD_COLOR * LCD_GetPaletteEx(int LayerIndex);
N
Nvoid (* LCD_GetDevFunc(int LayerIndex, int Item))(void);
N
N/*********************************************************************
N*
N*       Values for requesting and setting function pointers (display driver)
N*/
N                                       /* Request of a function pointer for... */
N#define LCD_DEVFUNC_READRECT      0x01 /* ...reading a rectangular display area */
N#define LCD_DEVFUNC_SETALPHA      0x02 /* ...setting the alpha blending factor */
N#define LCD_DEVFUNC_SETPOS        0x03 /* ...setting the layer position */
N#define LCD_DEVFUNC_GETPOS        0x04 /* ...getting the layer position */
N#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
N#define LCD_DEVFUNC_SETVIS        0x06 /* ...setting the visibility of a layer */
N#define LCD_DEVFUNC_24BPP         0x07 /* ...drawing 24bpp bitmaps */
N#define LCD_DEVFUNC_NEXT_PIXEL    0x08 /* ...drawing a bitmap pixel by pixel */
N#define LCD_DEVFUNC_SET_VRAM_ADDR 0x09 /* ...setting the VRAM address */
N#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
N#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
N#define LCD_DEVFUNC_INIT          0x0C /* ...initializing the display controller */
N#define LCD_DEVFUNC_CONTROLCACHE  0x0D /* ...controlling the cache */
N#define LCD_DEVFUNC_ON            0x0E /* ...switching the display on */
N#define LCD_DEVFUNC_OFF           0x0F /* ...switching the display off */
N#define LCD_DEVFUNC_SETLUTENTRY   0x10 /* ...setting a LUT entry */
N#define LCD_DEVFUNC_FILLPOLY      0x11 /* ...filling a polygon */
N#define LCD_DEVFUNC_FILLPOLYAA    0x12 /* ...filling an antialiased polygon */
N#define LCD_DEVFUNC_ALPHAMODE     0x13 /* ...setting the alpha blending mode */
N#define LCD_DEVFUNC_CHROMAMODE    0x14 /* ...setting the chroma blending mode */
N#define LCD_DEVFUNC_CHROMA        0x15 /* ...setting the chroma values */
N#define LCD_DEVFUNC_SETFUNC       0x16 /* ...setting a function pointer */
N#define LCD_DEVFUNC_REFRESH       0x17 /* ...refreshing the display */
N#define LCD_DEVFUNC_SETRECT       0x18 /* ...setting the drawing rectangle */
N                                       /* Setting a function pointer for... */
N#define LCD_DEVFUNC_FILLRECT      0x19 /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_1BPP  0x20 /* ...drawing a 1bpp bitmap */
N#define LCD_DEVFUNC_COPYBUFFER    0x21 /* ...copying complete frame buffers */
N#define LCD_DEVFUNC_SHOWBUFFER    0x22 /* ...shows the given buffer */
N#define LCD_DEVFUNC_COPYRECT      0x23 /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_16BPP 0x24 /* ...drawing a 16bpp bitmap */
N#define LCD_DEVFUNC_DRAWBMP_8BPP  0x25 /* ...drawing a 8bpp bitmap */
N#define LCD_DEVFUNC_READPIXEL     0x26 /* ...reading a pixel index */
N#define LCD_DEVFUNC_READMPIXELS   0x27 /* ...reading multiple pixel indices */
N#define LCD_DEVFUNC_DRAWBMP_32BPP 0x28 /* ...drawing a 32bpp bitmap */
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (memory devices)
N*/
N                                          /* Request of a function pointer for... */
N#define MEMDEV_DEVFUNC_WRITETOACTIVE 0x16 /* ...writing the memory device */
N
N/*********************************************************************
N*
N*       Values for requesting data
N*/
N                                       /* Request pointer to... */
N#define LCD_DEVDATA_MEMDEV        0x01 /* ...default memory device API */
N#define LCD_DEVDATA_PHYSPAL       0x02 /* ...physical palette */
N
N/*********************************************************************
N*
N*       Structures for passing data to LCD_X_DisplayDriver()
N*/
Ntypedef struct {
N  void * pVRAM;
N} LCD_X_SETVRAMADDR_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETORG_INFO;
N
Ntypedef struct {
N  LCD_COLOR Color;
N  U8 Pos;
X  unsigned char Pos;
N} LCD_X_SETLUTENTRY_INFO;
N
Ntypedef struct {
N  int xSize, ySize;
N} LCD_X_SETSIZE_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N  int xLen, yLen;
N  int BytesPerPixel;
N  U32 Off;
X  unsigned long Off;
N} LCD_X_SETPOS_INFO;
N
Ntypedef struct {
N  int Alpha;
N} LCD_X_SETALPHA_INFO;
N
Ntypedef struct {
N  int OnOff;
N} LCD_X_SETVIS_INFO;
N
Ntypedef struct {
N  int AlphaMode;
N} LCD_X_SETALPHAMODE_INFO;
N
Ntypedef struct {
N  int ChromaMode;
N} LCD_X_SETCHROMAMODE_INFO;
N
Ntypedef struct {
N  LCD_COLOR ChromaMin;
N  LCD_COLOR ChromaMax;
N} LCD_X_SETCHROMA_INFO;
N
Ntypedef struct {
N  int Index;
N} LCD_X_SHOWBUFFER_INFO;
N
N/*********************************************************************
N*
N*       Commands for LCD_X_DisplayDriver()
N*/
N#define LCD_X_INITCONTROLLER 0x01 /* Initializing the display controller */
N#define LCD_X_SETVRAMADDR    0x02 /* Setting the video RAM address */
N#define LCD_X_SETORG         0x03 /* Setting the origin within a layer */
N#define LCD_X_SETLUTENTRY    0x04 /* Setting an entry of the LUT */
N#define LCD_X_ON             0x05 /* Switching the display on */
N#define LCD_X_OFF            0x06 /* Switching the display off */
N#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
N#define LCD_X_SETPOS         0x08 /* Setting the layer position */
N#define LCD_X_SETVIS         0x09 /* Setting the visibility of a layer */
N#define LCD_X_SETALPHA       0x0A /* Setting the alpha value of the layer */
N#define LCD_X_SETALPHAMODE   0x0B /* Setting the alpha blending mode */
N#define LCD_X_SETCHROMAMODE  0x0C /* Setting the chroma blending mode */
N#define LCD_X_SETCHROMA      0x0D /* Setting the chroma values */
N#define LCD_X_SHOWBUFFER     0x0E /* Switching to the given buffer */
N
Nint  LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData);
Nvoid LCD_X_Config(void);
N
N/*********************************************************************
N*
N*       Set layer properties
N*/
Nint LCD_SetAlphaEx     (int LayerIndex, int Alpha);
Nint LCD_SetPosEx       (int LayerIndex, int xPos, int yPos);
Nint LCD_SetSizeEx      (int LayerIndex, int xSize, int ySize);
Nint LCD_SetVisEx       (int LayerIndex, int OnOff);
Nint LCD_SetVRAMAddrEx  (int LayerIndex, void * pVRAM);
Nint LCD_SetVSizeEx     (int LayerIndex, int xSize, int ySize);
Nint LCD_SetAlphaModeEx (int LayerIndex, int AlphaMode);
Nint LCD_SetChromaModeEx(int LayerIndex, int ChromaMode);
Nint LCD_SetChromaEx    (int LayerIndex, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
N
Nint LCD_SetAlpha     (int Alpha);
Nint LCD_SetVRAMAddr  (void * pVRAM);
Nint LCD_SetVSize     (int xSize, int ySize);
Nint LCD_SetSize      (int xSize, int ySize);
Nint LCD_SetVis       (int OnOff);
Nint LCD_SetPos       (int xPos, int yPos);
Nint LCD_SetAlphaMode (int AlphaMode);
Nint LCD_SetChromaMode(int ChromaMode);
Nint LCD_SetChroma    (LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint LCD_SetLUTEntry  (U8 Pos, LCD_COLOR Color);
Xint LCD_SetLUTEntry  (unsigned char Pos, LCD_COLOR Color);
Nint LCD_SetDevFunc   (int LayerIndex, int IdFunc, void (* pDriverFunc)(void));
N
N/*********************************************************************
N*
N*       Get layer properties
N*/
Nint LCD_GetPosEx(int LayerIndex, int * pxPos, int * pyPos);
N
Nint LCD_GetPos  (int * pxPos, int * pyPos);
N
N/*********************************************************************
N*
N*       Display refresh (optional)
N*/
Nint LCD_Refresh  (void);
Nint LCD_RefreshEx(int LayerIndex);
N
N/*********************************************************************
N*
N*       NEXT_PIXEL API support
N*/
Ntypedef struct {
N  int  (* pfStart)   (int x0, int y0, int x1, int y1);
N  void (* pfSetPixel)(int PixelIndex);
N  void (* pfNextLine)(void);
N  void (* pfEnd)     (void);
N} LCD_API_NEXT_PIXEL;
N
NLCD_API_NEXT_PIXEL * LCD_GetNextPixelAPI(void);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*/
Ntypedef void tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine * pfDrawHLine;
N  tLCD_HL_DrawPixel * pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine(int x,  int y0,  int y1);
N
N
N/*********************************************************************
N*
N*       Declarations for LCD_
N*/
Nvoid LCD_SetClipRectEx(const LCD_RECT * pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap  (int Index);
Xsigned long  LCD_GetDevCap  (int Index);
NI32  LCD_GetDevCapEx(int LayerIndex, int Index);
Xsigned long  LCD_GetDevCapEx(int LayerIndex, int Index);
N
N/* Initialize LCD using config-parameters */
Nint emWin_LCD_Init(void);
Nint LCD_InitColors(void);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
Nint  LCD_SetLUTEntryEx(int LayerIndex, U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntryEx(int LayerIndex, unsigned char Pos, LCD_COLOR Color);
Nvoid LCD_SetLUTEx(int LayerIndex, const LCD_PHYSPALETTE * pPalette);
Nvoid LCD_SetLUT  (const LCD_PHYSPALETTE * pPalette);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(unsigned PixelIndex);
Nvoid LCD_SetBkColorIndex(unsigned PixelIndex);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA4_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA4_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA8_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA8_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_NoTrans(int x, int y, unsigned char Intens);
N
NLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256   (LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N#if (GUI_USE_ARGB)
SU32          LCD_AA_SetOrMask(U32 OrMask);
N#else
NU32          LCD_AA_SetAndMask(U32 AndMask);
Xunsigned long          LCD_AA_SetAndMask(unsigned long AndMask);
N#endif
N
N/* Configuration */
Nint LCD_SetMaxNumColors(unsigned MaxNumColors);
N
N/*********************************************************************
N*
N*       Optional support for rotation
N*/
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 * pPixel, const void * pTrans);
X                             const unsigned char * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N  tRect2TextRect    * pfTransformRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N
NtLCD_SetPixelAA * LCD__GetPfSetPixel(int BitsPerPixel);
N
N#endif
N
N/*********************************************************************
N*
N*       Physical color access, internally used only
N*/
Nvoid LCD__SetPhysColor(U8 Pos, LCD_COLOR Color);
Xvoid LCD__SetPhysColor(unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Cache control
N*/
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
N
Nint LCD_ControlCache  (int Cmd);
Nint LCD_ControlCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       Color conversion
N*/
Nunsigned         LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*/
Nunsigned char LCD_X_Read00(void);
Nunsigned char LCD_X_Read01(void);
Nvoid LCD_X_Write00 (unsigned char c);
Nvoid LCD_X_Write01 (unsigned char c);
Nvoid LCD_X_WriteM01(unsigned char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
L 62 "..\STemWin\inc\GUI_Type.h" 2
N#include "GUIConf.h"
N
N/*********************************************************************
N*
N*       Common types
N*/
Ntypedef const char *  GUI_ConstString;
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)  (int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  GUI_COLOR (* pfIndex2Color)(unsigned Index);
N  void      (* pfDrawHW)(int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 * pData;
X  const unsigned char * pData;
N  const GUI_LOGPALETTE * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;
X  unsigned short ID;
N  U16 Format;
X  unsigned short Format;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int    Cmd;
N  U32    v;
X  unsigned long    v;
N  void * p;
N} GUI_BITMAPSTREAM_PARAM;
N
Ntypedef struct {
N  int XSize;
N  int YSize;
N  int BitsPerPixel;
N  int NumColors;
N  int HasTrans;
N} GUI_BITMAPSTREAM_INFO;
N
Ntypedef void * (* GUI_BITMAPSTREAM_CALLBACK)(GUI_BITMAPSTREAM_PARAM * pParam);
N
Ntypedef struct {
N  int x,y;
N  U8  Pressed;
X  unsigned char  Pressed;
N  U8  Layer;
X  unsigned char  Layer;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int Key;
N  int Pressed;
N} GUI_KEY_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
Ntypedef struct GUI_REGISTER_EXIT GUI_REGISTER_EXIT;
N
Nstruct GUI_REGISTER_EXIT {
N  void (* pfVoid)(void);
N  GUI_REGISTER_EXIT * pNext;
N};
N
Ntypedef struct {
N  void (* cbBegin)(void);
N  void (* cbEnd)  (void);
N} GUI_MULTIBUF_API;
N
Ntypedef struct {
N  void (* cbBeginEx)(int LayerIndex);
N  void (* cbEndEx)  (int LayerIndex);
N} GUI_MULTIBUF_API_EX;
N
N/*********************************************************************
N*
N*       FONT structures
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   '' -> index('a'), index('') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char * pData;
N} GUI_CHARINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 YSize;
X  unsigned char YSize;
N  I8 XPos;
X  signed char XPos;
N  I8 YPos;
X  signed char YPos;
N  U8 XDist;
X  unsigned char XDist;
N  const unsigned char * pData;
N} GUI_CHARINFO_EXT;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO         * paCharInfo;     /* Address of first character    */
N  const struct GUI_FONT_PROP * pNext;          /* Pointer to next               */
N} GUI_FONT_PROP;
N
Ntypedef struct GUI_FONT_PROP_EXT {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO_EXT         * paCharInfo; /* Address of first character    */
N  const struct GUI_FONT_PROP_EXT * pNext;      /* Pointer to next               */
N} GUI_FONT_PROP_EXT;
N
Ntypedef struct {
N  const unsigned char      * pData;
N  const U8                 * pTransData;
X  const unsigned char                 * pTransData;
N  const GUI_FONT_TRANSINFO * pTrans;
N  U16P                       FirstChar;
X  unsigned short                       FirstChar;
N  U16P                       LastChar;
X  unsigned short                       LastChar;
N  U8                         XSize;
X  unsigned char                         XSize;
N  U8                         XDist;
X  unsigned char                         XDist;
N  U8                         BytesPerLine;
X  unsigned char                         BytesPerLine;
N} GUI_FONT_MONO;
N
N/*********************************************************************
N*
N*       FONT structures
N*
N* This structure is used when retrieving information about a font.
N* It is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP    (1 << 0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO    (1 << 1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA      (1 << 2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2     (1 << 3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4     (1 << 4)    /* Is an antialiased font, 4bpp */
N#define GUI_FONTINFO_FLAG_PROPFRM (1 << 5)    /* Is proportional, framed */
N
N/*********************************************************************
N*
N*       UNICODE Encoding
N*/
Ntypedef U16  tGUI_GetCharCode   (const char * s);
Xtypedef unsigned short  tGUI_GetCharCode   (const char * s);
Ntypedef int  tGUI_GetCharSize   (const char * s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode        (char * s, U16 Char);
Xtypedef int  tGUI_Encode        (char * s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode    * pfGetCharCode;
N  tGUI_GetCharSize    * pfGetCharSize;
N  tGUI_CalcSizeOfChar * pfCalcSizeOfChar;
N  tGUI_Encode         * pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/*********************************************************************
N*
N*       FONT Encoding
N*/
Ntypedef int  tGUI_GetLineDistX(const char * s, int Len);
Ntypedef int  tGUI_GetLineLen  (const char * s, int MaxLen);
Ntypedef void tGL_DispLine     (const char * s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX * pfGetLineDistX;
N  tGUI_GetLineLen   * pfGetLineLen;
N  tGL_DispLine      * pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_EXT;
N
N/*********************************************************************
N*
N*       FONT methods
N*/
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR    (U16 c);
Xtypedef void GUI_DISPCHAR    (unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c, int * pSizeX);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c, int * pSizeX);
Ntypedef void GUI_GETFONTINFO (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT    (const GUI_FONT * pFont, U16 c);
Xtypedef char GUI_ISINFONT    (const GUI_FONT * pFont, unsigned short c);
Ntypedef int  GUI_GETCHARINFO (U16P c, GUI_CHARINFO_EXT * pInfo);
Xtypedef int  GUI_GETCHARINFO (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); \
Nint  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         void GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); int  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c, int * pSizeX); void GUIMONO_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIMONO_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_EXT);
Xvoid GUIPROP_EXT_DispChar (unsigned short c); int GUIPROP_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_FRM);
Xvoid GUIPROP_FRM_DispChar (unsigned short c); int GUIPROP_FRM_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_FRM_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_FRM_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_FRM_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROPAA_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROPAA_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2_EXT);
Xvoid GUIPROP_AA2_EXT_DispChar (unsigned short c); int GUIPROP_AA2_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4_EXT);
Xvoid GUIPROP_AA4_EXT_DispChar (unsigned short c); int GUIPROP_AA4_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N/* MONO: Monospaced fonts */
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N  GUIMONO_GetCharDistX,         \
N  GUIMONO_GetFontInfo,          \
N  GUIMONO_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,               GUIMONO_GetCharDistX,           GUIMONO_GetFontInfo,            GUIMONO_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP_EXT: Extended proportional fonts */
N#define GUI_FONTTYPE_PROP_EXT       \
N  GUIPROP_EXT_DispChar,             \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_EXT         GUIPROP_EXT_DispChar,               GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_FRM: Extended proportional fonts, framed */
N#define GUI_FONTTYPE_PROP_FRM       \
N  GUIPROP_FRM_DispChar,             \
N  GUIPROP_FRM_GetCharDistX,         \
N  GUIPROP_FRM_GetFontInfo,          \
N  GUIPROP_FRM_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_FRM         GUIPROP_FRM_DispChar,               GUIPROP_FRM_GetCharDistX,           GUIPROP_FRM_GetFontInfo,            GUIPROP_FRM_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N  GUIPROPAA_GetCharDistX,         \
N  GUIPROPAA_GetFontInfo,          \
N  GUIPROPAA_IsInFont,             \
N  (GUI_GETCHARINFO *)0,           \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,               GUIPROPAA_GetCharDistX,           GUIPROPAA_GetFontInfo,            GUIPROPAA_IsInFont,               (GUI_GETCHARINFO *)0,             (tGUI_ENC_APIList*)0
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp */
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2_EXT: Proportional, antialiased fonts, 2bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA2_EXT   \
N  GUIPROP_AA2_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA2_EXT     GUIPROP_AA2_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp */
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA4_EXT: Proportional, antialiased fonts, 4bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA4_EXT   \
N  GUIPROP_AA4_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA4_EXT     GUIPROP_AA4_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR     * pfDispChar; 
N  GUI_GETCHARDISTX * pfGetCharDistX; 
N  GUI_GETFONTINFO  * pfGetFontInfo; 
N  GUI_ISINFONT     * pfIsInFont;
N  GUI_GETCHARINFO  * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void              * pFontData;
N    const GUI_FONT_MONO     * pMono;
N    const GUI_FONT_PROP     * pProp;
N    const GUI_FONT_PROP_EXT * pPropExt;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* Height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* Height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       Bitmap serialization (BMP)
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
N/*********************************************************************
N*
N*       System independent font structures (SIF)
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 YSize;        /* Size of bitmap data in X */
X  unsigned short YSize;         
N  I16 XOff;         /* Display offset of bitmap data in X */
X  signed short XOff;          
N  I16 YOff;         /* Display offset of bitmap data in Y */
X  signed short YOff;          
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO_EXT;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE              tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP         &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_EXT     &GUI_SIF_APIList_Prop_Ext
N#define GUI_SIF_TYPE_PROP_FRM     &GUI_SIF_APIList_Prop_Frm
N#define GUI_SIF_TYPE_PROP_AA2     &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4     &GUI_SIF_APIList_Prop_AA4
N#define GUI_SIF_TYPE_PROP_AA2_EXT &GUI_SIF_APIList_Prop_AA2_EXT
N#define GUI_SIF_TYPE_PROP_AA4_EXT &GUI_SIF_APIList_Prop_AA4_EXT
N
N/*********************************************************************
N*
N*       External binary font structures (XBF)
N*/
Ntypedef int GUI_XBF_GET_DATA_FUNC(U32 Off, U16 NumBytes, void * pVoid, void * pBuffer);
Xtypedef int GUI_XBF_GET_DATA_FUNC(unsigned long Off, unsigned short NumBytes, void * pVoid, void * pBuffer);
N
Ntypedef struct {
N  U16 First;                         /* First character of font */
X  unsigned short First;                          
N  U16 Last;                          /* Last character of font */
X  unsigned short Last;                           
N  void * pVoid;                      /* Void pointer passed to GetData-function */
N  GUI_XBF_GET_DATA_FUNC * pfGetData; /* Pointer to callback function */
N} GUI_XBF_DATA;
N
Ntypedef struct tGUI_XBF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_XBF_APIList;
N
N#define GUI_XBF_TYPE              tGUI_XBF_APIList
N#define GUI_XBF_TYPE_PROP         &GUI_XBF_APIList_Prop
N#define GUI_XBF_TYPE_PROP_EXT     &GUI_XBF_APIList_Prop_Ext
N#define GUI_XBF_TYPE_PROP_FRM     &GUI_XBF_APIList_Prop_Frm
N#define GUI_XBF_TYPE_PROP_AA2_EXT &GUI_XBF_APIList_Prop_AA2_Ext
N#define GUI_XBF_TYPE_PROP_AA4_EXT &GUI_XBF_APIList_Prop_AA4_Ext
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Ntypedef struct {
N  const void * pData;      /* Pointer to TTF font file in addressable memory area */
N  U32 NumBytes;            /* Size of file in bytes */
X  unsigned long NumBytes;             
N} GUI_TTF_DATA;
N
Ntypedef struct {
N  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
N  U32 aImageTypeBuffer[4]; /* Buffer for image type structure */
X  unsigned long aImageTypeBuffer[4];  
N  int PixelHeight;         /* Pixel height of new font. It means the height of the surrounding rectangle
N                            * between the glyphs 'g' anf 'f'. Please notice that it is not the distance
N                            * between two lines of text. With other words the value returned byGUI_GetFontSizeY()
N                            * is not identically with this value. */
N  int FaceIndex;           /* Some font files can contain more than one font face. In case of more than one face
N                            * this index specifies the zero based face index to be used to create the font. 
N                            * Usually 0. */
N} GUI_TTF_CS;
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Ntypedef void (* GUI_SIGNAL_EVENT_FUNC)    (void);
Ntypedef void (* GUI_WAIT_EVENT_FUNC)      (void);
Ntypedef void (* GUI_WAIT_EVENT_TIMED_FUNC)(int Period);
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#ifndef     GUI_HMEM
N  #define     GUI_HMEM        I32
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed long      GUI_HWIN;
Ntypedef     GUI_HMEM      GUI_HSPRITE;
Xtypedef     signed long      GUI_HSPRITE;
N
N/*********************************************************************
N*
N*       Multi touch input
N*/
N#ifndef   GUI_MTOUCH_MAX_NUM_POINTS
N  #define GUI_MTOUCH_MAX_NUM_POINTS 10
N#endif
N
Ntypedef struct {
N  I32 x;
X  signed long x;
N  I32 y;
X  signed long y;
N  U32 Id;
X  unsigned long Id;
N  U16 Flags;
X  unsigned short Flags;
N} GUI_MTOUCH_INPUT;
N
Ntypedef struct {
N  int            LayerIndex;
N  unsigned       NumPoints;
N  GUI_TIMER_TIME TimeStamp;
X  int TimeStamp;
N  GUI_HMEM       hInput;
X  signed long       hInput;
N} GUI_MTOUCH_EVENT;
N
N//
N// Used for emWinSPY with reduced data types and array sizes
N//
Ntypedef struct {
N  U8  Layer;
X  unsigned char  Layer;
N  U8  NumPoints;
X  unsigned char  NumPoints;
N  I16 ax[5];
X  signed short ax[5];
N  I16 ay[5];
X  signed short ay[5];
N  U16 aId[5];
X  unsigned short aId[5];
N  U8  aFlags[5];
X  unsigned char  aFlags[5];
N} GUI_MTOUCH_STATE;
N
Ntypedef void (* T_GUI_MTOUCH_STOREEVENT)(GUI_MTOUCH_EVENT *, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Hardware routines
N*/
Ntypedef struct {
N  //
N  // 8 Bit access
N  //
N  void (* pfWrite8_A0)  (U8 Data);
X  void (* pfWrite8_A0)  (unsigned char Data);
N  void (* pfWrite8_A1)  (U8 Data);
X  void (* pfWrite8_A1)  (unsigned char Data);
N  void (* pfWriteM8_A0) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A0) (unsigned char * pData, int NumItems);
N  void (* pfWriteM8_A1) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A1) (unsigned char * pData, int NumItems);
N  U8   (* pfRead8_A0)   (void);
X  unsigned char   (* pfRead8_A0)   (void);
N  U8   (* pfRead8_A1)   (void);
X  unsigned char   (* pfRead8_A1)   (void);
N  void (* pfReadM8_A0)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A0)  (unsigned char * pData, int NumItems);
N  void (* pfReadM8_A1)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A1)  (unsigned char * pData, int NumItems);
N  //
N  // 16 Bit access
N  //
N  void (* pfWrite16_A0) (U16 Data);
X  void (* pfWrite16_A0) (unsigned short Data);
N  void (* pfWrite16_A1) (U16 Data);
X  void (* pfWrite16_A1) (unsigned short Data);
N  void (* pfWriteM16_A0)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A0)(unsigned short * pData, int NumItems);
N  void (* pfWriteM16_A1)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A1)(unsigned short * pData, int NumItems);
N  U16  (* pfRead16_A0)  (void);
X  unsigned short  (* pfRead16_A0)  (void);
N  U16  (* pfRead16_A1)  (void);
X  unsigned short  (* pfRead16_A1)  (void);
N  void (* pfReadM16_A0) (U16 * pData, int NumItems);
X  void (* pfReadM16_A0) (unsigned short * pData, int NumItems);
N  void (* pfReadM16_A1) (U16 * pData, int NumItems);
X  void (* pfReadM16_A1) (unsigned short * pData, int NumItems);
N  //
N  // 32 Bit access
N  //
N  void (* pfWrite32_A0) (U32 Data);
X  void (* pfWrite32_A0) (unsigned long Data);
N  void (* pfWrite32_A1) (U32 Data);
X  void (* pfWrite32_A1) (unsigned long Data);
N  void (* pfWriteM32_A0)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A0)(unsigned long * pData, int NumItems);
N  void (* pfWriteM32_A1)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A1)(unsigned long * pData, int NumItems);
N  U32  (* pfRead32_A0)  (void);
X  unsigned long  (* pfRead32_A0)  (void);
N  U32  (* pfRead32_A1)  (void);
X  unsigned long  (* pfRead32_A1)  (void);
N  void (* pfReadM32_A0) (U32 * pData, int NumItems);
X  void (* pfReadM32_A0) (unsigned long * pData, int NumItems);
N  void (* pfReadM32_A1) (U32 * pData, int NumItems);
X  void (* pfReadM32_A1) (unsigned long * pData, int NumItems);
N  //
N  // SPI access
N  //
N  void (* pfSetCS)      (U8 NotActive);
X  void (* pfSetCS)      (unsigned char NotActive);
N  //
N  // Common routines
N  //
N  void (* pfFlushBuffer)(void);
N} GUI_PORT_API;
N
N/*********************************************************************
N*
N*       Send/Receive function for VNC and/or emWinSPY
N*/
Ntypedef int    (* GUI_tSend)  (const U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tSend)  (const unsigned char * pData, int len, void * p);
Ntypedef int    (* GUI_tRecv)  (      U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tRecv)  (      unsigned char * pData, int len, void * p);
N
N/*********************************************************************
N*
N*       Memory allocation replacement for emWinSPY
N*/
Ntypedef void * (* GUI_tMalloc)(unsigned int);
Ntypedef void   (* GUI_tFree)  (void *);
N
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
L 59 "..\STemWin\inc\GUI.h" 2
N#include "GUI_Version.h"
L 1 "..\STemWin\inc\GUI_Version.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUI_Version.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 53202
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 60 "..\STemWin\inc\GUI.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Disable string function warning with newer MSVC versions
N*/
N#if defined (_MSC_VER)
X#if 0L
S  #if (_MSC_VER > 1200)
S    #pragma warning( disable : 4996)
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       Macros, function replacement
N*/
N#define GUI_COUNTOF(a)          (sizeof(a) / sizeof(a[0]))
N#define GUI_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define GUI_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define GUI_ZEROFILL(p, Size)   (memset(p, 0, Size))
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*/
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(0)
N  #define GUI_LOCK()
N  #define GUI_UNLOCK()
N  #define GUITASK_INIT()
N  #define GUITASK_COPY_CONTEXT()
N#else
S  void GUI_Lock(void);
S  void GUI_Unlock(void);
S  void GUITASK_Init(void);
S  void GUITASK_CopyContext(void);
S  void GUITASK_SetMaxTask(int MaxTask);
S  int  GUITASK_GetMaxTask(void);
S  GUI_CONTEXT * GUITASK_GetpContext(int Index);
S  #define GUI_LOCK()             GUI_Lock()
S  #define GUI_UNLOCK()           GUI_Unlock()
S  #define GUITASK_INIT()         GUITASK_Init()
S  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*       API table of a display driver
N*/
Nstruct GUI_DEVICE_API {
N  //
N  // Data
N  //
N  int DeviceClassIndex;
N  //
N  // Drawing functions
N  //
N  void     (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void     (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void     (* pfDrawHLine    )(GUI_DEVICE *  pDevice,  int x0, int y0,  int x1);
N  void     (* pfDrawVLine    )(GUI_DEVICE *  pDevice,  int x , int y0,  int y1);
N  void     (* pfFillRect     )(GUI_DEVICE *  pDevice,  int x0, int y0, int x1, int y1);
N  unsigned (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
N  void     (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, int ColorIndex);
N  void     (* pfXorPixel     )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Set origin
N  //
N  void     (* pfSetOrg       )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Request information
N  //
N  void   (*(* pfGetDevFunc)   (GUI_DEVICE ** ppDevice, int Index))(void);
N  I32      (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
X  signed long      (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
N  void    *(* pfGetDevData   )(GUI_DEVICE *  pDevice,  int Index);
N  void     (* pfGetRect      )(GUI_DEVICE *  pDevice,  LCD_RECT * pRect);
N};
N
N/*********************************************************************
N*
N*       Device classes
N*/
Ntypedef enum {
N  DEVICE_CLASS_DRIVER = 0,
N  DEVICE_CLASS_DRIVER_MODIFIER,   // Zoom or delta-pixel modifier
N  DEVICE_CLASS_VNC,
N  DEVICE_CLASS_SPRITE,
N  DEVICE_CLASS_MEMDEV,
N  DEVICE_CLASS_ALPHA,
N  DEVICE_CLASS_AUTOALPHA,
N  DEVICE_CLASS_MEASDEV
N} DEVICE_CLASS;
N
N#define GUI_DEVICE_STAYONTOP 1
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
N
Nextern const GUI_DEVICE_API GUIDRV_Template_API;
N
N//
N// Macros to be used in configuration files
N//
N#define GUIDRV_WIN32       &GUIDRV_Win_API
N
N#if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
X#if 0L && !0L
S
S  #define GUIDRV_TEMPLATE         &GUIDRV_Win_API
S
N#else
N
N  #define GUIDRV_TEMPLATE         &GUIDRV_Template_API
N
N#endif
N
N/*********************************************************************
N*
N*       Definition of GUI_DEVICE structure
N*/
Nstruct GUI_DEVICE {
N  //
N  // Linking
N  //
N  GUI_DEVICE * pNext;
N  GUI_DEVICE * pPrev;
N  //
N  // Data
N  //
N  union {
N    GUI_HMEM hContext; // Handle of payload data like sprite- or memory device context
X    signed long hContext; 
N    void   * pContext; // Pointer for context data in a fixed block
N  } u;
N  //
N  // API pointers
N  //
N  const GUI_DEVICE_API     * pDeviceAPI;
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N  U16 Flags;
X  unsigned short Flags;
N  int LayerIndex;
N};
N
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_1;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_8;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_16;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_32;
N
N/*********************************************************************
N*
N*       GUI_CONTEXT
N*
N*  This structure is public for one reason only:
N*  To allow the application to save and restore the context.
N*/
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N  //
N  // Variables in LCD module
N  //
N  LCD_COLORINDEX_UNION uLCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N  //
N  // Variables in GL module
N  //
N  GUI_RECT * pClipRect_HL;                 // High level clip rectangle ... Speed optimization so drawing routines can optimize
N  U8         PenSize;
X  unsigned char         PenSize;
N  U8         PenShape;
X  unsigned char         PenShape;
N  U8         LineStyle;
X  unsigned char         LineStyle;
N  //
N  // Variables in GUICHAR module
N  //
N  const GUI_FONT * pAFont;
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;                // Required only when changing devices and for speed opt (caching)
N  //
N  // Pointer to  color indices
N  //
N  LCD_PIXELINDEX * LCD_pBkColorIndex;
X  unsigned long * LCD_pBkColorIndex;
N  LCD_PIXELINDEX * LCD_pColorIndex;
X  unsigned long * LCD_pColorIndex;
N  LCD_PIXELINDEX * LCD_pAColorIndex;
X  unsigned long * LCD_pAColorIndex;
N  //
N  // Variables in WM module
N  //
N  #if GUI_WINSUPPORT
X  #if (1)
N    const GUI_RECT * WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N    U8 WM_IsActive;
X    unsigned char WM_IsActive;
N  #endif
N  //
N  // Array of pointers to device chains
N  //
N  //GUI_DEVICE * apDevice[GUI_NUM_LAYERS];
N  GUI_DEVICE * apDriver[GUI_NUM_LAYERS];
X  GUI_DEVICE * apDriver[2];
N  //
N  // Variables in MEMDEV module (with memory devices only)
N  //
N  GUI_HMEM    hDevData;
X  signed long    hDevData;
N  //
N  // Variables in Anitaliasing module
N  //
N  const tLCD_HL_APIList * pLCD_HL;       // Required to reroute drawing (HLine & Pixel) to the AA module
N  U8 AA_Factor;
X  unsigned char AA_Factor;
N  U8 AA_HiResEnable;
X  unsigned char AA_HiResEnable;
N  void (* AA_pfSetPixelAA)(int x, int y, U8 Intens); // Function to be used for drawing a single pixel
X  void (* AA_pfSetPixelAA)(int x, int y, unsigned char Intens); 
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if (GUI_WINSUPPORT == 1)
X#if ((1) == 1)
N  #define GUI_SaveContext GUI_SaveContext_W
N#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*       Device management
N*/
NGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
NGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
Nvoid         GUI_DEVICE_Delete       (GUI_DEVICE * pDevice);
Nint          GUI_DEVICE_Link         (GUI_DEVICE * pDevice);
Nvoid         GUI_DEVICE_Unlink       (GUI_DEVICE * pDevice);
NGUI_DEVICE * GUI_DEVICE__GetpDriver  (int LayerIndex);
NGUI_DEVICE * GUI_DEVICE__GetpDevice  (int LayerIndex, int DeviceClass);
N
NGUI_DEVICE * GUI_DEVICE_UnlinkTaskDevices(void);
Nvoid         GUI_DEVICE_LinkDevices      (GUI_DEVICE * pDevice);
N
Nvoid _RegisterExit(void);
N/*********************************************************************
N*
N*       GUI_DIRTYDEVICE
N*/
Ntypedef struct {
N  void * pData;         // Pointer to first pixel
N  int    x0, y0;        // Coordinates of the upper left pixel
N  int    xSize, ySize;  // Size of dirty rectangle
N  int    LineOff;       // Virtual xSize in pixels
N  int    BytesPerPixel; // Number of bytes required per pixel
N  int    IsDirty;       // Indicates if dirty pixels exist
N} GUI_DIRTYDEVICE_INFO;
N
Nint GUI_DIRTYDEVICE_Create      (void);
Nint GUI_DIRTYDEVICE_CreateEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_CreateExInfo(GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
Nint GUI_DIRTYDEVICE_Delete      (void);
Nint GUI_DIRTYDEVICE_DeleteEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_Fetch       (GUI_DIRTYDEVICE_INFO * pInfo);
Nint GUI_DIRTYDEVICE_FetchEx     (GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
N
N/*********************************************************************
N*
N*       GUI_SOFTLAYER
N*/
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Visible;
N} GUI_SOFTLAYER_CONFIG;
N
Nint  GUI_SOFTLAYER_Enable           (GUI_SOFTLAYER_CONFIG * pConfig, int NumLayers, GUI_COLOR CompositeColor);
Nint  GUI_SOFTLAYER_Refresh          (void);
Nvoid GUI_SOFTLAYER_SetCompositeColor(U32 Color);
Xvoid GUI_SOFTLAYER_SetCompositeColor(unsigned long Color);
Nint  GUI_SOFTLAYER_MULTIBUF_Enable  (int OnOff);
N
N/*********************************************************************
N*
N*       General routines
N*/
Nint          GUI_Init             (void);
Nint          GUI_IsInitialized    (void);
Nvoid         GUI_Exit             (void);
Nvoid         GUI_SetDefaultFont   (const GUI_FONT * pFont);
Nvoid         GUI_SetDefault       (void);
NGUI_DRAWMODE GUI_SetDrawMode      (GUI_DRAWMODE dm);
Nconst char * GUI_GetVersionString (void);
Nvoid         GUI_SaveContext      (      GUI_CONTEXT * pContext);
Xvoid         GUI_SaveContext_W      (      GUI_CONTEXT * pContext);
Nvoid         GUI_RestoreContext   (const GUI_CONTEXT * pContext);
Nvoid         GUI_SetScreenSizeX   (int xSize);
Nvoid         GUI_SetScreenSizeY   (int ySize);
Nint          GUI_GetScreenSizeX   (void);
Nint          GUI_GetScreenSizeY   (void);
Nconst GUI_RECT * GUI_SetClipRect  (const GUI_RECT * pRect);
Nvoid         GUI_SetRefreshHook   (void (* pFunc)(void));
Nvoid         GUI_SetControlHook   (void (* pFunc)(int LayerIndex, int Cmd));
Nvoid         MainTask             (void);
N
N/*********************************************************************
N*
N*       Rectangle helper functions
N*/
Nint  GUI_RectsIntersect(const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI_MoveRect       (GUI_RECT * pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint  GUI__IntersectRects(GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI__IntersectRect (GUI_RECT * pDest, const GUI_RECT * pr0);
Nvoid GUI__ReduceRect    (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*/
NI32  GUI__ATan2(I32 x, I32 y, I32 * ph);
Xsigned long  GUI__ATan2(signed long x, signed long y, signed long * ph);
NI32  GUI__ASinHQ(I32 SinHQ);
Xsigned long  GUI__ASinHQ(signed long SinHQ);
Nint  GUI__CompactPixelIndices  (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel);
Xint  GUI__CompactPixelIndices  (unsigned long * pBuffer, int NumPixels, int BitsPerPixel);
Nint  GUI__CompactPixelIndicesEx(LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Xint  GUI__CompactPixelIndicesEx(unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint  GUI__ConvertColor2Index   (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Xint  GUI__ConvertColor2Index   (unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Nvoid GUI__Config(void);
NI32  GUI__CosHQ(I32 Ang1000);
Xsigned long  GUI__CosHQ(signed long Ang1000);
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nvoid GUI__ExpandPixelIndices   (void * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__ExpandPixelIndicesEx (void * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid GUI__memcpy(void * pDest, const void * pSrc, int NumBytes);
Nint  GUI__SetText(GUI_HMEM * phText, const char * s);
Xint  GUI__SetText(signed long * phText, const char * s);
NI32  GUI__SinHQ(I32 Ang1000);
Xsigned long  GUI__SinHQ(signed long Ang1000);
NI32  GUI__sqrt32(I32 Square);
Xsigned long  GUI__sqrt32(signed long Square);
Nvoid GUI__DrawTwinArc2(int xl, int xr, int y0,         int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid GUI__DrawTwinArc4(int x0, int y0, int x1, int y1, int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid GUI__FillTrippleArc(int x0, int y0, int Size, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorR2, GUI_COLOR ColorFill);
Nvoid GUI__RegisterExit(GUI_REGISTER_EXIT * pRegisterExit);
N
N/*********************************************************************
N*
N*       Get / Set Attributes
N*/
NGUI_COLOR GUI_GetBkColor     (void);
Nint       GUI_GetBkColorIndex(void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
Nunsigned  GUI_GetPixelIndex  (int x, int y);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*/
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Error handler
N*/
Nvoid GUI_SetOnErrorFunc(void (* pFunc)(const char * s));
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*/
Nvoid GUI_Log      (const char * s);
Nvoid GUI_Log1     (const char * s, I32 p0);
Xvoid GUI_Log1     (const char * s, signed long p0);
Nvoid GUI_Log2     (const char * s, I32 p0, I32 p1);
Xvoid GUI_Log2     (const char * s, signed long p0, signed long p1);
Nvoid GUI_Log3     (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Log3     (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Log4     (const char * s, I32 p0, I32 p1, I32 p2,I32 p3);
Xvoid GUI_Log4     (const char * s, signed long p0, signed long p1, signed long p2,signed long p3);
Nvoid GUI_Warn     (const char * s);
Nvoid GUI_Warn1    (const char * s, I32 p0);
Xvoid GUI_Warn1    (const char * s, signed long p0);
Nvoid GUI_Warn2    (const char * s, I32 p0, I32 p1);
Xvoid GUI_Warn2    (const char * s, signed long p0, signed long p1);
Nvoid GUI_Warn3    (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Warn3    (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Warn4    (const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_Warn4    (const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
Nvoid GUI_ErrorOut (const char * s);
Nvoid GUI_ErrorOut1(const char * s, I32 p0);
Xvoid GUI_ErrorOut1(const char * s, signed long p0);
Nvoid GUI_ErrorOut2(const char * s, I32 p0, I32 p1);
Xvoid GUI_ErrorOut2(const char * s, signed long p0, signed long p1);
Nvoid GUI_ErrorOut3(const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_ErrorOut3(const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_ErrorOut4(const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_ErrorOut4(const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
N
N/*********************************************************************
N*
N*       2d - GL
N*/
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT * pRect);
Nvoid GUI_CopyRect         (int x0, int y0, int x1, int y1, int dx, int dy);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 * pData, const GUI_LOGPALETTE * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, const GUI_LOGPALETTE * pPal);
Nvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGradientH    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientV    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedH(int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedV(int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGraph        (I16 * pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short * pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Xvoid GUI_DrawGraphEx      (signed short * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT  * pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT * pRect);
Nvoid GUI_DrawRoundedFrame (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT * pRect);
Nvoid GUI_FillRoundedFrame (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectB (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectT (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_GetClientRect    (GUI_RECT * pRect);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
Nvoid GUI_SetAlphaMask8888 (U32 OrMask, U32 AndMask);
Xvoid GUI_SetAlphaMask8888 (unsigned long OrMask, unsigned long AndMask);
N
N/*********************************************************************
N*
N*       Graphic file support
N*/
Ntypedef int GUI_GET_DATA_FUNC(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GIF file support
N*/
Nint GUI_GIF_Draw           (const void * pGIF, U32 NumBytes,         int x0, int y0);
Xint GUI_GIF_Draw           (const void * pGIF, unsigned long NumBytes,         int x0, int y0);
Nint GUI_GIF_DrawEx         (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_GIF_DrawSub        (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index);
Xint GUI_GIF_DrawSub        (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index);
Nint GUI_GIF_DrawSubEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index);
Nint GUI_GIF_DrawSubScaled  (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Xint GUI_GIF_DrawSubScaled  (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_DrawSubScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_GetComment     (const void * pGIF, U32 NumBytes,         U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetComment     (const void * pGIF, unsigned long NumBytes,         unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetImageInfo   (const void * pGIF, U32 NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint GUI_GIF_GetImageInfo   (const void * pGIF, unsigned long NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetImageInfoEx (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetInfo        (const void * pGIF, U32 NumBytes,         GUI_GIF_INFO * pInfo);
Xint GUI_GIF_GetInfo        (const void * pGIF, unsigned long NumBytes,         GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetInfoEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetXSize       (const void * pGIF);
Nint GUI_GIF_GetXSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_GetYSize       (const void * pGIF);
Nint GUI_GIF_GetYSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_SetFillTrans   (int OnOff);
N
N/*********************************************************************
N*
N*       BMP file support
N*/
Nint  GUI_BMP_Draw        (const void * pFileData,                  int x0, int y0);
Nint  GUI_BMP_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint  GUI_BMP_DrawScaled  (const void * pFileData,                  int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_GetXSize    (const void * pFileData);
Nint  GUI_BMP_GetXSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint  GUI_BMP_GetYSize    (const void * pFileData);
Nint  GUI_BMP_GetYSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nvoid GUI_BMP_EnableAlpha (void);
Nvoid GUI_BMP_DisableAlpha(void);
N
N/*********************************************************************
N*
N*       PNG file support
N*/
Nint GUI_PNG_Draw      (const void * pFileData, int DataSize, int x0, int y0);
Nint GUI_PNG_DrawEx    (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_PNG_GetXSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetXSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_PNG_GetYSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetYSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       JPEG file support
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
Nint GUI_JPEG_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO * pInfo);
Nint GUI_JPEG_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pInfo);
N
N/*********************************************************************
N*
N*       MOVIE file support
N*/
N#define GUI_MOVIE_NOTIFICATION_PREDRAW  0 // Immediately before frame is drawn
N#define GUI_MOVIE_NOTIFICATION_POSTDRAW 1 // Immediately after a frame is drawn
N#define GUI_MOVIE_NOTIFICATION_START    2 // Send when start playing a movie
N#define GUI_MOVIE_NOTIFICATION_STOP     3 // Movie has stopped
N#define GUI_MOVIE_NOTIFICATION_DELETE   4 // Movie has been deleted
N
Ntypedef GUI_HMEM GUI_MOVIE_HANDLE;
Xtypedef signed long GUI_MOVIE_HANDLE;
N
Ntypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, U32 CurrentFrame);
Xtypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, unsigned long CurrentFrame);
N
Ntypedef struct {
N  int xSize;         // X-size of images
N  int ySize;         // Y-size of images
N  int msPerFrame;    // Default duration of 1 frame
N  U32 NumFrames;     // Number of frames
X  unsigned long NumFrames;     
N} GUI_MOVIE_INFO;
N
NGUI_MOVIE_HANDLE GUI_MOVIE_Create       (const void * pFileData, U32 FileSize, GUI_MOVIE_FUNC * pfNotify);
XGUI_MOVIE_HANDLE GUI_MOVIE_Create       (const void * pFileData, unsigned long FileSize, GUI_MOVIE_FUNC * pfNotify);
NGUI_MOVIE_HANDLE GUI_MOVIE_CreateEx     (GUI_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_Delete       (GUI_MOVIE_HANDLE hMovie);
NU32              GUI_MOVIE_GetFrameIndex(GUI_MOVIE_HANDLE hMovie);
Xunsigned long              GUI_MOVIE_GetFrameIndex(GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetInfo      (const void * pFileData, U32 FileSize, GUI_MOVIE_INFO * pInfo);
Xint              GUI_MOVIE_GetInfo      (const void * pFileData, unsigned long FileSize, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetInfoEx    (GUI_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetPos       (GUI_MOVIE_HANDLE hMovie, int * pxPos, int * pyPos, int * pxSize, int * pySize);
Nint              GUI_MOVIE_GotoFrame    (GUI_MOVIE_HANDLE hMovie, U32 Frame);
Xint              GUI_MOVIE_GotoFrame    (GUI_MOVIE_HANDLE hMovie, unsigned long Frame);
Nint              GUI_MOVIE_Pause        (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_Play         (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_SetPeriod    (GUI_MOVIE_HANDLE hMovie, unsigned Period);
Nint              GUI_MOVIE_SetPos       (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos);
Nint              GUI_MOVIE_ShowScaled   (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos, int num, int denom, int DoLoop);
Nint              GUI_MOVIE_Show         (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos, int DoLoop);
N
N/*********************************************************************
N*
N*       Cursor routines
N*/
N#define GUI_CURSOR_SHOW 0
N#define GUI_CURSOR_HIDE 1
N
Ntypedef struct {
N  const GUI_BITMAP  * pBitmap;
N  int                 xHot;
N  int                 yHot;
N} GUI_CURSOR;
N
Ntypedef struct {
N  const GUI_BITMAP ** ppBm;
N  int                 xHot;
N  int                 yHot;
N  unsigned            Period;
N  const unsigned    * pPeriod;
N  int                 NumItems;
N} GUI_CURSOR_ANIM;
N
N#if GUI_SUPPORT_CURSOR
X#if ((1) | (0))
N  int                GUI_CURSOR_GetState     (void);
N  int                GUI_CURSOR_GetStateEx   (int Layer);
N  void               GUI_CURSOR_Hide         (void);
N  void               GUI_CURSOR_HideEx       (int Layer);
N  const GUI_CURSOR * GUI_CURSOR_Select       (const GUI_CURSOR * pCursor);
N  const GUI_CURSOR * GUI_CURSOR_SelectEx     (const GUI_CURSOR * pCursor, int Layer);
N  int                GUI_CURSOR_SelectAnim   (const GUI_CURSOR_ANIM * pCursorAnim);
N  int                GUI_CURSOR_SelectAnimEx (const GUI_CURSOR_ANIM * pCursorAnim, int LayerIndex);
N  int                GUI_CURSOR_SetBitmap    (const GUI_BITMAP * pBM);
N  int                GUI_CURSOR_SetBitmapEx  (const GUI_BITMAP * pBM, int Layer);
N  void               GUI_CURSOR_SetPosition  (int x, int y);
N  void               GUI_CURSOR_SetPositionEx(int xNewPos, int yNewPos, int Layer);
N  void               GUI_CURSOR_Show         (void);
N  void               GUI_CURSOR_ShowEx       (int Layer);
N  GUI_HSPRITE        GUI_CURSOR__GetSpriteEx (int LayerIndex, int * pxPos, int * pyPos);
N  void               GUI_CURSOR__SetSpriteEx (GUI_HSPRITE hSprite, const GUI_CURSOR * pCursor, int LayerIndex);
N#else
S  #define GUI_CURSOR_Show();
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Sprite support
N*/
N#define GUI_SPRITE_CF_STAYONTOP (1 << 0)
N#define GUI_SPRITE_CF_SHOW      (1 << 1)
N
N#define GUI_SPRITE_SHOW 0
N#define GUI_SPRITE_HIDE 1
N
NGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, U16 Flags); /* Not to be documented, only used by cursor modul */
XGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, unsigned short Flags);  
Nvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, GUI_HMEM hContext, void (* pCB)(GUI_HSPRITE, int));
Xvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, signed long hContext, void (* pCB)(GUI_HSPRITE, int));
NGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateAnim          (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems);
NGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP * pBM, int x, int y, int Layer);
NGUI_HSPRITE GUI_SPRITE_CreateExAnim        (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems, int LayerIndex);
NGUI_HSPRITE GUI_SPRITE_CreateHidden        (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateHiddenEx      (const GUI_BITMAP * pBM, int x, int y, int Layer);
Nvoid        GUI_SPRITE_Delete              (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_GetState            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Hide                (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP * pBM);
Nint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP * pBM, int x, int y);
Nint         GUI_SPRITE_SetLoop             (GUI_HSPRITE hSprite, int OnOff);
Nvoid        GUI_SPRITE_SetPosition         (GUI_HSPRITE hSprite, int x, int y);
Nint         GUI_SPRITE_StartAnim           (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_StopAnim            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Show                (GUI_HSPRITE hSprite);
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
N
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Xextern const GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Xextern const GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Xextern const GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Xextern const GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Xextern const GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
Xextern const GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
N
Nextern GUI_CONST_STORAGE GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
Xextern const GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*       Text related routines
N*/
Nvoid  GUI_DispCEOL             (void);
Nvoid  GUI_DispChar             (U16 c);
Xvoid  GUI_DispChar             (unsigned short c);
Nvoid  GUI_DispCharAt           (U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt           (unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispChars            (U16 c, int Cnt);
Xvoid  GUI_DispChars            (unsigned short c, int Cnt);
Nvoid  GUI_DispNextLine         (void);
Nvoid  GUI_DispString           (const char * s);
Nvoid  GUI_DispStringAt         (const char * s, int x, int y);
Nvoid  GUI_DispStringAtCEOL     (const char * s, int x, int y);
Nvoid  GUI_DispStringHCenterAt  (const char * s, int x, int y);
Nvoid  GUI__DispStringInRect    (const char * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect     (const char * s, GUI_RECT * pRect, int TextAlign);
N#if GUI_SUPPORT_ROTATION
X#if 1
N  void  GUI_DispStringInRectEx (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
X  void  GUI_DispStringInRectEx (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax  (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Nvoid  GUI_DispStringInRectWrap (const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
Nvoid  GUI_DispStringLen        (const char * s, int Len);
Nvoid  GUI_GetTextExtend        (GUI_RECT* pRect, const char * s, int Len);
Nint   GUI_GetYAdjust           (void);
Nint   GUI_GetDispPosX          (void);
Nint   GUI_GetDispPosY          (void);
Nconst GUI_FONT * GUI_GetFont(void);
Nint   GUI_GetCharDistX         (U16 c);
Xint   GUI_GetCharDistX         (unsigned short c);
Nint   GUI_GetCharDistXEx       (U16 c, int * pSizeX);
Xint   GUI_GetCharDistXEx       (unsigned short c, int * pSizeX);
Nint   GUI_GetStringDistX       (const char * s);
NGUI_DRAWMODE GUI_GetDrawMode   (void);
Nint   GUI_GetFontDistY         (void);
Nint   GUI_GetFontSizeY         (void);
Nvoid  GUI_GetFontInfo          (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nvoid  GUI_GetOrg               (int * px, int * py);
Nint   GUI_GetYSizeOfFont       (const GUI_FONT * pFont);
Nint   GUI_GetYDistOfFont       (const GUI_FONT * pFont);
Nint   GUI_GetTextAlign         (void);
Nint   GUI_GetTextMode          (void);
Nchar  GUI_IsInFont             (const GUI_FONT * pFont, U16 c);
Xchar  GUI_IsInFont             (const GUI_FONT * pFont, unsigned short c);
Nint   GUI_SetTextAlign         (int Align);
Nint   GUI_SetTextMode          (int Mode);
Nchar  GUI_SetTextStyle         (char Style);
Nint   GUI_SetLBorder           (int x);
Nconst GUI_FONT * GUI_SetFont(const GUI_FONT * pNewFont);
Nchar  GUI_GotoXY               (int x, int y);
Nchar  GUI_GotoX                (int x);
Nchar  GUI_GotoY                (int y);
Nint   GUI_WrapGetNumLines      (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
N
Nint   GUI_GetLeadingBlankCols (U16 c);
Xint   GUI_GetLeadingBlankCols (unsigned short c);
Nint   GUI_GetTrailingBlankCols(U16 c);
Xint   GUI_GetTrailingBlankCols(unsigned short c);
N
N
N/*********************************************************************
N*
N*       System independent fonts (SIF)
N*/
Nvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       External binary fonts (XBF)
N*/
Nint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const GUI_XBF_TYPE * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Xint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const tGUI_XBF_APIList * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid GUI_XBF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Nint  GUI_TTF_CreateFont   (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nint  GUI_TTF_CreateFontAA (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nvoid GUI_TTF_DestroyCache (void);
Nvoid GUI_TTF_Done         (void);
Nint  GUI_TTF_GetFamilyName(GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_GetStyleName (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, U32 MaxBytes);
Xvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, unsigned long MaxBytes);
N
N/*********************************************************************
N*
N*       Resource file support
N*/
Nint          GUI_LANG_GetLang          (void);
Nint          GUI_LANG_GetNumItems      (int IndexLang);
Nconst char * GUI_LANG_GetText          (int IndexText);
Nint          GUI_LANG_GetTextBuffered  (int IndexText, char * pBuffer, int SizeOfBuffer);
Nint          GUI_LANG_GetTextBufferedEx(int IndexText, int IndexLang, char * pBuffer, int SizeOfBuffer);
Nconst char * GUI_LANG_GetTextEx        (int IndexText, int IndexLang);
Nint          GUI_LANG_LoadCSV          (U8 * pFileData, U32 FileSize);
Xint          GUI_LANG_LoadCSV          (unsigned char * pFileData, unsigned long FileSize);
Nint          GUI_LANG_LoadCSVEx        (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint          GUI_LANG_LoadText         (U8 * pFileData, U32 FileSize, int IndexLang);
Xint          GUI_LANG_LoadText         (unsigned char * pFileData, unsigned long FileSize, int IndexLang);
Nint          GUI_LANG_LoadTextEx       (GUI_GET_DATA_FUNC * pfGetData, void * p, int IndexLang);
Nint          GUI_LANG_SetLang          (int IndexLang);
Nunsigned     GUI_LANG_SetMaxNumLang    (unsigned MaxNumLang);
NU16          GUI_LANG_SetSep           (U16 Sep);
Xunsigned short          GUI_LANG_SetSep           (unsigned short Sep);
N
N/*********************************************************************
N*
N*       Unicode support
N*/
Nint   GUI_UC_ConvertUC2UTF8   (const U16 * s, int Len, char * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUC2UTF8   (const unsigned short * s, int Len, char * pBuffer, int BufferSize);
Nint   GUI_UC_ConvertUTF82UC   (const char * s, int Len, U16 * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUTF82UC   (const char * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint   GUI_UC_Encode           (char * s, U16 Char);
Xint   GUI_UC_Encode           (char * s, unsigned short Char);
Nint   GUI_UC_GetCharSize      (const char * s);
NU16   GUI_UC_GetCharCode      (const char * s);
Xunsigned short   GUI_UC_GetCharCode      (const char * s);
Nvoid  GUI_UC_SetEncodeNone    (void);
Nvoid  GUI_UC_SetEncodeUTF8    (void);
Nint   GUI_UC_EnableBIDI       (int OnOff);
N
Nvoid GUI_UC_DispString(const U16 * s);
Xvoid GUI_UC_DispString(const unsigned short * s);
Nvoid GUI_UC2DB (U16 Code, U8 * pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char * pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*********************************************************************
N*
N*       Drawing of binary, decimal and hexadecimal values
N*/
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*********************************************************************
N*
N*       Drawing of floating point values
N*/
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N/*********************************************************************
N*
N*       Dynamic memory management
N*/
Ntypedef struct {
N  U32 TotalBytes;
X  unsigned long TotalBytes;
N  U32 FreeBytes;
X  unsigned long FreeBytes;
N  U32 UsedBytes;
X  unsigned long UsedBytes;
N  U32 AllocSize;
X  unsigned long AllocSize;
N  U32 NumFixedBytes;
X  unsigned long NumFixedBytes;
N  U32 MaxUsedBytes;
X  unsigned long MaxUsedBytes;
N} GUI_ALLOC_INFO;
N
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
Xsigned long GUI_ALLOC_GetNumFreeBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
Xsigned long GUI_ALLOC_GetNumFreeBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
Xsigned long GUI_ALLOC_GetNumUsedBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
Xsigned long GUI_ALLOC_GetNumUsedBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxUsedBytes (void);
Xsigned long GUI_ALLOC_GetMaxUsedBytes (void);
N
Nvoid GUI_ALLOC_GetMemInfo  (GUI_ALLOC_INFO * pInfo);
Nvoid GUI_ALLOC_SuppressPeak(int OnOff);
N
NGUI_HMEM           GUI_ALLOC_AllocInit       (const void * pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned long           GUI_ALLOC_AllocInit       (const void * pInitData, signed long Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocNoInit     (signed long size);
NGUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocZero       (signed long size);
Nvoid               GUI_ALLOC_AssignMemory    (void * p, U32 NumBytes);
Xvoid               GUI_ALLOC_AssignMemory    (void * p, unsigned long NumBytes);
Nvoid               GUI_ALLOC_Free            (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free            (signed long  hMem);
Nvoid               GUI_ALLOC_FreeFixedBlock  (void * p);
Nvoid               GUI_ALLOC_FreePtrArray    (GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray    (signed long * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr         (GUI_HMEM * phMem);
Xvoid               GUI_ALLOC_FreePtr         (signed long * phMem);
Nvoid *             GUI_ALLOC_GetFixedBlock   (GUI_ALLOC_DATATYPE Size);
Xvoid *             GUI_ALLOC_GetFixedBlock   (signed long Size);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize      (void);
Xsigned long GUI_ALLOC_GetMaxSize      (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize         (GUI_HMEM  hMem);
Xsigned long GUI_ALLOC_GetSize         (signed long  hMem);
Nvoid *             GUI_ALLOC_h2p             (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_h2p             (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_p2h             (void * p);
Xsigned long           GUI_ALLOC_p2h             (void * p);
Nvoid               GUI_ALLOC_Init            (void);
Nvoid               GUI_ALLOC_Lock            (void);
Nvoid *             GUI_ALLOC_LockH           (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_LockH           (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_Realloc         (GUI_HMEM hOld, int NewSize);
Xsigned long           GUI_ALLOC_Realloc         (signed long hOld, int NewSize);
NGUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize     (void);
Xsigned long GUI_ALLOC_RequestSize     (void);
Nvoid               GUI_ALLOC_SetAvBlockSize  (U32 BlockSize);
Xvoid               GUI_ALLOC_SetAvBlockSize  (unsigned long BlockSize);
Nvoid               GUI_ALLOC_Unlock          (void);
Nvoid *             GUI_ALLOC_UnlockH         (void ** pp);
Nint                GUI_ALLOC_SetMaxPercentage(int MaxPercentage);
N
N/*********************************************************************
N*
N*       Memory devices: GUI_MEMDEV
N*/
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS  (1 << 0)
N
Ntypedef GUI_HMEM GUI_MEMDEV_Handle;
Xtypedef signed long GUI_MEMDEV_Handle;
Ntypedef void     GUI_CALLBACK_VOID_P        (void * p);
Ntypedef int      GUI_ANIMATION_CALLBACK_FUNC(int TimeRem, void * pVoid);
Ntypedef void     GUI_DRAWMEMDEV_16BPP_FUNC  (void * pDst, const void * pSrc, int xSize, int ySize, int BytesPerLineDst, int BytesPerLineSrc);
N
Nextern GUI_ANIMATION_CALLBACK_FUNC * GUI_MEMDEV__pCbAnimation;
Nextern void                        * GUI_MEMDEV__pVoid;
N
Ntypedef struct {
N  GUI_RECT rView, rPrev;
N  char FirstCall;
N} GUI_AUTODEV;
N
Ntypedef struct {
N  char DrawFixed;
N  char IsMeasurement;
N} GUI_AUTODEV_INFO;
N
Nint  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
Nvoid GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
Nint  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N/* Create a memory device which is compatible to the selected LCD */
NGUI_MEMDEV_Handle GUI_MEMDEV_Create       (int x0, int y0, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateEx     (int x0, int y0, int xSize, int ySize, int Flags);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed  (int x0, int y0, int xSize, int ySize, int Flags,
N                                           const GUI_DEVICE_API     * pDeviceAPI,
N                                           const LCD_API_COLOR_CONV * pColorConvAPI);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed32(int x0, int y0, int xSize, int ySize);
N
Nvoid GUI_MEMDEV_Clear                (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_ClearAlpha           (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid GUI_MEMDEV_CopyFromLCD          (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCDAA        (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCD            (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAA          (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAt          (GUI_MEMDEV_Handle hMem, int x, int y);
Nint  GUI_MEMDEV_CompareWithLCD       (GUI_MEMDEV_Handle hMem, int * px, int * py, int * pExp, int * pAct);
Nvoid GUI_MEMDEV_Delete               (GUI_MEMDEV_Handle MemDev);
Nvoid GUI_MEMDEV_DrawPerspectiveX     (GUI_MEMDEV_Handle hMem, int x, int y, int h0, int h1, int dx, int dy);
Nint  GUI_MEMDEV_GetXPos              (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetXSize             (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYPos              (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYSize             (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_MarkDirty            (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
Nvoid GUI_MEMDEV_ReduceYSize          (GUI_MEMDEV_Handle hMem, int YSize);
Nvoid GUI_MEMDEV_Rotate               (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateAlpha          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid GUI_MEMDEV_RotateAlpha          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid GUI_MEMDEV_RotateHR             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid GUI_MEMDEV_RotateHR             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid GUI_MEMDEV__Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U32 Mask);
Xvoid GUI_MEMDEV__Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned long Mask);
Nvoid GUI_MEMDEV__RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag, U32 Mask);
Xvoid GUI_MEMDEV__RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag, unsigned long Mask);
Nvoid GUI_MEMDEV_RotateHQ             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQAlpha        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid GUI_MEMDEV_RotateHQAlpha        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid GUI_MEMDEV_RotateHQHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid GUI_MEMDEV_RotateHQHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQT            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQTI           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
NGUI_MEMDEV_Handle GUI_MEMDEV_Select  (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
Nvoid  GUI_MEMDEV_SetOrg              (GUI_MEMDEV_Handle hMem, int x0, int y0);
Nvoid  GUI_MEMDEV_WriteAt             (GUI_MEMDEV_Handle hMem, int x, int y);
Nvoid  GUI_MEMDEV_Write               (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteAlphaAt        (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
Nvoid  GUI_MEMDEV_WriteAlpha          (GUI_MEMDEV_Handle hMem, int Alpha);
Nvoid  GUI_MEMDEV_WriteExAt           (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteEx             (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteOpaque         (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteOpaqueAt       (GUI_MEMDEV_Handle hMem, int x, int y);
Nint   GUI_MEMDEV_Draw                (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, int NumLines, int Flags);
Nvoid* GUI_MEMDEV_GetDataPtr          (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_SetColorConv        (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
Nconst LCD_API_COLOR_CONV * GUI_MEMDEV_GetColorConv(GUI_MEMDEV_Handle hMemDev);
Nint   GUI_MEMDEV_GetBitsPerPixel     (GUI_MEMDEV_Handle hMemDev);
Nint   GUI_MEMDEV_FadeInDevices       (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nint   GUI_MEMDEV_FadeOutDevices      (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nvoid  GUI_MEMDEV_SerializeBMP        (GUI_MEMDEV_Handle hDev, GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid  GUI_MEMDEV_SetAnimationCallback(GUI_ANIMATION_CALLBACK_FUNC * pCbAnimation, void * pVoid);
Nvoid  GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens);
Xvoid  GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens);
Nvoid  GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens, int xPosWin, int yPosWin);
Xvoid  GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens, int xPosWin, int yPosWin);
Nint   GUI_MEMDEV_PunchOutDevice      (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid  GUI_MEMDEV_SetTimePerFrame     (unsigned TimePerFrame);
N
Nvoid  GUI_SelectLCD(void);
N
N/* Blurring, dithering and blending */
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
Nvoid              GUI_MEMDEV_SetBlurHQ              (void);
Nvoid              GUI_MEMDEV_SetBlurLQ              (void);
Nint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
Nint               GUI_MEMDEV_Dither32               (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N/* Optional custom drawing of 16bpp memory devices */
Nvoid GUI_MEMDEV_SetDrawMemdev16bppFunc(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdev16bppFunc);
N
N/*********************************************************************
N*
N*       Alpha blending
N*/
Ntypedef struct {
N  U32 UserAlpha;
X  unsigned long UserAlpha;
N} GUI_ALPHA_STATE;
N
N#define GUI_MAKE_ALPHA(Alpha, Color) ((U32)(((U32)Alpha << 24) | (Color & 0xFFFFFF)))
N
Nunsigned GUI_EnableAlpha         (unsigned OnOff);
NU32      GUI_RestoreUserAlpha    (GUI_ALPHA_STATE * pAlphaState);
Xunsigned long      GUI_RestoreUserAlpha    (GUI_ALPHA_STATE * pAlphaState);
Nunsigned GUI_SetAlpha            (U8 Alpha);
Xunsigned GUI_SetAlpha            (unsigned char Alpha);
NU32      GUI_SetUserAlpha        (GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha);
Xunsigned long      GUI_SetUserAlpha        (GUI_ALPHA_STATE * pAlphaState, unsigned long UserAlpha);
Nvoid     GUI_SetFuncAlphaBlending(void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32));
Xvoid     GUI_SetFuncAlphaBlending(void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long));
Nvoid     GUI_SetFuncMixColors    (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens));
Xvoid     GUI_SetFuncMixColors    (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens));
Nvoid     GUI_SetFuncMixColorsBulk(void (* pFunc)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens));
Xvoid     GUI_SetFuncMixColorsBulk(void (* pFunc)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens));
Nunsigned GUI_PreserveTrans       (unsigned OnOff);
N
N/*********************************************************************
N*
N*       Multi layer support
N*/
Nunsigned GUI_SelectLayer(unsigned Index);
Nunsigned GUI_GetSelLayer(void);
N
Nint  GUI_SetLayerPosEx  (unsigned Index, int xPos, int yPos);
Nint  GUI_SetLayerSizeEx (unsigned Index, int xSize, int ySize);
Nint  GUI_SetLayerVisEx  (unsigned Index, int OnOff);
Nint  GUI_SetLayerAlphaEx(unsigned Index, int Alpha);
Nvoid GUI_GetLayerPosEx  (unsigned Index, int * pxPos, int * pyPos);
N
Nvoid     GUI_AssignCursorLayer(unsigned Index, unsigned CursorLayer);
Nunsigned GUI_GetCursorLayer   (unsigned Index);
N
N/*********************************************************************
N*
N*       Multiple buffers and display origin
N*/
Nvoid GUI_SetOrg(int x, int y);
N
Nvoid GUI_MULTIBUF_Begin          (void);
Nvoid GUI_MULTIBUF_BeginEx        (int LayerIndex);
Nvoid GUI_MULTIBUF_End            (void);
Nvoid GUI_MULTIBUF_EndEx          (int LayerIndex);
Nvoid GUI_MULTIBUF_Config         (int NumBuffers);
Nvoid GUI_MULTIBUF_ConfigEx       (int LayerIndex, int NumBuffers);
Nvoid GUI_MULTIBUF_Confirm        (int Index);
Nvoid GUI_MULTIBUF_ConfirmEx      (int LayerIndex, int BufferIndex);
Nint  GUI_MULTIBUF_GetNumBuffers  (void);
Nint  GUI_MULTIBUF_GetNumBuffersEx(int LayerIndex);
Nvoid GUI_MULTIBUF_UseSingleBuffer(void);
N
N/*********************************************************************
N*
N*       emWinSPY
N*/
Nint  GUI_SPY_Process      (GUI_tSend pfSend, GUI_tRecv pfRecv, void * pConnectInfo);
Nvoid GUI_SPY_SetMemHandler(GUI_tMalloc pMalloc, GUI_tFree pFree);
Nint  GUI_SPY_StartServer  (void);
Nint  GUI_SPY_X_StartServer(void);
N
N/*********************************************************************
N*
N*       Basics for animations
N*/
N#define ANIM_LINEAR     GUI_ANIM__Linear
N#define ANIM_ACCEL      GUI_ANIM__Accel
N#define ANIM_DECEL      GUI_ANIM__Decel
N#define ANIM_ACCELDECEL GUI_ANIM__AccelDecel
N
N#define GUI_ANIM_START   0
N#define GUI_ANIM_RUNNING 1
N#define GUI_ANIM_END     2
N
N#ifndef   GUI_ANIM_RANGE
N  #define GUI_ANIM_RANGE 32767L
N#endif
N
Ntypedef GUI_HMEM GUI_ANIM_HANDLE;
Xtypedef signed long GUI_ANIM_HANDLE;
N
Ntypedef I32 (* GUI_ANIM_GETPOS_FUNC)(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xtypedef signed long (* GUI_ANIM_GETPOS_FUNC)(int ts, int te, int tNow);
N
Ntypedef struct {
N  int Pos;
N  int State;
N  GUI_ANIM_HANDLE hAnim;
N  GUI_TIMER_TIME Period;
X  int Period;
N} GUI_ANIM_INFO;
N
Ntypedef void GUI_ANIMATION_FUNC(GUI_ANIM_INFO * pInfo, void * pVoid);
N
NI32 GUI_ANIM__Linear    (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Linear    (int ts, int te, int tNow);
NI32 GUI_ANIM__Decel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Decel     (int ts, int te, int tNow);
NI32 GUI_ANIM__Accel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Accel     (int ts, int te, int tNow);
NI32 GUI_ANIM__AccelDecel(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__AccelDecel(int ts, int te, int tNow);
N
Nint             GUI_ANIM_AddItem(GUI_ANIM_HANDLE hAnim, GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
Xint             GUI_ANIM_AddItem(GUI_ANIM_HANDLE hAnim, int ts, int te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
NGUI_ANIM_HANDLE GUI_ANIM_Create (GUI_TIMER_TIME Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSliceInfo)(int State, void * pVoid));
XGUI_ANIM_HANDLE GUI_ANIM_Create (int Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSliceInfo)(int State, void * pVoid));
Nvoid            GUI_ANIM_Delete (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_Exec   (GUI_ANIM_HANDLE hAnim);
Nvoid            GUI_ANIM_Start  (GUI_ANIM_HANDLE hAnim);
N
N/*********************************************************************
N*
N*       Display orientation
N*/
N/*********************************************************************
N*
N*       GUI_ORIENTATION_API
N*/
Ntypedef struct {
N  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void     (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void     (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void     (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void     (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
N  void     (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  int      BytesPerPixel;
N} GUI_ORIENTATION_API;
N
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C0;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C8;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C16;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C32;
N
N#define GUI_ORIENTATION_C0  &GUI_OrientationAPI_C0
N#define GUI_ORIENTATION_C8  &GUI_OrientationAPI_C8
N#define GUI_ORIENTATION_C16 &GUI_OrientationAPI_C16
N#define GUI_ORIENTATION_C32 &GUI_OrientationAPI_C32
N
Nint GUI_SetOrientation        (int Orientation);
Nint GUI_SetOrientationEx      (int Orientation, int LayerIndex);
Nint GUI_SetOrientationExCached(int Orientation, int LayerIndex, const GUI_ORIENTATION_API * pAPI);
N
N/*********************************************************************
N*
N*       Measure device: GUI_MEASDEV
N*/
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed long GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT * pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/*********************************************************************
N*
N*       Polygon helpers
N*/
Nvoid GUI_RotatePolygon (GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Len);
N
N/*********************************************************************
N*
N*       Streamed bitmaps
N*/
N#define GUI_BITMAPSTREAM_GET_BUFFER     1
N#define GUI_BITMAPSTREAM_RELEASE_BUFFER 2
N#define GUI_BITMAPSTREAM_MODIFY_PALETTE 3
N
N#define DECLARE_CREATE_FROM_STREAM(ID) int GUI_CreateBitmapFromStream##ID(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
NDECLARE_CREATE_FROM_STREAM(IDX)
Xint GUI_CreateBitmapFromStreamIDX(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE4)
Xint GUI_CreateBitmapFromStreamRLE4(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE8)
Xint GUI_CreateBitmapFromStreamRLE8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(565)
Xint GUI_CreateBitmapFromStream565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M565)
Xint GUI_CreateBitmapFromStreamM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(555)
Xint GUI_CreateBitmapFromStream555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M555)
Xint GUI_CreateBitmapFromStreamM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A565)
Xint GUI_CreateBitmapFromStreamA565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM565)
Xint GUI_CreateBitmapFromStreamAM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A555)
Xint GUI_CreateBitmapFromStreamA555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM555)
Xint GUI_CreateBitmapFromStreamAM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE16)
Xint GUI_CreateBitmapFromStreamRLE16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEM16)
Xint GUI_CreateBitmapFromStreamRLEM16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(24)
Xint GUI_CreateBitmapFromStream24(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(Alpha)
Xint GUI_CreateBitmapFromStreamAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M8888I)
Xint GUI_CreateBitmapFromStreamM8888I(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEAlpha)
Xint GUI_CreateBitmapFromStreamRLEAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE32)
Xint GUI_CreateBitmapFromStreamRLE32(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12)
Xint GUI_CreateBitmapFromStream444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12)
Xint GUI_CreateBitmapFromStreamM444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12_1)
Xint GUI_CreateBitmapFromStream444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12_1)
Xint GUI_CreateBitmapFromStreamM444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_16)
Xint GUI_CreateBitmapFromStream444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_16)
Xint GUI_CreateBitmapFromStreamM444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
Nint  GUI_CreateBitmapFromStream   (GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
Nvoid GUI_DrawStreamedBitmap       (const void * p, int x, int y);
Nvoid GUI_DrawStreamedBitmapAuto   (const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapEx     (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapExAuto (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap555Ex  (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM555Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap565Ex  (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM565Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA555Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM555Ex(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA565Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM565Ex(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap24Ex   (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nvoid GUI_GetStreamedBitmapInfo    (const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nint  GUI_GetStreamedBitmapInfoEx  (GUI_GET_DATA_FUNC * pfGetData, const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid GUI_SetStreamedBitmapHook    (GUI_BITMAPSTREAM_CALLBACK pfStreamedBitmapHook);
N
Nvoid LCD__RLE4_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE4_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE8_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE8_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE16_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE16_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
Nvoid LCD__RLE32_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE32_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
N
N/*********************************************************************
N*
N*       BMP-export
N*/
Nvoid GUI_BMP_Serialize     (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid GUI_BMP_SerializeEx   (GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_SerializeExBpp(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p, int BitsPerPixel);
N
N/*********************************************************************
N*
N*       Time / execution related routines
N*/
Nvoid           GUI_Delay  (int Period);
NGUI_TIMER_TIME GUI_GetTime(void);
Xint GUI_GetTime(void);
Nint            GUI_Exec(void);         /* Execute all jobs ... Return 0 if nothing was done. */
Nint            GUI_Exec1(void);        /* Execute one job  ... Return 0 if nothing was done. */
N
N/*********************************************************************
N*
N*       MessageBox
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*       GUI_TIMER module
N*/
N#define GUI_TIMER_CF_WINDOW (1 << 0)
N#define GUI_TIMER_CF_CURSOR (1 << 1)
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed long GUI_TIMER_HANDLE;
N
Ntypedef struct {
N  GUI_TIMER_TIME   Time;
X  int   Time;
N  U32              Context;
X  unsigned long              Context;
N  GUI_TIMER_HANDLE hTimer;
N} GUI_TIMER_MESSAGE;
N
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, GUI_TIMER_TIME Time, U32 Context, U16 Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, int Time, unsigned long Context, unsigned short Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
NGUI_TIMER_TIME GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Xint GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Nvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetTime  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetTime  (GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid           GUI_TIMER_Restart  (GUI_TIMER_HANDLE hObj);
Nint            GUI_TIMER_GetFlag  (GUI_TIMER_HANDLE hObj, int Flag); /* Not to be documented */
Nint            GUI_TIMER_Exec     (void);
N
N/*********************************************************************
N*
N*       Anti Aliasing
N*/
N#define GUI_AA_TRANS   0 // Foreground color mixed up with current content of framebuffer
N#define GUI_AA_NOTRANS 1 // Foreground color mixed up with current background color
N
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_DrawRoundedRectEx(GUI_RECT * pRect, int r);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_AA_FillPolygon      (GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_AA_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_FillRoundedRectEx(GUI_RECT * pRect, int r);
N//int  GUI_AA_PreserveTrans    (int OnOff);
Nint  GUI_AA_SetDrawMode      (int Mode);
Nvoid GUI_AA_SetpfDrawCharAA4 (int (* pfDrawChar)(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine));
Xvoid GUI_AA_SetpfDrawCharAA4 (int (* pfDrawChar)(int LayerIndex, int x, int y, unsigned char const * p, int xSize, int ySize, int BytesPerLine));
N
N#define GUI_AA_PreserveTrans(OnOff) GUI_PreserveTrans(OnOff)
N
N/*********************************************************************
N*
N*       Keyboard
N*/
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg (void);
Nvoid GUI_GetKeyState(GUI_KEY_STATE * pState);
N
Nvoid GUI_KEY__SetHook(void (* pfHook)(const GUI_KEY_STATE *));
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Nvoid GUI_WaitEvent            (void);
Nvoid GUI_SignalEvent          (void);
Nvoid GUI_SetSignalEventFunc   (GUI_SIGNAL_EVENT_FUNC     pfSignalEvent);
Nvoid GUI_SetWaitEventFunc     (GUI_WAIT_EVENT_FUNC       pfWaitEvent);
Nvoid GUI_SetWaitEventTimedFunc(GUI_WAIT_EVENT_TIMED_FUNC pfWaitEventTimed);
N
N/*********************************************************************
N*
N*       Joystick, generic
N*/
Nvoid GUI_JOYSTICK_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       PID  (Pointer input device ... mouse/touch)
N*/
Nvoid GUI_PID_StoreState     (const GUI_PID_STATE * pState);
Nint  GUI_PID_GetState       (      GUI_PID_STATE * pState);
Nvoid GUI_PID_GetCurrentState(      GUI_PID_STATE * pState);
Nint  GUI_PID_IsEmpty        (void);
Nint  GUI_PID_IsPressed      (void);
Nvoid GUI_PID__SetHook       (void (* pfHook)(const GUI_PID_STATE *));
N
N/*********************************************************************
N*
N*       Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE * pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       TOUCH screen, generic
N*/
Nint  GUI_TOUCH_GetLayer     (void);
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_GetUnstable  (int * px, int * py);  /* for diagnostics only */
Nvoid GUI_TOUCH_SetLayer     (int Layer);
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N/*********************************************************************
N*
N*       Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N/*********************************************************************
N*
N*       TOUCH screen, analog driver
N*/
Nint  GUI_TOUCH_CalcCoefficients (int NumPoints, int * pxRef, int * pyRef, int * pxSample, int * pySample, int xSize, int ySize);
Nint  GUI_TOUCH_Calibrate        (int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nint  GUI_TOUCH_CalibratePoint   (int * px, int * py);
Nvoid GUI_TOUCH_EnableCalibration(int OnOff);
Nvoid GUI_TOUCH_Exec             (void);
Nint  GUI_TOUCH_GetxPhys         (void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys         (void);    /* for diagnostics only */
Nvoid GUI_TOUCH_SetCalibration   (int (* pFunc)(int *, int *)); /* Not to be documented */
Nvoid GUI_TOUCH_SetOrientation   (unsigned Orientation);
Nint  GUI_TOUCH_TransformPoint   (int * px, int * py);          /* Not to be documented */
N
N/*********************************************************************
N*
N*       TOUCH: imports
N*
N* Please note: The following functions are required by the module.
N* They need to be part of your application software (or rather, part
N* of the hardware-layer of your software).
N*/
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable  (void);
Nint  GUI_TOUCH_X_MeasureX (void);
Nint  GUI_TOUCH_X_MeasureY (void);
N
N/*********************************************************************
N*
N*       GUI_X_
N*
N* Externals, to be defined by application
N*
N* The externals defined below should be defined by the
N* application. They are per default contained in the module
N* GUI_X.c.
N* Note that a lot if not all of these are not required in most target
N* systems.
N* For this module, samples are available for configurations
N* with or without operating system.
N*/
N//
N// Configuration
N//
Nvoid GUI_X_Config(void);
Nvoid GUI_X_Init  (void);
N
N//
N// Timing routines
N//
NGUI_TIMER_TIME GUI_X_GetTime(void);
Xint GUI_X_GetTime(void);
Nvoid           GUI_X_Delay  (int Period);
N
N//
N// Multitask routines - required only if multitasking is used (#define GUI_OS 1)
N//
Nvoid GUI_X_Unlock   (void);
Nvoid GUI_X_Lock     (void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS   (void);
N
N//
N// Event driving (optional with multitasking)
N//
Nvoid GUI_X_ExecIdle      (void);
Nvoid GUI_X_WaitEvent     (void);
Nvoid GUI_X_WaitEventTimed(int Period);
Nvoid GUI_X_SignalEvent   (void);
N
N//
N// Recording (logs/warnings and errors) - required only for higher levels
N//
Nvoid GUI_X_Log     (const char * s);
Nvoid GUI_X_Warn    (const char * s);
Nvoid GUI_X_ErrorOut(const char * s);
N
N/*********************************************************************
N*
N*       Constants for fonts and bitmaps
N*/
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEAlpha;
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods24;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods8888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM8888I;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM555;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4         &GUI_BitmapMethodsRLE4       /* Method table ! */
N#define GUI_DRAW_RLE8         &GUI_BitmapMethodsRLE8       /* Method table ! */
N#define GUI_DRAW_RLE16        &GUI_BitmapMethodsRLE16      /* Method table ! */
N#define GUI_DRAW_RLEM16       &GUI_BitmapMethodsRLEM16     /* Method table ! */
N#define GUI_DRAW_RLE32        &GUI_BitmapMethodsRLE32      /* Method table ! */
N#define GUI_DRAW_RLEALPHA     &GUI_BitmapMethodsRLEAlpha   /* Method table ! */
N
N#define GUI_DRAW_BMP444_12    &GUI_BitmapMethods444_12     /* Method table ! */
N#define GUI_DRAW_BMPM444_12   &GUI_BitmapMethodsM444_12    /* Method table ! */
N#define GUI_DRAW_BMP444_12_1  &GUI_BitmapMethods444_12_1   /* Method table ! */
N#define GUI_DRAW_BMPM444_12_1 &GUI_BitmapMethodsM444_12_1  /* Method table ! */
N#define GUI_DRAW_BMP444_16    &GUI_BitmapMethods444_16     /* Method table ! */
N#define GUI_DRAW_BMPM444_16   &GUI_BitmapMethodsM444_16    /* Method table ! */
N#define GUI_DRAW_BMP555       &GUI_BitmapMethods555        /* Method table ! */
N#define GUI_DRAW_BMPM555      &GUI_BitmapMethodsM555       /* Method table ! */
N#define GUI_DRAW_BMP565       &GUI_BitmapMethods565        /* Method table ! */
N#define GUI_DRAW_BMPM565      &GUI_BitmapMethodsM565       /* Method table ! */
N#define GUI_DRAW_BMP24        &GUI_BitmapMethods24         /* Method table ! */
N#define GUI_DRAW_BMP888       &GUI_BitmapMethods888        /* Method table ! */
N#define GUI_DRAW_BMPM888      &GUI_BitmapMethodsM888       /* Method table ! */
N#define GUI_DRAW_BMP8888      &GUI_BitmapMethods8888       /* Method table ! */
N#define GUI_DRAW_BMPM8888I    &GUI_BitmapMethodsM8888I     /* Method table ! */
N#define GUI_DRAW_BMPA555      &GUI_BitmapMethodsA555       /* Method table ! */
N#define GUI_DRAW_BMPAM555     &GUI_BitmapMethodsAM555      /* Method table ! */
N#define GUI_DRAW_BMPA565      &GUI_BitmapMethodsA565       /* Method table ! */
N#define GUI_DRAW_BMPAM565     &GUI_BitmapMethodsAM565      /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Ext;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Frm;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2_EXT;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4_EXT;
N
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Frm;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA2_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA4_Ext;
N
N/*********************************************************************
N*
N*       GUI_KEY_...
N*
N* These ID values are basically meant to be used with widgets
N* Note that we have chosen the values to be close to existing
N* "standards", so do not change them unless forced to.
N*
N*/
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL    0xFE
N#define GUI_ID_HSCROLL    0xFF
N
N#define GUI_ID_EDIT0      0x100
N#define GUI_ID_EDIT1      0x101
N#define GUI_ID_EDIT2      0x102
N#define GUI_ID_EDIT3      0x103
N#define GUI_ID_EDIT4      0x104
N#define GUI_ID_EDIT5      0x105
N#define GUI_ID_EDIT6      0x106
N#define GUI_ID_EDIT7      0x107
N#define GUI_ID_EDIT8      0x108
N#define GUI_ID_EDIT9      0x109
N
N#define GUI_ID_LISTBOX0   0x110
N#define GUI_ID_LISTBOX1   0x111
N#define GUI_ID_LISTBOX2   0x112
N#define GUI_ID_LISTBOX3   0x113
N#define GUI_ID_LISTBOX4   0x114
N#define GUI_ID_LISTBOX5   0x115
N#define GUI_ID_LISTBOX6   0x116
N#define GUI_ID_LISTBOX7   0x117
N#define GUI_ID_LISTBOX8   0x118
N#define GUI_ID_LISTBOX9   0x119
N
N#define GUI_ID_CHECK0     0x120
N#define GUI_ID_CHECK1     0x121
N#define GUI_ID_CHECK2     0x122
N#define GUI_ID_CHECK3     0x123
N#define GUI_ID_CHECK4     0x124
N#define GUI_ID_CHECK5     0x125
N#define GUI_ID_CHECK6     0x126
N#define GUI_ID_CHECK7     0x127
N#define GUI_ID_CHECK8     0x128
N#define GUI_ID_CHECK9     0x129
N
N#define GUI_ID_SLIDER0    0x130
N#define GUI_ID_SLIDER1    0x131
N#define GUI_ID_SLIDER2    0x132
N#define GUI_ID_SLIDER3    0x133
N#define GUI_ID_SLIDER4    0x134
N#define GUI_ID_SLIDER5    0x135
N#define GUI_ID_SLIDER6    0x136
N#define GUI_ID_SLIDER7    0x137
N#define GUI_ID_SLIDER8    0x138
N#define GUI_ID_SLIDER9    0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x143
N
N#define GUI_ID_RADIO0     0x150
N#define GUI_ID_RADIO1     0x151
N#define GUI_ID_RADIO2     0x152
N#define GUI_ID_RADIO3     0x153
N#define GUI_ID_RADIO4     0x154
N#define GUI_ID_RADIO5     0x155
N#define GUI_ID_RADIO6     0x156
N#define GUI_ID_RADIO7     0x157
N
N#define GUI_ID_TEXT0      0x160
N#define GUI_ID_TEXT1      0x161
N#define GUI_ID_TEXT2      0x162
N#define GUI_ID_TEXT3      0x163
N#define GUI_ID_TEXT4      0x164
N#define GUI_ID_TEXT5      0x165
N#define GUI_ID_TEXT6      0x166
N#define GUI_ID_TEXT7      0x167
N#define GUI_ID_TEXT8      0x168
N#define GUI_ID_TEXT9      0x169
N
N#define GUI_ID_BUTTON0    0x170
N#define GUI_ID_BUTTON1    0x171
N#define GUI_ID_BUTTON2    0x172
N#define GUI_ID_BUTTON3    0x173
N#define GUI_ID_BUTTON4    0x174
N#define GUI_ID_BUTTON5    0x175
N#define GUI_ID_BUTTON6    0x176
N#define GUI_ID_BUTTON7    0x177
N#define GUI_ID_BUTTON8    0x178
N#define GUI_ID_BUTTON9    0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0     0x220
N#define GUI_ID_GRAPH1     0x221
N#define GUI_ID_GRAPH2     0x222
N#define GUI_ID_GRAPH3     0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_TREEVIEW0  0x240
N#define GUI_ID_TREEVIEW1  0x241
N#define GUI_ID_TREEVIEW2  0x242
N#define GUI_ID_TREEVIEW3  0x243
N
N#define GUI_ID_ICONVIEW0  0x250
N#define GUI_ID_ICONVIEW1  0x251
N#define GUI_ID_ICONVIEW2  0x252
N#define GUI_ID_ICONVIEW3  0x253
N
N#define GUI_ID_LISTWHEEL0 0x260
N#define GUI_ID_LISTWHEEL1 0x261
N#define GUI_ID_LISTWHEEL2 0x262
N#define GUI_ID_LISTWHEEL3 0x263
N
N#define GUI_ID_IMAGE0     0x270
N#define GUI_ID_IMAGE1     0x271
N#define GUI_ID_IMAGE2     0x272
N#define GUI_ID_IMAGE3     0x273
N#define GUI_ID_IMAGE4     0x274
N#define GUI_ID_IMAGE5     0x275
N#define GUI_ID_IMAGE6     0x276
N#define GUI_ID_IMAGE7     0x277
N#define GUI_ID_IMAGE8     0x278
N#define GUI_ID_IMAGE9     0x279
N
N#define GUI_ID_SPINBOX0   0x280
N#define GUI_ID_SPINBOX1   0x281
N#define GUI_ID_SPINBOX2   0x282
N#define GUI_ID_SPINBOX3   0x283
N#define GUI_ID_SPINBOX4   0x284
N#define GUI_ID_SPINBOX5   0x285
N#define GUI_ID_SPINBOX6   0x286
N#define GUI_ID_SPINBOX7   0x287
N#define GUI_ID_SPINBOX8   0x288
N#define GUI_ID_SPINBOX9   0x289
N
N#define GUI_ID_CALENDAR0  0x290
N
N#define GUI_ID_KNOB0      0x300
N#define GUI_ID_KNOB1      0x301
N#define GUI_ID_KNOB2      0x302
N#define GUI_ID_KNOB3      0x303
N#define GUI_ID_KNOB4      0x304
N#define GUI_ID_KNOB5      0x305
N#define GUI_ID_KNOB6      0x306
N#define GUI_ID_KNOB7      0x307
N#define GUI_ID_KNOB8      0x308
N#define GUI_ID_KNOB9      0x309
N
N#define GUI_ID_SWIPELIST0 0x320
N#define GUI_ID_SWIPELIST1 0x321
N#define GUI_ID_SWIPELIST2 0x322
N
N#define GUI_ID_USER       0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Text styles
N*/
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/*********************************************************************
N*
N*       Line styles
N*/
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N/*********************************************************************
N*
N*       Pen shapes
N*/
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N/*********************************************************************
N*
N*       Standard colors
N*/
N#if (GUI_USE_ARGB)
S  #define GUI_BLUE          0xFF0000FF
S  #define GUI_GREEN         0xFF00FF00
S  #define GUI_RED           0xFFFF0000
S  #define GUI_CYAN          0xFF00FFFF
S  #define GUI_MAGENTA       0xFFFF00FF
S  #define GUI_YELLOW        0xFFFFFF00
S  #define GUI_LIGHTBLUE     0xFF8080FF
S  #define GUI_LIGHTGREEN    0xFF80FF80
S  #define GUI_LIGHTRED      0xFFFF8080
S  #define GUI_LIGHTCYAN     0xFF80FFFF
S  #define GUI_LIGHTMAGENTA  0xFFFF80FF
S  #define GUI_LIGHTYELLOW   0xFFFFFF80
S  #define GUI_DARKBLUE      0xFF000080
S  #define GUI_DARKGREEN     0xFF008000
S  #define GUI_DARKRED       0xFF800000
S  #define GUI_DARKCYAN      0xFF008080
S  #define GUI_DARKMAGENTA   0xFF800080
S  #define GUI_DARKYELLOW    0xFF808000
S  #define GUI_WHITE         0xFFFFFFFF
S  #define GUI_LIGHTGRAY     0xFFD3D3D3
S  #define GUI_GRAY          0xFF808080
S  #define GUI_DARKGRAY      0xFF404040
S  #define GUI_BLACK         0xFF000000
S  #define GUI_BROWN         0xFFA52A2A
S  #define GUI_ORANGE        0xFFFFA500
S  #define GUI_TRANSPARENT   0x00000000
S
S  #define GUI_GRAY_3F       0xFF3F3F3F
S  #define GUI_GRAY_50       0xFF505050
S  #define GUI_GRAY_55       0xFF555555
S  #define GUI_GRAY_60       0xFF606060
S  #define GUI_GRAY_7C       0xFF7C7C7C
S  #define GUI_GRAY_9A       0xFF9A9A9A
S  #define GUI_GRAY_AA       0xFFAAAAAA
S  #define GUI_GRAY_C0       0xFFC0C0C0
S  #define GUI_GRAY_C8       0xFFC8C8C8
S  #define GUI_GRAY_D0       0xFFD0D0D0
S  #define GUI_GRAY_E7       0xFFE7E7E7
S  #define GUI_BLUE_98       0xFF000098
N#else
N  #define GUI_BLUE          0x00FF0000
N  #define GUI_GREEN         0x0000FF00
N  #define GUI_RED           0x000000FF
N  #define GUI_CYAN          0x00FFFF00
N  #define GUI_MAGENTA       0x00FF00FF
N  #define GUI_YELLOW        0x0000FFFF
N  #define GUI_LIGHTBLUE     0x00FF8080
N  #define GUI_LIGHTGREEN    0x0080FF80
N  #define GUI_LIGHTRED      0x008080FF
N  #define GUI_LIGHTCYAN     0x00FFFF80
N  #define GUI_LIGHTMAGENTA  0x00FF80FF
N  #define GUI_LIGHTYELLOW   0x0080FFFF
N  #define GUI_DARKBLUE      0x00800000
N  #define GUI_DARKGREEN     0x00008000
N  #define GUI_DARKRED       0x00000080
N  #define GUI_DARKCYAN      0x00808000
N  #define GUI_DARKMAGENTA   0x00800080
N  #define GUI_DARKYELLOW    0x00008080
N  #define GUI_WHITE         0x00FFFFFF
N  #define GUI_LIGHTGRAY     0x00D3D3D3
N  #define GUI_GRAY          0x00808080
N  #define GUI_DARKGRAY      0x00404040
N  #define GUI_BLACK         0x00000000
N  #define GUI_BROWN         0x002A2AA5
N  #define GUI_ORANGE        0x0000A5FF
N  #define GUI_TRANSPARENT   0xFF000000
N
N  #define GUI_GRAY_3F       0x003F3F3F
N  #define GUI_GRAY_50       0x00505050
N  #define GUI_GRAY_55       0x00555555
N  #define GUI_GRAY_60       0x00606060
N  #define GUI_GRAY_7C       0x007C7C7C
N  #define GUI_GRAY_9A       0x009A9A9A
N  #define GUI_GRAY_AA       0x00AAAAAA
N  #define GUI_GRAY_C0       0x00C0C0C0
N  #define GUI_GRAY_C8       0x00C8C8C8
N  #define GUI_GRAY_D0       0x00D0D0D0
N  #define GUI_GRAY_E7       0x00E7E7E7
N  #define GUI_BLUE_98       0x00980000
N#endif
N
N#define GUI_INVALID_COLOR 0xFFFFFFF      /* Invalid color - more than 24 bits */
N
N#if (GUI_USE_ARGB)
S  #define GUI_MAKE_COLOR(ABGR)  (((((U32)ABGR) & 0xFF000000ul) ^ 0xFF000000ul) | ((((U32)ABGR) & 0x00FF0000ul) >> 16) | (((U32)ABGR) & 0x0000FF00ul) | ((((U32)ABGR) & 0x000000FFul) << 16))
S  #define GUI_MAKE_TRANS(Alpha) (255 - (Alpha))
N#else
N  #define GUI_MAKE_COLOR(ABGR)  (ABGR)
N  #define GUI_MAKE_TRANS(Alpha) (Alpha)
N#endif
N
N#if (GUI_USE_ARGB)
S  #define GUI_TRANS_BYTE 0x00
N#else
N  #define GUI_TRANS_BYTE 0xFF
N#endif
N
N
N/*********************************************************************
N*
N*       MultiTouch-Support
N*/
N//
N// Defines
N//
N#define GUI_MTOUCH_FLAG_DOWN (1 << 0)
N#define GUI_MTOUCH_FLAG_MOVE (1 << 1)
N#define GUI_MTOUCH_FLAG_UP   (1 << 2)
N
N//
N// Variables
N//
Nextern T_GUI_MTOUCH_STOREEVENT GUI_MTOUCH__pStoreEvent;
N
N//
N// Interface
N//
Nvoid GUI_MTOUCH_Enable          (int OnOff);
Nint  GUI_MTOUCH_GetEvent        (GUI_MTOUCH_EVENT * pEvent);
Nint  GUI_MTOUCH_GetTouchInput   (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pBuffer, unsigned Index);
Nint  GUI_MTOUCH_IsEmpty         (void);
Nvoid GUI_MTOUCH_SetOrientation  (int Orientation);
Nvoid GUI_MTOUCH_SetOrientationEx(int Orientation, int LayerIndex);
Nvoid GUI_MTOUCH_StoreEvent      (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Coordinates used in touch driver
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*       Addresses of standard fonts
N*/
N//
N// Proportional fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Xextern const GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Xextern const GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N//
N// Proportional fonts, framed
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20F_ASCII;
Xextern const GUI_FONT GUI_Font20F_ASCII;
N
N//
N// Monospaced
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Xextern const GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Xextern const GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
Xextern const GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
N
N//
N// Digits
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N//
N// Comic fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N/*********************************************************************
N*
N*       Macros to be used
N*/
N//
N// Proportional fonts
N//
N#define GUI_FONT_8_ASCII        &GUI_Font8_ASCII
N#define GUI_FONT_8_1            &GUI_Font8_1
N#define GUI_FONT_10S_ASCII      &GUI_Font10S_ASCII
N#define GUI_FONT_10S_1          &GUI_Font10S_1
N#define GUI_FONT_10_ASCII       &GUI_Font10_ASCII
N#define GUI_FONT_10_1           &GUI_Font10_1
N#define GUI_FONT_13_ASCII       &GUI_Font13_ASCII
N#define GUI_FONT_13_1           &GUI_Font13_1
N#define GUI_FONT_13B_ASCII      &GUI_Font13B_ASCII
N#define GUI_FONT_13B_1          &GUI_Font13B_1
N#define GUI_FONT_13H_ASCII      &GUI_Font13H_ASCII
N#define GUI_FONT_13H_1          &GUI_Font13H_1
N#define GUI_FONT_13HB_ASCII     &GUI_Font13HB_ASCII
N#define GUI_FONT_13HB_1         &GUI_Font13HB_1
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16B_ASCII      &GUI_Font16B_ASCII
N#define GUI_FONT_16B_1          &GUI_Font16B_1
N#define GUI_FONT_20_ASCII       &GUI_Font20_ASCII
N#define GUI_FONT_20_1           &GUI_Font20_1
N#define GUI_FONT_20B_ASCII      &GUI_Font20B_ASCII
N#define GUI_FONT_20B_1          &GUI_Font20B_1
N#define GUI_FONT_24_ASCII       &GUI_Font24_ASCII
N#define GUI_FONT_24_1           &GUI_Font24_1
N#define GUI_FONT_24B_ASCII      &GUI_Font24B_ASCII
N#define GUI_FONT_24B_1          &GUI_Font24B_1
N#define GUI_FONT_32_ASCII       &GUI_Font32_ASCII
N#define GUI_FONT_32_1           &GUI_Font32_1
N#define GUI_FONT_32B_ASCII      &GUI_Font32B_ASCII
N#define GUI_FONT_32B_1          &GUI_Font32B_1
N
N//
N// Proportional fonts, framed
N//
N#define GUI_FONT_20F_ASCII      &GUI_Font20F_ASCII
N
N//
N// Monospaced
N//
N#define GUI_FONT_4X6            &GUI_Font4x6
N#define GUI_FONT_6X8            &GUI_Font6x8
N#define GUI_FONT_6X8_ASCII      &GUI_Font6x8_ASCII
N#define GUI_FONT_6X8_1          &GUI_Font6x8_1
N#define GUI_FONT_6X9            &GUI_Font6x9
N#define GUI_FONT_8X8            &GUI_Font8x8
N#define GUI_FONT_8X8_ASCII      &GUI_Font8x8_ASCII
N#define GUI_FONT_8X8_1          &GUI_Font8x8_1
N#define GUI_FONT_8X9            &GUI_Font8x9
N#define GUI_FONT_8X10_ASCII     &GUI_Font8x10_ASCII
N#define GUI_FONT_8X12_ASCII     &GUI_Font8x12_ASCII
N#define GUI_FONT_8X13_ASCII     &GUI_Font8x13_ASCII
N#define GUI_FONT_8X13_1         &GUI_Font8x13_1
N#define GUI_FONT_8X15B_ASCII    &GUI_Font8x15B_ASCII
N#define GUI_FONT_8X15B_1        &GUI_Font8x15B_1
N#define GUI_FONT_8X16           &GUI_Font8x16
N#define GUI_FONT_8X17           &GUI_Font8x17
N#define GUI_FONT_8X18           &GUI_Font8x18
N#define GUI_FONT_8X16X1X2       &GUI_Font8x16x1x2
N#define GUI_FONT_8X16X2X2       &GUI_Font8x16x2x2
N#define GUI_FONT_8X16X3X3       &GUI_Font8x16x3x3
N#define GUI_FONT_8X16_ASCII     &GUI_Font8x16_ASCII
N#define GUI_FONT_8X16_1         &GUI_Font8x16_1
N
N//
N// Digits
N//
N#define GUI_FONT_D24X32         &GUI_FontD24x32
N#define GUI_FONT_D32            &GUI_FontD32
N#define GUI_FONT_D36X48         &GUI_FontD36x48
N#define GUI_FONT_D48            &GUI_FontD48
N#define GUI_FONT_D48X64         &GUI_FontD48x64
N#define GUI_FONT_D64            &GUI_FontD64
N#define GUI_FONT_D60X80         &GUI_FontD60x80
N#define GUI_FONT_D80            &GUI_FontD80
N
N//
N// Comic fonts
N//
N#define GUI_FONT_COMIC18B_ASCII &GUI_FontComic18B_ASCII
N#define GUI_FONT_COMIC18B_1     &GUI_FontComic18B_1
N#define GUI_FONT_COMIC24B_ASCII &GUI_FontComic24B_ASCII
N#define GUI_FONT_COMIC24B_1     &GUI_FontComic24B_1
N
N/*********************************************************************
N*
N*       Text and drawing modes
N*
N* These defines come in two flavors: the long version (.._DRAWMODE_..)
N* and the short ones (.._DM_..). They are identical, feel free to use
N* which ever one you like best.
N*/
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_HORIZONTAL  (3<<0)
N#define GUI_TA_LEFT        (0<<0)
N#define GUI_TA_RIGHT	     (1<<0)
N#define GUI_TA_CENTER	     (2<<0)
N#define GUI_TA_HCENTER	   GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_VERTICAL   (3<<2)
N#define GUI_TA_TOP	      (0<<2)
N#define GUI_TA_BOTTOM	    (1<<2)
N#define GUI_TA_BASELINE   (2<<2)
N#define GUI_TA_VCENTER    (3<<2)
N
N/* General orientation flags */
N#define GUI_MIRROR_X (1 << 0)
N#define GUI_MIRROR_Y (1 << 1)
N#define GUI_SWAP_XY  (1 << 2)
N
N/*********************************************************************
N*
N*       Min/Max coordinates
N*
N* Define minimum and maximum coordinates in x and y
N*/
N#if 1
N  #define GUI_XMIN -16383
N  #define GUI_XMAX  16383
N  #define GUI_YMIN -16383
N  #define GUI_YMAX  16383
N#else
S  #define GUI_XMIN -4095
S  #define GUI_XMAX  4095
S  #define GUI_YMIN -4095
S  #define GUI_YMAX  4095
N#endif
N
N/*********************************************************************
N*
N*       Defines for constants
N*/
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/*********************************************************************
N*
N*       Compatibility with older versions
N*/
N#define GUI_DispString_UC      GUI_UC_DispString
N#define TOUCH_X_ActivateX      GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY      GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable        GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX       GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY       GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer           GUI_SelectLayer
N#define GUI_MEMDEV_FadeDevices GUI_MEMDEV_FadeInDevices
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
L 20 "..\User\emWinTask\MainTask.h" 2
N#include "DIALOG.h"
L 1 "..\STemWin\inc\DIALOG.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef DIALOG_H
N#define DIALOG_H
N
N#include "WM.h"
L 1 "..\STemWin\inc\WM.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : WM.h
NPurpose     : Windows manager include
N----------------------------------------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef WM_H            /* Make sure we only include it once */
N#define WM_H
N
N
N#include "GUI_ConfDefaults.h"
N#include "GUI_Type.h"      /* Needed because of typedefs only */
N#include "WM_GUI.h"       /* Some functions needed by GUI routines */
L 1 "..\STemWin\inc\WM_GUI.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)       (x += GUI_pContext->xOff)
N#define WM_ADDORGY(y)       (y += GUI_pContext->yOff)
N#define WM_ADDORG(x0,y0)    WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    (x += WM__GetOrgX_AA())
N#define WM_ADDORGY_AA(y)    (y += WM__GetOrgY_AA())
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)       (x -= GUI_pContext->xOff)
N#define WM_SUBORGY(y)       (y -= GUI_pContext->yOff)
N#define WM_SUBORG(x0,y0)    WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 61 "..\STemWin\inc\WM.h" 2
N#include "GUI.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* Static memory devices */
N#ifndef   WM_SUPPORT_STATIC_MEMDEV
N  #define WM_SUPPORT_STATIC_MEMDEV GUI_SUPPORT_MEMDEV
N#endif
N
N/* Support for transparency. Switching it off makes Wm smaller and faster */
N#ifndef   WM_SUPPORT_TRANSPARENCY
N  #define WM_SUPPORT_TRANSPARENCY 1 /* Should be defined outside of GUI_WINSUPPORT because of '#if GUI_WINSUPPORT && WM_SUPPORT_TRANSPARENCY' in some files */
N#endif
N
N/* This is for tests only. It will fill the invalid area of a window.
N   Can be used for debugging. */
N#ifndef WM_SUPPORT_DIAG
N  #ifdef WIN32   /* In simulation */
S    #define WM_SUPPORT_DIAG GUI_WINSUPPORT
N  #else
N    #define WM_SUPPORT_DIAG 0
N  #endif
N#endif
N
N/* Make sure we actually have configured windows. If we have not,
N  there is no point for a windows manager and it will therefor not
N  generate any code !
N*/
N
N#if GUI_WINSUPPORT
X#if (1)
N
N/*********************************************************************
N*
N*       Config defaults
N*/
N#ifndef   WM_ASSERT
N  #define WM_ASSERT(expr) GUI_DEBUG_ASSERT(expr)
N#endif
N
N#ifndef   WM_SUPPORT_TOUCH
N  #define WM_SUPPORT_TOUCH        GUI_SUPPORT_TOUCH
N#endif
N
N/* Allow older API calls */
N#ifndef   WM_COMPATIBLE_MODE
N  #define WM_COMPATIBLE_MODE 1
N#endif
N
N/* Send a message if visibility of a window has changed */
N#ifndef   WM_SUPPORT_NOTIFY_VIS_CHANGED
N  #define WM_SUPPORT_NOTIFY_VIS_CHANGED 0
N#endif
N
N#ifndef   WM_SUPPORT_CPP
N  #if defined (_MSC_VER)
X  #if 0L
S    #define WM_SUPPORT_CPP 1
N  #else
N    #define WM_SUPPORT_CPP 0
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       Locking macros
N*/
N#define WM_LOCK()   GUI_LOCK()
N#define WM_UNLOCK() GUI_UNLOCK()
N
N#define WM_LOCK_H(hWin) (WM_Obj *)GUI_LOCK_H(hWin)
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct WM_WINDOW_INFO WM_WINDOW_INFO;
N
Nstruct WM_WINDOW_INFO {
N  GUI_HMEM hWin;
X  signed long hWin;
N  GUI_HMEM hParent;
X  signed long hParent;
N  GUI_HMEM hFirstChild;
X  signed long hFirstChild;
N  GUI_HMEM hNext;
X  signed long hNext;
N  GUI_RECT Rect;
N  U32      Status;
X  unsigned long      Status;
N  U32      DebugId;
X  unsigned long      DebugId;
N  WM_WINDOW_INFO * pNext;
N};
N
Ntypedef struct {
N  int Key, PressedCnt;
N} WM_KEY_INFO;
N
Ntypedef struct {
N  int NumItems, v, PageSize;
N} WM_SCROLL_STATE;
N
Ntypedef struct {
N  int Done;
N  int ReturnValue;
N} WM_DIALOG_STATUS;
N
Ntypedef struct {
N  int x,y;
N  U8  State;
X  unsigned char  State;
N  U8  StatePrev;
X  unsigned char  StatePrev;
N} WM_PID_STATE_CHANGED_INFO;
N
Ntypedef struct {
N  int Cmd;
N  int dx, dy, da;
N  int xPos, yPos;
N  int Period;
N  int SnapX;
N  int SnapY;
N  int FinalMove;
N  U32 Flags;
X  unsigned long Flags;
N  GUI_PID_STATE * pState;
N  GUI_HMEM hContext;
X  signed long hContext;
N} WM_MOTION_INFO;
N
Ntypedef struct {
N  I32       FactorMin;   // Minimum factor to be used (<< 16)
X  signed long       FactorMin;   
N  I32       FactorMax;   // Maximum factor to be used (<< 16)
X  signed long       FactorMax;   
N  U32       xSize;       // Native xSize of window to be zoomed in pixels
X  unsigned long       xSize;       
N  U32       ySize;       // Native ySize of window to be zoomed in pixels
X  unsigned long       ySize;       
N  U32       xSizeParent; // xSize of parent window
X  unsigned long       xSizeParent; 
N  U32       ySizeParent; // ySize of parent window
X  unsigned long       ySizeParent; 
N  I32       Factor0;     // Primary factor when starting zoom gesture (<< 16)
X  signed long       Factor0;     
N  int       xPos0;       // Primary window position in x when starting the gesture
N  int       yPos0;       // Primary window position in y when starting the gesture
N  GUI_POINT Center0;     // Primary center point when starting the gesture
N} WM_ZOOM_INFO;
N
Ntypedef struct {
N  int            Flags;     // Information regarding gesture type
N  GUI_POINT      Point;     // Relative movement
N  GUI_POINT      Center;    // Center point for zooming
N  I32            Angle;     // Angle between the touch points
X  signed long            Angle;     
N  I32            Factor;    // Current zoom factor
X  signed long            Factor;    
N  WM_ZOOM_INFO * pZoomInfo; // Pointer to WM_ZOOM_INFO structure
N} WM_GESTURE_INFO;
N
Ntypedef struct {
N  int dx, dy;
N} WM_MOVE_INFO;
N
N/*********************************************************************
N*
N*       Gesture flags for multi touch support
N*/
N#define WM_GF_BEGIN  (1 << 0)
N#define WM_GF_END    (1 << 1)
N#define WM_GF_PAN    (1 << 2)
N#define WM_GF_ZOOM   (1 << 3)
N#define WM_GF_ROTATE (1 << 4)
N
N/*********************************************************************
N*
N*       Messages Ids
N*
N* The following is the list of windows messages.
N*/
N#define WM_CREATE                   0x0001  /* The first message received, right after client has actually been created */
N#define WM_MOVE                     0x0003  /* window has been moved (Same as WIN32) */
N
N#define WM_SIZE                     0x0005  /* Is sent to a window after its size has changed (Same as WIN32, do not change !) */
N
N#define WM_DELETE                   11      /* Delete (Destroy) command: This tells the client to free its data strutures since the window
N                                               it is associates with no longer exists.*/
N#define WM_TOUCH                    0x0240  /* Touch screen message */
N#define WM_TOUCH_CHILD              13      /* Touch screen message to ancestors */
N#define WM_KEY                      14      /* Key has been pressed */
N
N#define WM_PAINT                    0x000F  /* Repaint window (because content is (partially) invalid */
N
N#if GUI_SUPPORT_MOUSE
X#if (1)
N#define WM_MOUSEOVER                16      /* Mouse has moved, no key pressed */
N#define WM_MOUSEOVER_END            18      /* Mouse has moved, no key pressed */
N#endif
N
N#define WM_PID_STATE_CHANGED        17      /* Pointer input device state has changed */
N
N#define WM_GET_INSIDE_RECT          20      /* get inside rectangle: client rectangle minus pixels lost to effect */
N#define WM_GET_ID                   21      /* Get id of widget */
N#define WM_SET_ID                   22      /* Set id of widget */
N#define WM_GET_CLIENT_WINDOW        23      /* Get window handle of client window. Default is the same as window */
N#define WM_CAPTURE_RELEASED         24      /* Let window know that mouse capture is over */
N
N#define WM_INIT_DIALOG              29      /* Inform dialog that it is ready for init */
N
N#define WM_SET_FOCUS                30      /* Inform window that it has gotten or lost the focus */
N#define WM_GET_ACCEPT_FOCUS         31      /* Find out if window can accept the focus */
N#define WM_NOTIFY_CHILD_HAS_FOCUS   32      /* Sent to parent when child receives / loses focus */
N
N#define WM_NOTIFY_OWNER_KEY         33      /* Some widgets (e.g. listbox) notify owner when receiving key messages */
N
N#define WM_GET_BKCOLOR              34      /* Return back ground color (only frame window and similar) */
N#define WM_GET_SCROLL_STATE         35      /* Query state of scroll bar */
N
N#define WM_SET_SCROLL_STATE         36      /* Set scroll info ... only effective for scrollbars */
N
N#define WM_NOTIFY_CLIENTCHANGE      37      /* Client area may have changed */
N#define WM_NOTIFY_PARENT            38      /* Notify parent. Information is detailed as notification code */
N#define WM_NOTIFY_PARENT_REFLECTION 39      /* Notify parent reflection. 
N                                               Sometimes send back as a result of the WM_NOTIFY_PARENT message
N                                               to let child react on behalf of its parent.
N                                               Information is detailed as notification code */
N#define WM_NOTIFY_ENABLE            40      /* Enable or disable widget */
N#define WM_NOTIFY_VIS_CHANGED       41      /* Visibility of a window has or may have changed */
N
N#define WM_HANDLE_DIALOG_STATUS     42      /* Set or get dialog status */
N#define WM_GET_RADIOGROUP           43      /* Send to all siblings and children of a radio control when
N                                               selection changed */
N#define WM_MENU                     44      /* Send to owner window of menu widget */
N#define WM_SCREENSIZE_CHANGED       45      /* Send to all windows when size of screen has changed */
N#define WM_PRE_PAINT                46      /* Send to a window before it receives a WM_PAINT message */
N#define WM_POST_PAINT               47      /* Send to a window after (the last) WM_PAINT message */
N
N#define WM_MOTION                   48      /* Automatic motion messages */
N
N#define WM_GET_WINDOW_ID            49      /* Return widget type specific Id (DebugId) */
N
N#define WM_PRE_BANDING              50
N#define WM_POST_BANDING             51
N
N#define WM_GESTURE                  0x0119  /* Gesture message */
N
N#define WM_TIMER                    0x0113  /* Timer has expired              (Keep the same as WIN32) */
N#define WM_WIDGET                   0x0300  /* 256 messages reserved for Widget messages */
N#define WM_USER                     0x0400  /* Reserved for user messages ... (Keep the same as WIN32) */
N
N/*********************************************************************
N*
N*       Motion messages
N*/
N#define WM_MOTION_INIT    0
N#define WM_MOTION_MOVE    1
N#define WM_MOTION_GETPOS  2
N#define WM_MOTION_GETCONTEXT 3
N
N/*********************************************************************
N*
N*       Motion flags
N*/
N#define WM_MOTION_MANAGE_BY_WINDOW   (1 << 0) // Window movement is managed by window itself
N
N/*********************************************************************
N*
N*       Notification codes
N*
N* The following is the list of notification codes send
N* with the WM_NOTIFY_PARENT message
N*/
N#define WM_NOTIFICATION_CLICKED             1
N#define WM_NOTIFICATION_RELEASED            2
N#define WM_NOTIFICATION_MOVED_OUT           3
N#define WM_NOTIFICATION_SEL_CHANGED         4
N#define WM_NOTIFICATION_VALUE_CHANGED       5
N#define WM_NOTIFICATION_SCROLLBAR_ADDED     6      /* Scroller added */
N#define WM_NOTIFICATION_CHILD_DELETED       7      /* Inform window that child is about to be deleted */
N#define WM_NOTIFICATION_GOT_FOCUS           8
N#define WM_NOTIFICATION_LOST_FOCUS          9
N#define WM_NOTIFICATION_SCROLL_CHANGED     10
N
N#define WM_NOTIFICATION_WIDGET             11      /* Space for widget defined notifications */
N#define WM_NOTIFICATION_USER               16      /* Space for  application (user) defined notifications */
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#define WM_HWIN        GUI_HWIN
N#define WM_HWIN_NULL   GUI_HMEM_NULL
N#define WM_HMEM        GUI_HMEM
N#define WM_HMEM_NULL   GUI_HMEM_NULL
N#define WM_HTIMER      GUI_HMEM
N
N/*********************************************************************
N*
N*       Window defines
N*/
N#define WM_HBKWIN      WM_GetDesktopWindow()                /* Handle of background window */
N#define WM_UNATTACHED  ((WM_HMEM) - 1)                      /* Do not attach to a window */
N
N/*********************************************************************
N*
N*       Window create flags.
N*
N* These flags can be passed to the create window
N* function as flag-parameter. The flags are combinable using the
N* binary or operator.
N*/
N#define WM_CF_HASTRANS         (1UL << 0)  /* Has transparency. Needs to be defined for windows which do not fill the entire
N                                          section of their (client) rectangle. */
N#define WM_CF_HIDE             (0UL << 1)  /* Hide window after creation (default !) */
N#define WM_CF_SHOW             (1UL << 1)  /* Show window after creation */
N#define WM_CF_MEMDEV           (1UL << 2)  /* Use memory device for redraws */
N#define WM_CF_STAYONTOP        (1UL << 3)  /* Stay on top */
N#define WM_CF_DISABLED         (1UL << 4)  /* Disabled: Does not receive PID (mouse & touch) input */
N
N/* Create only flags ... Not available as status flags */
N#define WM_CF_ACTIVATE         (1UL << 5)  /* If automatic activation upon creation of window is desired */
N#define WM_CF_FGND             (0UL << 6)  /* Put window in foreground after creation (default !) */
N#define WM_CF_BGND             (1UL << 6)  /* Put window in background after creation */
N
N/* Anchor flags */
N#define WM_CF_ANCHOR_RIGHT     (1UL << 7)  /* Right anchor ...  If parent is resized, distance to right  will remain const (left is default) */
N#define WM_CF_ANCHOR_BOTTOM    (1UL << 8)  /* Bottom anchor ... If parent is resized, distance to bottom will remain const (top  is default) */
N#define WM_CF_ANCHOR_LEFT      (1UL << 9)  /* Left anchor ...   If parent is resized, distance to left   will remain const (left is default) */
N#define WM_CF_ANCHOR_TOP       (1UL << 10) /* Top anchor ...    If parent is resized, distance to top    will remain const (top  is default) */
N
N#define WM_CF_CONST_OUTLINE    (1UL << 11) /* Constant outline. This is relevant for transparent windows only. If a window is transparent
N                                              and does not have a constant outline, its background is invalided instead of the window itself.
N                                              This causes add. computation time when redrawing. */
N#define WM_CF_LATE_CLIP        (1UL << 12)
N#define WM_CF_MEMDEV_ON_REDRAW (1UL << 13)
N
N#define WM_SF_INVALID_DRAW     (1UL << 14)
N#define WM_SF_DELETE           (1UL << 15) /* Marks the window to be deleted within WM_Exec() when no callback routine is executed */
N
N#define WM_CF_STATIC           (1UL << 16) /* Use static memory device for redraws */
N
N#define WM_CF_MOTION_X         (1UL << 17) /* Window can be moved automatically in X axis */
N#define WM_CF_MOTION_Y         (1UL << 18) /* Window can be moved automatically in Y axis */
N
N#define WM_CF_GESTURE          (1UL << 19) /* Marks the window to be a able to receive gesture messages */
N
N#define WM_CF_ZOOM             (1UL << 20) /* Window can be scaled automatically by multi touch gesture input */
N
N#define WM_CF_MOTION_R         (1UL << 21) // Window can be rotated
N
N/*********************************************************************
N*
N*       Window manager types
N*/
Ntypedef struct WM_Obj     WM_Obj;
Ntypedef struct WM_MESSAGE WM_MESSAGE;
N
Ntypedef void WM_CALLBACK( WM_MESSAGE * pMsg);
N
Nstruct WM_MESSAGE {
N  int MsgId;            /* type of message */
N  WM_HWIN hWin;         /* Destination window */
X  GUI_HWIN hWin;          
N  WM_HWIN hWinSrc;      /* Source window  */
X  GUI_HWIN hWinSrc;       
N  union {
N    const void * p;            /* Some messages need more info ... Pointer is declared "const" because some systems (M16C) have 4 byte const, byte 2 byte default ptrs */
N    int v;
N    GUI_COLOR Color;
N  } Data;
N};
N
Nstruct WM_Obj {
N  GUI_RECT Rect;        /* Outer dimensions of window */
N  GUI_RECT InvalidRect; /* Invalid rectangle */
N  WM_CALLBACK* cb;      /* Ptr to notification callback */
N  WM_HWIN hNextLin;     /* Next window in linear list */
X  GUI_HWIN hNextLin;      
N  WM_HWIN hParent;
X  GUI_HWIN hParent;
N  WM_HWIN hFirstChild;
X  GUI_HWIN hFirstChild;
N  WM_HWIN hNext;
X  GUI_HWIN hNext;
N  #if WM_SUPPORT_STATIC_MEMDEV
X  #if (1)
N    GUI_MEMDEV_Handle hMem; /* Static memory device */
N  #endif
N  U32 Status;           /* Status flags */
X  unsigned long Status;            
N  #if WM_SUPPORT_CPP
X  #if 0
S    void * ObjPtr;
N  #endif
N};
N
Ntypedef void WM_tfPollPID(void);
Ntypedef void WM_tfForEach(WM_HWIN hWin, void * pData);
Xtypedef void WM_tfForEach(GUI_HWIN hWin, void * pData);
N
Ntypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xtypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Ntypedef void (* WM_tfInvalidateDrawFunc)(WM_HWIN hWin);
Xtypedef void (* WM_tfInvalidateDrawFunc)(GUI_HWIN hWin);
Ntypedef void (* WM_tfPaint1Func)        (WM_HWIN hWin);
Xtypedef void (* WM_tfPaint1Func)        (GUI_HWIN hWin);
N
Ntypedef struct {
N  WM_HMEM  hTimer;
X  signed long  hTimer;
N  WM_HWIN  hWin;
X  GUI_HWIN  hWin;
N  int      UserId;
N} WM_TIMER_OBJ;
N
N/*********************************************************************
N*
N*       General control routines
N*/
Nvoid WM_Activate  (void);
Nvoid WM_Deactivate(void);
Nvoid WM_Init      (void);
Nint  WM_Exec      (void);    /* Execute all jobs ... Return 0 if nothing was done. */
NU32  WM_SetCreateFlags(U32 Flags);
Xunsigned long  WM_SetCreateFlags(unsigned long Flags);
NWM_tfPollPID * WM_SetpfPollPID(WM_tfPollPID * pf);
N
N/*********************************************************************
N*
N*       Window manager interface
N*/
Nvoid    WM_AttachWindow              (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM_AttachWindow              (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM_AttachWindowAt            (WM_HWIN hWin, WM_HWIN hParent, int x, int y);
Xvoid    WM_AttachWindowAt            (GUI_HWIN hWin, GUI_HWIN hParent, int x, int y);
Nint     WM_CheckScrollPos            (WM_SCROLL_STATE * pScrollState, int Pos, int LowerDist, int UpperDist); /* not to be documented (may change in future version) */
Nvoid    WM_ClrHasTrans               (WM_HWIN hWin);
Xvoid    WM_ClrHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, U32 Style, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, unsigned long Style, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, WM_HWIN hWinParent, U32 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, GUI_HWIN hWinParent, unsigned long Style, WM_CALLBACK* cb, int NumExtraBytes);
Nvoid    WM_DeleteWindow              (WM_HWIN hWin);
Xvoid    WM_DeleteWindow              (GUI_HWIN hWin);
Nvoid    WM_DetachWindow              (WM_HWIN hWin);
Xvoid    WM_DetachWindow              (GUI_HWIN hWin);
Nvoid    WM_EnableGestures            (WM_HWIN hWin, int OnOff);
Xvoid    WM_EnableGestures            (GUI_HWIN hWin, int OnOff);
Nint     WM_GetHasTrans               (WM_HWIN hWin);
Xint     WM_GetHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_GetFocussedWindow         (void);
XGUI_HWIN WM_GetFocussedWindow         (void);
Nint     WM_GetInvalidRect            (WM_HWIN hWin, GUI_RECT * pRect);
Xint     WM_GetInvalidRect            (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM_GetStayOnTop              (WM_HWIN hWin);
Xint     WM_GetStayOnTop              (GUI_HWIN hWin);
Nvoid    WM_HideWindow                (WM_HWIN hWin);
Xvoid    WM_HideWindow                (GUI_HWIN hWin);
Nvoid    WM_InvalidateArea            (const GUI_RECT * pRect);
Nvoid    WM_InvalidateRect            (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_InvalidateRect            (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_InvalidateWindow          (WM_HWIN hWin);
Xvoid    WM_InvalidateWindow          (GUI_HWIN hWin);
Nvoid    WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect, U16 Flags);
Xvoid    WM_InvalidateWindowAndDescsEx(GUI_HWIN hWin, const GUI_RECT * pInvalidRect, unsigned short Flags);
Nvoid    WM_InvalidateWindowAndDescs  (WM_HWIN hWin);    /* not to be documented (may change in future version) */
Xvoid    WM_InvalidateWindowAndDescs  (GUI_HWIN hWin);     
Nint     WM_IsEnabled                 (WM_HWIN hObj);
Xint     WM_IsEnabled                 (GUI_HWIN hObj);
Nchar    WM_IsCompletelyCovered       (WM_HWIN hWin);    /* Checks if the window is completely covered by other windows */
Xchar    WM_IsCompletelyCovered       (GUI_HWIN hWin);     
Nchar    WM_IsCompletelyVisible       (WM_HWIN hWin);    /* Is the window completely visible ? */
Xchar    WM_IsCompletelyVisible       (GUI_HWIN hWin);     
Nint     WM_IsFocussable              (WM_HWIN hWin);
Xint     WM_IsFocussable              (GUI_HWIN hWin);
Nint     WM_IsVisible                 (WM_HWIN hWin);
Xint     WM_IsVisible                 (GUI_HWIN hWin);
Nint     WM_IsWindow                  (WM_HWIN hWin);    /* Check validity */
Xint     WM_IsWindow                  (GUI_HWIN hWin);     
Nvoid    WM_SetAnchor                 (WM_HWIN hWin, U16 AnchorFlags);
Xvoid    WM_SetAnchor                 (GUI_HWIN hWin, unsigned short AnchorFlags);
Nvoid    WM_SetHasTrans               (WM_HWIN hWin);
Xvoid    WM_SetHasTrans               (GUI_HWIN hWin);
Nvoid    WM_SetId                     (WM_HWIN hObj, int Id);
Xvoid    WM_SetId                     (GUI_HWIN hObj, int Id);
Nvoid    WM_SetStayOnTop              (WM_HWIN hWin, int OnOff);
Xvoid    WM_SetStayOnTop              (GUI_HWIN hWin, int OnOff);
Nvoid    WM_SetTransState             (WM_HWIN hWin, unsigned State);
Xvoid    WM_SetTransState             (GUI_HWIN hWin, unsigned State);
Nvoid    WM_ShowWindow                (WM_HWIN hWin);
Xvoid    WM_ShowWindow                (GUI_HWIN hWin);
Nvoid    WM_ValidateRect              (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_ValidateRect              (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_ValidateWindow            (WM_HWIN hWin);
Xvoid    WM_ValidateWindow            (GUI_HWIN hWin);
N
N/* Gesture support */
Nvoid WM_GESTURE_Enable  (int OnOff);
Nint  WM_GESTURE_EnableEx(int OnOff, int MaxFactor);
Nvoid WM_GESTURE_Exec    (void);
NI32  WM_GESTURE_SetThresholdAngle(I32 ThresholdAngle);
Xsigned long  WM_GESTURE_SetThresholdAngle(signed long ThresholdAngle);
NI32  WM_GESTURE_SetThresholdDist (I32 ThresholdDist);
Xsigned long  WM_GESTURE_SetThresholdDist (signed long ThresholdDist);
N
N/* Motion support */
Nvoid     WM_MOTION_Enable          (int OnOff);
Nvoid     WM_MOTION_SetMovement     (WM_HWIN hWin, int Axis, I32 Velocity, I32 Dist);
Xvoid     WM_MOTION_SetMovement     (GUI_HWIN hWin, int Axis, signed long Velocity, signed long Dist);
Nvoid     WM_MOTION_SetMotion       (WM_HWIN hWin, int Axis, I32 Velocity, I32 Deceleration);
Xvoid     WM_MOTION_SetMotion       (GUI_HWIN hWin, int Axis, signed long Velocity, signed long Deceleration);
Nvoid     WM_MOTION_SetMoveable     (WM_HWIN hWin, U32 Flags, int OnOff);
Xvoid     WM_MOTION_SetMoveable     (GUI_HWIN hWin, unsigned long Flags, int OnOff);
Nvoid     WM_MOTION_SetDeceleration (WM_HWIN hWin, int Axis, I32 Deceleration);
Xvoid     WM_MOTION_SetDeceleration (GUI_HWIN hWin, int Axis, signed long Deceleration);
Nunsigned WM_MOTION_SetDefaultPeriod(unsigned Period);
Nvoid     WM_MOTION_SetSpeed        (WM_HWIN hWin, int Axis, I32 Velocity);
Xvoid     WM_MOTION_SetSpeed        (GUI_HWIN hWin, int Axis, signed long Velocity);
N
N/* Motion support, private interface */
NWM_HMEM WM_MOTION__CreateContext(void);
Xsigned long WM_MOTION__CreateContext(void);
Nvoid    WM_MOTION__DeleteContext(WM_HMEM hContext);
Xvoid    WM_MOTION__DeleteContext(signed long hContext);
N
N/* Motion support, private function(s) */
Nvoid     WM__SetMotionCallback (void(* cbMotion) (GUI_PID_STATE * pState, void * p));
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if ((1))
N  #define GUI_MEMDEV_EDGE_LEFT   0
N  #define GUI_MEMDEV_EDGE_RIGHT  1
N  #define GUI_MEMDEV_EDGE_TOP    2
N  #define GUI_MEMDEV_EDGE_BOTTOM 3
N
N  int               GUI_MEMDEV_BlendWinBk       (WM_HWIN hWin, int Period, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlendWinBk       (GUI_HWIN hWin, int Period, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurAndBlendWinBk(WM_HWIN hWin, int Period, U8 BlurDepth, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlurAndBlendWinBk(GUI_HWIN hWin, int Period, unsigned char BlurDepth, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurWinBk        (WM_HWIN hWin, int Period, U8 BlurDepth);
X  int               GUI_MEMDEV_BlurWinBk        (GUI_HWIN hWin, int Period, unsigned char BlurDepth);
N  void              GUI_MEMDEV_CreateStatic     (WM_HWIN hWin);
X  void              GUI_MEMDEV_CreateStatic     (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(GUI_HWIN hWin);
N  int               GUI_MEMDEV_FadeInWindow     (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeInWindow     (GUI_HWIN hWin, int Period);
N  int               GUI_MEMDEV_FadeOutWindow    (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeOutWindow    (GUI_HWIN hWin, int Period);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (GUI_HWIN hWin);
N  int               GUI_MEMDEV_MoveInWindow     (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveInWindow     (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  int               GUI_MEMDEV_MoveOutWindow    (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveOutWindow    (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  void              GUI_MEMDEV_Paint1Static     (WM_HWIN hWin);                                     /* not to be documented */
X  void              GUI_MEMDEV_Paint1Static     (GUI_HWIN hWin);                                      
N  int               GUI_MEMDEV_ShiftInWindow    (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftInWindow    (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_ShiftOutWindow   (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftOutWindow   (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_SwapWindow       (WM_HWIN hWin, int Period, int Edge);
X  int               GUI_MEMDEV_SwapWindow       (GUI_HWIN hWin, int Period, int Edge);
N
N  void              GUI_MEMDEV__CreateStatic    (WM_HWIN hWin);
X  void              GUI_MEMDEV__CreateStatic    (GUI_HWIN hWin);
N#endif
N
N/* Move/resize windows */
Nvoid WM_MoveWindow                (WM_HWIN hWin, int dx, int dy);
Xvoid WM_MoveWindow                (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_ResizeWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid WM_ResizeWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_MoveTo                    (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveTo                    (GUI_HWIN hWin, int x, int y);
Nvoid WM_MoveChildTo               (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveChildTo               (GUI_HWIN hWin, int x, int y);
Nvoid WM_SetSize                   (WM_HWIN hWin, int XSize, int YSize);
Xvoid WM_SetSize                   (GUI_HWIN hWin, int XSize, int YSize);
Nvoid WM_SetWindowPos              (WM_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Xvoid WM_SetWindowPos              (GUI_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Nint  WM_SetXSize                  (WM_HWIN hWin, int xSize);
Xint  WM_SetXSize                  (GUI_HWIN hWin, int xSize);
Nint  WM_SetYSize                  (WM_HWIN hWin, int ySize);
Xint  WM_SetYSize                  (GUI_HWIN hWin, int ySize);
Nint  WM_SetScrollbarH             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarH             (GUI_HWIN hWin, int OnOff);  
Nint  WM_SetScrollbarV             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarV             (GUI_HWIN hWin, int OnOff);  
N
N/* ToolTip support */
N#define WM_TOOLTIP_PI_FIRST 0
N#define WM_TOOLTIP_PI_SHOW  1
N#define WM_TOOLTIP_PI_NEXT  2
N
N#define WM_TOOLTIP_CI_BK    0
N#define WM_TOOLTIP_CI_FRAME 1
N#define WM_TOOLTIP_CI_TEXT  2
N
Ntypedef WM_HMEM WM_TOOLTIP_HANDLE;
Xtypedef signed long WM_TOOLTIP_HANDLE;
N
Ntypedef struct {
N  int          Id;
N  const char * pText;
N} TOOLTIP_INFO;
N
Nint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, WM_HWIN hTool, const char * pText);
Xint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, GUI_HWIN hTool, const char * pText);
NWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (WM_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
XWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (GUI_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
Nvoid              WM_TOOLTIP_Delete          (WM_TOOLTIP_HANDLE hToolTip);
NGUI_COLOR         WM_TOOLTIP_SetDefaultColor (unsigned Index, GUI_COLOR Color);
Nconst GUI_FONT *  WM_TOOLTIP_SetDefaultFont  (const GUI_FONT * pFont);
Nunsigned          WM_TOOLTIP_SetDefaultPeriod(unsigned Index, unsigned Period);
N
N/* ToolTip support, private */
Nvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, WM_HWIN));
Xvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, GUI_HWIN));
N
N/* Timer */
N#ifdef GUI_X_CREATE_TIMER
S  int  WM_CreateTimer    (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
S  void WM_DeleteTimer    (WM_HWIN hWin, int UserId); /* not to be documented (may change in future version) */
N#else
N  WM_HMEM WM_CreateTimer (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
X  signed long WM_CreateTimer (GUI_HWIN hWin, int UserID, int Period, int Mode);  
N  void    WM_DeleteTimer (WM_HMEM hTimer); /* not to be documented (may change in future version) */
X  void    WM_DeleteTimer (signed long hTimer);  
N  void    WM_RestartTimer(WM_HMEM hTimer, int Period);
X  void    WM_RestartTimer(signed long hTimer, int Period);
N#endif
Nint WM_GetTimerId(WM_HTIMER hTimer);
Xint WM_GetTimerId(signed long hTimer);
N
N/* Diagnostics */
Nint WM_GetNumWindows(void);
Nint WM_GetNumInvalidWindows(void);
N
N/* Scroll state related functions */
Nvoid WM_CheckScrollBounds(WM_SCROLL_STATE * pScrollState); /* not to be documented (may change in future version) */
Nint  WM_GetScrollPosH    (WM_HWIN hWin);
Xint  WM_GetScrollPosH    (GUI_HWIN hWin);
Nint  WM_GetScrollPosV    (WM_HWIN hWin);
Xint  WM_GetScrollPosV    (GUI_HWIN hWin);
Nvoid WM_SetScrollPosH    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosH    (GUI_HWIN hWin, unsigned ScrollPos);
Nvoid WM_SetScrollPosV    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosV    (GUI_HWIN hWin, unsigned ScrollPos);
Nint  WM_SetScrollValue   (WM_SCROLL_STATE * pScrollState, int v); /* not to be documented (may change in future version) */
N
N/* Get / Set (new) callback function */
NWM_CALLBACK * WM_SetCallback(WM_HWIN hWin, WM_CALLBACK * cb);
XWM_CALLBACK * WM_SetCallback(GUI_HWIN hWin, WM_CALLBACK * cb);
NWM_CALLBACK * WM_GetCallback(WM_HWIN hWin);
XWM_CALLBACK * WM_GetCallback(GUI_HWIN hWin);
N
N/* Get size/origin of a window */
Nvoid      WM_GetClientRect           (GUI_RECT * pRect);
Nvoid      WM_GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRect           (GUI_RECT * pRect);
Nvoid      WM_GetInsideRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetInsideRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRectExScrollbar(WM_HWIN hWin, GUI_RECT * pRect); /* not to be documented (may change in future version) */
Xvoid      WM_GetInsideRectExScrollbar(GUI_HWIN hWin, GUI_RECT * pRect);  
Nvoid      WM_GetWindowRect           (GUI_RECT * pRect);
Nvoid      WM_GetWindowRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetWindowRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nint       WM_GetOrgX                 (void);
Nint       WM_GetOrgY                 (void);
Nint       WM_GetWindowOrgX           (WM_HWIN hWin);
Xint       WM_GetWindowOrgX           (GUI_HWIN hWin);
Nint       WM_GetWindowOrgY           (WM_HWIN hWin);
Xint       WM_GetWindowOrgY           (GUI_HWIN hWin);
Nint       WM_GetWindowSizeX          (WM_HWIN hWin);
Xint       WM_GetWindowSizeX          (GUI_HWIN hWin);
Nint       WM_GetWindowSizeY          (WM_HWIN hWin);
Xint       WM_GetWindowSizeY          (GUI_HWIN hWin);
NWM_HWIN   WM_GetFirstChild           (WM_HWIN hWin);
XGUI_HWIN   WM_GetFirstChild           (GUI_HWIN hWin);
NWM_HWIN   WM_GetNextSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetNextSibling          (GUI_HWIN hWin);
NWM_HWIN   WM_GetParent               (WM_HWIN hWin);
XGUI_HWIN   WM_GetParent               (GUI_HWIN hWin);
NWM_HWIN   WM_GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetPrevSibling          (GUI_HWIN hWin);
Nint       WM_GetId                   (WM_HWIN hWin);
Xint       WM_GetId                   (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarV           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarV           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarH           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarH           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollPartner        (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollPartner        (GUI_HWIN hWin);
NWM_HWIN   WM_GetClientWindow         (WM_HWIN hObj);
XGUI_HWIN   WM_GetClientWindow         (GUI_HWIN hObj);
NGUI_COLOR WM_GetBkColor              (WM_HWIN hObj);
XGUI_COLOR WM_GetBkColor              (GUI_HWIN hObj);
N
N/* Change Z-Order of windows */
Nvoid WM_BringToBottom(WM_HWIN hWin);
Xvoid WM_BringToBottom(GUI_HWIN hWin);
Nvoid WM_BringToTop(WM_HWIN hWin);
Xvoid WM_BringToTop(GUI_HWIN hWin);
N
NGUI_COLOR WM_SetDesktopColor  (GUI_COLOR Color);
NGUI_COLOR WM_SetDesktopColorEx(GUI_COLOR Color, unsigned int LayerIndex);
Nvoid      WM_SetDesktopColors (GUI_COLOR Color);
N
N/* Select window used for drawing operations */
NWM_HWIN WM_SelectWindow           (WM_HWIN  hWin);
XGUI_HWIN WM_SelectWindow           (GUI_HWIN  hWin);
NWM_HWIN WM_GetActiveWindow        (void);
XGUI_HWIN WM_GetActiveWindow        (void);
Nvoid    WM_Paint                  (WM_HWIN hObj);
Xvoid    WM_Paint                  (GUI_HWIN hObj);
Nvoid    WM_Update                 (WM_HWIN hWin);
Xvoid    WM_Update                 (GUI_HWIN hWin);
Nvoid    WM_PaintWindowAndDescs    (WM_HWIN hWin);
Xvoid    WM_PaintWindowAndDescs    (GUI_HWIN hWin);
Nvoid    WM_UpdateWindowAndDescs   (WM_HWIN hWin);
Xvoid    WM_UpdateWindowAndDescs   (GUI_HWIN hWin);
N
N/* Get foreground/background windows */
NWM_HWIN WM_GetDesktopWindow  (void);
XGUI_HWIN WM_GetDesktopWindow  (void);
NWM_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
XGUI_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
N
N/* Reduce clipping area of a window */
Nconst GUI_RECT * WM_SetUserClipRect(const GUI_RECT * pRect);
Nvoid             WM_SetDefault     (void);
N
N/* Use of memory devices */
Nvoid WM_EnableMemdev              (WM_HWIN hWin);
Xvoid WM_EnableMemdev              (GUI_HWIN hWin);
Nvoid WM_DisableMemdev             (WM_HWIN hWin);
Xvoid WM_DisableMemdev             (GUI_HWIN hWin);
N
N/* Automatic use of multiple buffers */
Nint WM_MULTIBUF_Enable(int OnOff);
N
Nextern const GUI_MULTIBUF_API * WM_MULTIBUF__pAPI;
N
Ntypedef void (* T_WM_EXEC_GESTURE)(void);
N
Nextern T_WM_EXEC_GESTURE WM__pExecGestures;
N
N/* ... */
Nint WM_OnKey(int Key, int Pressed);
Nvoid WM_MakeModal(WM_HWIN hWin);
Xvoid WM_MakeModal(GUI_HWIN hWin);
Nint WM_SetModalLayer(int LayerIndex);
Nint WM_GetModalLayer(void);
N
N/*********************************************************************
N*
N*       Message related functions
N*
N*  Please note that some of these functions do not yet show up in the
N*  documentation, as they should not be required by application program.
N*/
Nvoid      WM_NotifyParent         (WM_HWIN hWin, int Notification);
Xvoid      WM_NotifyParent         (GUI_HWIN hWin, int Notification);
Nvoid      WM_SendMessage          (WM_HWIN hWin, WM_MESSAGE * p);
Xvoid      WM_SendMessage          (GUI_HWIN hWin, WM_MESSAGE * p);
Nvoid      WM_SendMessageNoPara    (WM_HWIN hWin, int MsgId);             /* not to be documented (may change in future */
Xvoid      WM_SendMessageNoPara    (GUI_HWIN hWin, int MsgId);              
Nvoid      WM_DefaultProc          (WM_MESSAGE * pMsg);
Nint       WM_BroadcastMessage     (WM_MESSAGE * pMsg);
Nvoid      WM_SetScrollState       (WM_HWIN hWin, const WM_SCROLL_STATE * pState);
Xvoid      WM_SetScrollState       (GUI_HWIN hWin, const WM_SCROLL_STATE * pState);
Nvoid      WM_SetEnableState       (WM_HWIN hItem, int State);
Xvoid      WM_SetEnableState       (GUI_HWIN hItem, int State);
Nvoid      WM_SendToParent         (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid      WM_SendToParent         (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint       WM_HasFocus             (WM_HWIN hWin);
Xint       WM_HasFocus             (GUI_HWIN hWin);
Nint       WM_SetFocus             (WM_HWIN hWin);
Xint       WM_SetFocus             (GUI_HWIN hWin);
NWM_HWIN   WM_SetFocusOnNextChild  (WM_HWIN hParent);     /* Set the focus to the next child */
XGUI_HWIN   WM_SetFocusOnNextChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_SetFocusOnPrevChild  (WM_HWIN hParent);     /* Set the focus to the previous child */
XGUI_HWIN   WM_SetFocusOnPrevChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_GetDialogItem        (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetDialogItem        (GUI_HWIN hWin, int Id);
Nvoid      WM_EnableWindow         (WM_HWIN hWin);
Xvoid      WM_EnableWindow         (GUI_HWIN hWin);
Nvoid      WM_DisableWindow        (WM_HWIN hWin);
Xvoid      WM_DisableWindow        (GUI_HWIN hWin);
Nvoid      WM_GetScrollState       (WM_HWIN hObj, WM_SCROLL_STATE * pScrollState);
Xvoid      WM_GetScrollState       (GUI_HWIN hObj, WM_SCROLL_STATE * pScrollState);
N
N/*********************************************************************
N*
N*       Managing user data
N*/
Nint       WM_GetUserData   (WM_HWIN hWin, void * pDest, int SizeOfBuffer);
Xint       WM_GetUserData   (GUI_HWIN hWin, void * pDest, int SizeOfBuffer);
Nint       WM_SetUserData   (WM_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Xint       WM_SetUserData   (GUI_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Nint       WM__GetUserDataEx(WM_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Xint       WM__GetUserDataEx(GUI_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Nint       WM__SetUserDataEx(WM_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
Xint       WM__SetUserDataEx(GUI_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
N
N/*********************************************************************
N*
N*       Capturing input focus
N*/
Nint  WM_HasCaptured   (WM_HWIN hWin);
Xint  WM_HasCaptured   (GUI_HWIN hWin);
Nvoid WM_SetCapture    (WM_HWIN hObj, int AutoRelease);
Xvoid WM_SetCapture    (GUI_HWIN hObj, int AutoRelease);
Nvoid WM_SetCaptureMove(WM_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop); /* Not yet documented */
Xvoid WM_SetCaptureMove(GUI_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop);  
Nvoid WM_ReleaseCapture(void);
N
N/*********************************************************************
N*
N*       Misc routines
N*/
Nint       WM_HandlePID      (void);
NWM_HWIN   WM_Screen2hWin    (int x, int y);
XGUI_HWIN   WM_Screen2hWin    (int x, int y);
NWM_HWIN   WM_Screen2hWinEx  (WM_HWIN hStop, int x, int y);
XGUI_HWIN   WM_Screen2hWinEx  (GUI_HWIN hStop, int x, int y);
Nvoid      WM_ForEachDesc    (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid      WM_ForEachDesc    (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid      WM_SetScreenSize  (int xSize, int ySize);
Nint       WM_PollSimMsg     (void);
Nint       WM_GetWindowInfo  (WM_WINDOW_INFO * pInfo, int FirstWindow);
N
N/*********************************************************************
N*
N*       Diagnostics routines
N*/
N#if (WM_SUPPORT_DIAG)
X#if (0)
Svoid WM_DIAG_EnableInvalidationColoring(int OnOff);
N#endif
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*/
N#if WM_COMPATIBLE_MODE
X#if 1
N  #define HBWIN             WM_HWIN
N  #define HBWIN_NULL        WM_HWIN_NULL
N
N  #define WM_HideWin        WM_HideWindow
N  #define WM_ShowWin        WM_ShowWindow
N  #define WM_GetKey         GUI_GetKey
N  #define WM_WaitKey        GUI_WaitKey
N
N  #define WM_ExecIdle       WM_Exec
N  #define WM_ExecIdle1      WM_Exec1
N
N  #define WM_Invalidate     WM_InvalidateWindow
N  #define WM_GetWinRect     WM_GetWindowRect
N  #define WM_GetWinOrgX     WM_GetWindowOrgX
N  #define WM_GetWinOrgY     WM_GetWindowOrgY
N  #define WM_GetWinSizeX    WM_GetWindowSizeX
N  #define WM_GetWinSizeY    WM_GetWindowSizeY
N  #define WM_GetXSize       WM_GetWindowSizeX
N  #define WM_GetYSize       WM_GetWindowSizeY
N  #define WM_SelWin         WM_SelectWindow
N  #define WM_GetBackgroundWindow  WM_GetDesktopWindow
N  #define WM_GetForegroundWindow    0
N  #define WM_SetForegroundWindow    WM_BringToTop
N  #define WM_SetUserClipArea WM_SetUserClipRect
N
N
N  #define WM_Start()
N  #define WM_Stop()
N  #define WM_SetBkWindowColor(Color)  WM_SetDesktopColor(Color)
N
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* WM_H */
N
N/*************************** End of file ****************************/
L 58 "..\STemWin\inc\DIALOG.h" 2
N#include "BUTTON.h"
L 1 "..\STemWin\inc\BUTTON.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : BUTTON.h
NPurpose     : BUTTON public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef BUTTON_H
N#define BUTTON_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
L 1 "..\STemWin\inc\DIALOG_Intern.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef DIALOG_INTERN_H
N#define DIALOG_INTERN_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct  GUI_WIDGET_CREATE_INFO_struct GUI_WIDGET_CREATE_INFO;
Ntypedef WM_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, WM_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
Xtypedef GUI_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, GUI_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Structures
N*
N**********************************************************************
N*/
Nstruct GUI_WIDGET_CREATE_INFO_struct {
N  GUI_WIDGET_CREATE_FUNC * pfCreateIndirect;
N  const char             * pName;            // Text ... Not used on all widgets
N  I16                      Id;               // ID ... should be unique in a dialog
X  signed short                      Id;               
N  I16                      x0;               // x position
X  signed short                      x0;               
N  I16                      y0;               // y position
X  signed short                      y0;               
N  I16                      xSize;            // x size
X  signed short                      xSize;            
N  I16                      ySize;            // y size
X  signed short                      ySize;            
N  U16                      Flags;            // Widget specific create flags (opt.)
X  unsigned short                      Flags;            
N  I32                      Para;             // Widget specific parameter (opt.)
X  signed long                      Para;             
N  U32                      NumExtraBytes;    // Number of extra bytes usable with <WIDGET>_SetUserData & <WIDGET>_GetUserData
X  unsigned long                      NumExtraBytes;    
N};
N
N/*********************************************************************
N*
N*       Public API functions
N*
N**********************************************************************
N*/
NWM_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
XGUI_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nvoid               GUI_EndDialog         (WM_HWIN hWin, int r);
Xvoid               GUI_EndDialog         (GUI_HWIN hWin, int r);
Nint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
Xint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nint                GUI_ExecCreatedDialog (WM_HWIN hDialog);
Xint                GUI_ExecCreatedDialog (GUI_HWIN hDialog);
NWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(WM_HWIN hDialog);                                    // Not to be documented
XWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(GUI_HWIN hDialog);                                    
Nvoid               GUI_SetDialogStatusPtr(WM_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  // Not to be documented
Xvoid               GUI_SetDialogStatusPtr(GUI_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  
N
N/*********************************************************************
N*
N*       Obsolete
N*/
NLCD_COLOR          DIALOG_GetBkColor(void);
NLCD_COLOR          DIALOG_SetBkColor(LCD_COLOR BkColor);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_INTERN_H
N
N/*************************** End of file ****************************/
L 59 "..\STemWin\inc\BUTTON.h" 2
N#include "WIDGET.h"
L 1 "..\STemWin\inc\WIDGET.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
N#define WIDGET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
L 1 "..\STemWin\inc\WM_Intern.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : WM_Intern.h
NPurpose     : Windows manager internal include
N----------------------------------------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef WM_INTERN_H            /* Make sure we only include it once */
N#define WM_INTERN_H            /* Make sure we only include it once */
N
N#include "WM.h"
N#include "GUI_Private.h"
L 1 "..\STemWin\inc\GUI_Private.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUI_Private.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef GUI_PRIVATE_H
N#define GUI_PRIVATE_H
N
N#include "GUI.h"
N#include "LCD_Protected.h"
L 1 "..\STemWin\inc\LCD_Protected.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : LCD level - To be used only internally by the GUI
N----------------------------------------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef LCD_PROTECTED_H
N#define LCD_PROTECTED_H
N
N#include "LCD.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct {
N  LCD_COLOR * paColor;
N  I16         NumEntries;
X  signed short         NumEntries;
N} LCD_LUT_INFO;
N
Ntypedef struct {
N  tLCDDEV_DrawPixel  * pfDrawPixel;
N  tLCDDEV_DrawHLine  * pfDrawHLine;
N  tLCDDEV_DrawVLine  * pfDrawVLine;
N  tLCDDEV_FillRect   * pfFillRect;
N  tLCDDEV_DrawBitmap * pfDrawBitmap;
N} LCD_API_LIST;
N
N/*********************************************************************
N*
N*       External data
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
Nextern LCD_PIXELINDEX * LCD__aConvTable;
Xextern unsigned long * LCD__aConvTable;
N
N/*********************************************************************
N*
N*       Misc functions
N*/
Nvoid LCD_UpdateColorIndices   (void);
Nint  LCD_PassingBitmapsAllowed(void);
Nvoid LCD_EnableCursor         (int OnOff);
Nvoid LCD_SelectLCD            (void);
N
Nvoid LCD_DrawBitmap(int x0,    int y0,
N                    int xsize, int ysize,
N                    int xMul,  int yMul,
N                    int BitsPerPixel,
N                    int BytesPerLine,
N                    const U8 * pPixel,
X                    const unsigned char * pPixel,
N                    const LCD_PIXELINDEX * pTrans);
X                    const unsigned long * pTrans);
N
Nvoid LCD__DrawBitmap_1bpp(int x0,    int y0,
N                          int xsize, int ysize,
N                          int xMul,  int yMul,
N                          int BitsPerPixel,
N                          int BytesPerLine,
N                          const U8 * pPixel,
X                          const unsigned char * pPixel,
N                          const LCD_PIXELINDEX * pTrans,
X                          const unsigned long * pTrans,
N                          int OffData);
N
N/*********************************************************************
N*
N*       Internal used color conversion routines
N*/
NtLCDDEV_Index2Color LCD_Index2Color_444_12;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12;
NtLCDDEV_Index2Color LCD_Index2Color_444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_444_16;
NtLCDDEV_Index2Color LCD_Index2Color_M444_16;
NtLCDDEV_Index2Color LCD_Index2Color_555;
NtLCDDEV_Index2Color LCD_Index2Color_565;
NtLCDDEV_Index2Color LCD_Index2Color_8666;
NtLCDDEV_Index2Color LCD_Index2Color_888;
NtLCDDEV_Index2Color LCD_Index2Color_8888;
NtLCDDEV_Index2Color LCD_Index2Color_M8888I;
NtLCDDEV_Index2Color LCD_Index2Color_M555;
NtLCDDEV_Index2Color LCD_Index2Color_M565;
NtLCDDEV_Index2Color LCD_Index2Color_M888;
N
NtLCDDEV_Color2Index LCD_Color2Index_8666;
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* LCD_PROTECTED_H */
N
N/*************************** End of file ****************************/
N
L 59 "..\STemWin\inc\GUI_Private.h" 2
N#include "GUI_Debug.h"
L 1 "..\STemWin\inc\GUI_Debug.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GUI_Debug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include <stddef.h>
L 1 "C:\Keil_v521a\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 61 "..\STemWin\inc\GUI_Debug.h" 2
N
N#include "GUI.h"
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
N  #endif
N#endif
N
N#define GUI_LOCK_H(hMem)   GUI_ALLOC_LockH(hMem)
N#define GUI_UNLOCK_H(pMem) GUI_ALLOC_UnlockH((void **)&pMem)
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 1 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 1 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Log1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Log2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Log3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Log4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
L 60 "..\STemWin\inc\GUI_Private.h" 2
N#if GUI_WINSUPPORT
X#if (1)
N  #include "WM_GUI.h"
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defaults for config switches
N*
N**********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context and some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N/*********************************************************************
N*
N*       Angles
N*
N**********************************************************************
N*/
N#define GUI_45DEG  512
N#define GUI_90DEG  (2 * GUI_45DEG)
N#define GUI_180DEG (4 * GUI_45DEG)
N#define GUI_360DEG (8 * GUI_45DEG)
N
N
N/*********************************************************************
N*
N*       Locking checks
N*
N**********************************************************************
N*/
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (0)
S  #define GUI_ASSERT_LOCK()    GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N/*********************************************************************
N*
N*       Division tables
N*
N**********************************************************************
N*/
Nextern const U8 GUI__aConvert_15_255[(1 << 4)];
Xextern const unsigned char GUI__aConvert_15_255[(1 << 4)];
Nextern const U8 GUI__aConvert_31_255[(1 << 5)];
Xextern const unsigned char GUI__aConvert_31_255[(1 << 5)];
Nextern const U8 GUI__aConvert_63_255[(1 << 6)];
Xextern const unsigned char GUI__aConvert_63_255[(1 << 6)];
Nextern const U8 GUI__aConvert_255_15[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_15[(1 << 8)];
Nextern const U8 GUI__aConvert_255_31[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_31[(1 << 8)];
Nextern const U8 GUI__aConvert_255_63[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_63[(1 << 8)];
N
N/*********************************************************************
N*
N*       Usage internals
N*
N**********************************************************************
N*/
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed long GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
N
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE * p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE * p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE * p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE * p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE * p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE * p, int * pxOff, int yOff);
N#define GUI_USAGE_LOCK_H(h) ((GUI_USAGE *)GUI_LOCK_H(h))
N
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE * pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel         * pfAddPixel;
N  tUSAGE_AddHLine         * pfAddHLine;
N  tUSAGE_Clear            * pfClear;
N  tUSAGE_CreateCompatible * pfCreateCompatible;
N  tUSAGE_Delete           * pfDelete;
N  tUSAGE_GetNextDirty     * pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList * pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N
N/*********************************************************************
N*
N*       GUI_MEMDEV
N*
N**********************************************************************
N*/
N#if GUI_SUPPORT_MEMDEV
X#if (1)
N
Ntypedef struct {
N  GUI_DEVICE * pDevice;
N  I16P                   x0, y0, XSize, YSize;
X  signed short                   x0, y0, XSize, YSize;
N  unsigned               BytesPerLine;
N  unsigned               BitsPerPixel;
N  GUI_HMEM               hUsage;
X  signed long               hUsage;
N} GUI_MEMDEV;
N
N#define      GUI_MEMDEV_LOCK_H(h) ((GUI_MEMDEV *)GUI_LOCK_H(h))
N
Nvoid         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
Nvoid         GUI_MEMDEV__GetRect     (GUI_RECT * pRect);
Nunsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
NLCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
Nunsigned int GUI_MEMDEV__GetIndexMask(void);
Nvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(U8));
Xvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(unsigned char));
N
NGUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xSize, int ySize, int Flags,
N                                          const GUI_DEVICE_API     * pDeviceAPI,
N                                          const LCD_API_COLOR_CONV * pColorConvAPI);
N
Nvoid              GUI_MEMDEV__DrawSizedAt        (GUI_MEMDEV_Handle hMem, int xPos, int yPos, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV__GetEmptyCopy32     (GUI_MEMDEV_Handle hMem, int * pxSize, int * pySize, int * pxPos, int * pyPos);
Nvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, LCD_PIXELINDEX * pBuffer);
Xvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, unsigned long * pBuffer);
Nvoid              GUI_MEMDEV__WriteToActiveAlpha (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveAt    (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveOpaque(GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid            * GUI_MEMDEV__XY2PTR             (int x,int y);
Nvoid            * GUI_MEMDEV__XY2PTREx           (GUI_MEMDEV * pDev, int x,int y);
Nvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
N
Nunsigned GUI__AlphaPreserveTrans(int OnOff);
N
Nextern unsigned GUI_MEMDEV__TimePerFrame;
N
N#define GUI_TIME_PER_FRAME (GUI_TIMER_TIME)GUI_MEMDEV__TimePerFrame
N
N#define GUI_POS_AUTO -4095   /* Position value for auto-pos */
N
N#endif
N
N
N/*********************************************************************
N*
N*       LCD_HL_ level defines
N*
N**********************************************************************
N*/
N#define LCD_HL_DrawHLine             GUI_pContext->pLCD_HL->pfDrawHLine
N#define LCD_HL_DrawPixel             GUI_pContext->pLCD_HL->pfDrawPixel
N
N
N/*********************************************************************
N*
N*       Helper functions
N*
N**********************************************************************
N*/
N#define GUI_ZEROINIT(Obj) GUI_MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* Multi-touch */
Nvoid GUI_MTOUCH__ManagePID(int OnOff);
N
N/* Anti-aliased drawing */
Nint  GUI_AA_Init       (int x0, int x1);
Nint  GUI_AA_Init_HiRes (int x0, int x1);
Nvoid GUI_AA_Exit       (void);
NI16  GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short  GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_FillCircleAA_HiRes (int x0, int y0, int r);
Nvoid GL_FillEllipseAA_HiRes(int x0, int y0, int rx, int ry);
N
Nvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
N
N/* Alpha blending helper functions */
N#define GUI_ALPHABLENDING_DONE  (1 << 0)
N
Nint      GUI__GetAlphaBuffer    (U32 ** ppCurrent, U32 ** ppConvert, U32 ** ppData, int * pVXSizeMax);
Xint      GUI__GetAlphaBuffer    (unsigned long ** ppCurrent, unsigned long ** ppConvert, unsigned long ** ppData, int * pVXSizeMax);
Nint      GUI__AllocAlphaBuffer  (int AllocDataBuffer);
NU32    * GUI__DoAlphaBlending   (int x, int y, U32 * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Xunsigned long    * GUI__DoAlphaBlending   (int x, int y, unsigned long * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Nunsigned GUI__SetAlphaBufferSize(int xSize);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX       (U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX       (unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo        (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont           (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont           (const GUI_FONT * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo       (const GUI_FONT * pFont, U16P c, unsigned SizeOfCharInfo);
Xconst unsigned char * GUI_SIF__GetpCharInfo       (const GUI_FONT * pFont, unsigned short c, unsigned SizeOfCharInfo);
Nint        GUI_SIF__GetNumCharAreas    (const GUI_FONT * pFont);
Nint        GUI_SIF__GetCharDistX_ExtFrm(U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX_ExtFrm(unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo_ExtFrm (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_SIF__GetCharInfo_ExtFrm (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_SIF__GetCharInfo_ExtFrm (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_SIF__ClearLine_ExtFrm   (const char * s, int Len);
N
N/* External binary font routines */
Nint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff);
Xint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff);
Nint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff, U16 * pSize);
Xint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff, unsigned short * pSize);
Nint        GUI_XBF__GetCharDistX (U16P c, int * pSizeX);
Xint        GUI_XBF__GetCharDistX (unsigned short c, int * pSizeX);
Nvoid       GUI_XBF__GetFontInfo  (const GUI_FONT * pFont, GUI_FONTINFO * pInfo);
Nchar       GUI_XBF__IsInFont     (const GUI_FONT * pFont, U16 c);
Xchar       GUI_XBF__IsInFont     (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_XBF__GetCharInfo  (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_XBF__GetCharInfo  (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_XBF__ClearLine    (const char * s, int Len);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecMin  (I32 v, char ** ps);
Xvoid GUI_AddDecMin  (signed long v, char ** ps);
Nvoid GUI_AddDec     (I32 v, U8 Len, char ** ps);
Xvoid GUI_AddDec     (signed long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char ** ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char ** ps);
Nlong GUI_AddSign    (long v, char ** ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
N#define GUI_UC__GetCharSize(sText)  GUI_pUC_API->pfGetCharSize(sText)
N#define GUI_UC__GetCharCode(sText)  GUI_pUC_API->pfGetCharCode(sText)
N
Nint   GUI_UC__CalcSizeOfChar   (U16 Char);
Xint   GUI_UC__CalcSizeOfChar   (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc   (const char ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc   (const char ** ps);
Nint   GUI_UC__NumChars2NumBytes(const char * s, int NumChars);
Nint   GUI_UC__NumBytes2NumChars(const char * s, int NumBytes);
N
Nint  GUI__GetLineNumChars  (const char * s, int MaxNumChars);
Nint  GUI__GetNumChars      (const char * s);
Nint  GUI__GetOverlap       (U16 Char);
Xint  GUI__GetOverlap       (unsigned short Char);
Nint  GUI__GetLineDistX     (const char * s, int Len);
Nint  GUI__GetFontSizeY     (void);
Nint  GUI__HandleEOLine     (const char ** ps);
Nvoid GUI__DispLine         (const char * s, int Len, const GUI_RECT * pr);
Nvoid GUI__AddSpaceHex      (U32 v, U8 Len, char ** ps);
Xvoid GUI__AddSpaceHex      (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI__CalcTextRect     (const char * pText, const GUI_RECT * pTextRectIn, GUI_RECT * pTextRectOut, int TextAlign);
N
Nvoid GUI__ClearTextBackground(int xDist, int yDist);
N
Nint  GUI__WrapGetNumCharsDisp       (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nvoid GUI__memset    (U8  * p, U8 Fill, int NumBytes);
Xvoid GUI__memset    (unsigned char  * p, unsigned char Fill, int NumBytes);
Nvoid GUI__memset16  (U16 * p, U16 Fill, int NumWords);
Xvoid GUI__memset16  (unsigned short * p, unsigned short Fill, int NumWords);
Nint  GUI__strlen    (const char * s);
Nint  GUI__strcmp    (const char * s0, const char * s1);
Nint  GUI__strcmp_hp (GUI_HMEM hs0, const char * s1);
Xint  GUI__strcmp_hp (signed long hs0, const char * s1);
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support (tbd) */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext, const char * s);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext, const char * s);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
N
N/* BiDi support */
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
N
Nconst char * GUI__BIDI_Log2VisBuffered(const char * s, int * pMaxNumChars);
N
Nextern int GUI__BIDI_Enabled;
N
Nextern int (* _pfGUI__BIDI_Log2Vis         )(const char * s, int NumChars, char * pBuffer, int BufferSize);
Nextern int (* _pfGUI__BIDI_GetCursorPosX   )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCursorPosChar)(const char * s, int NumChars, int x);
Nextern U16 (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Xextern unsigned short (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCharDir      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_IsNSM           )(U16 Char);
Xextern int (* _pfGUI__BIDI_IsNSM           )(unsigned short Char);
N
N/* BiDi-related function pointers */
Nextern const char * (* GUI_CharLine_pfLog2Vis)(const char * s, int * pMaxNumChars);
N
Nextern int (* GUI__GetCursorPos_pfGetPosX)     (const char * s, int MaxNumChars, int Index);
Nextern int (* GUI__GetCursorPos_pfGetPosChar)  (const char * s, int MaxNumChars, int x);
Nextern U16 (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
Xextern unsigned short (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
N
Nextern int (* GUI__Wrap_pfGetWordWrap)(const char * s, int xSize, int * pxDist);
Nextern int (* GUI__Wrap_pfGetCharWrap)(const char * s, int xSize);
N
N/* Proportional  font support */
Nconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, U16P c);
Xconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, unsigned short c);
N
N/* Extended proportional font support */
Nconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, U16P c);
Xconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, unsigned short c);
Nvoid  GUIPROP_EXT__DispLine      (const char * s, int Len);
Nvoid  GUIPROP_EXT__ClearLine     (const char * s, int Len);
Nvoid  GUIPROP_EXT__SetfpClearLine(void (* fpClearLine)(const char * s, int Len));
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
Nvoid GUI__SetOrgHook(void(* pfHook)(int x, int y));
N
N/* Timer support */
Nint              GUI_TIMER__IsActive       (void);
NGUI_TIMER_TIME   GUI_TIMER__GetPeriod      (void);
Xint   GUI_TIMER__GetPeriod      (void);
NGUI_TIMER_HANDLE GUI_TIMER__GetNextTimer   (GUI_TIMER_HANDLE hTimer, U32 * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetNextTimer   (GUI_TIMER_HANDLE hTimer, unsigned long * pContext);
NGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (U32 * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (unsigned long * pContext);
NGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, U32 * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, unsigned long * pContext);
N
N/* Get function pointers for color conversion */
NtLCDDEV_Index2Color * GUI_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * GUI_GetpfColor2IndexEx(int LayerIndex);
N
Nint GUI_GetBitsPerPixelEx(int LayerIndex);
N
NLCD_PIXELINDEX * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xunsigned long * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N/* Setting a function for converting a color palette to an array of index values */
Nvoid GUI_SetFuncGetpPalConvTable(LCD_PIXELINDEX * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
Xvoid GUI_SetFuncGetpPalConvTable(unsigned long * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
N
N/*********************************************************************
N*
N*       Format definitions used by streamed bitmaps
N*
N*   IMPORTANT: DO NOT CHANGE THESE VALUES!
N*   THEY HAVE TO CORRESPOND TO THE DEFINITIONS WITHIN THE CODE OF THE BITMAPCONVERTER!
N*/
N#define GUI_STREAM_FORMAT_INDEXED    100 /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE4       6   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE8       7   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_565        8   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M565       9   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_555        10  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M555       11  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE16      12  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEM16     13  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_8888       16  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE32      15  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_24         17  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEALPHA   18  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12     19  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12    20  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12_1   21  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12_1  22  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_16     23  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_16    24  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A555       25  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM555      26  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A565       27  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM565      28  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M8888I     29  /* DO NOT CHANGE */
N
N
Nvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const U8 * pData);
Xvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const unsigned char * pData);
Nvoid GUI__CreateBitmapFromStream(const GUI_BITMAP_STREAM * pBitmapHeader, const void * pData, GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const GUI_BITMAP_METHODS * pMethods);
N
N/* Cache management */
Nint GUI__ManageCache  (int Cmd);
Nint GUI__ManageCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       2d - GL
N*
N**********************************************************************
N*/
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry, int w);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x,  int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLine1Ex      (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x,  int y);
Nvoid GL_DrawLineToEx     (int x,  int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x,  int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N
N/*********************************************************************
N*
N*       Callback pointers for dynamic linkage
N*
N**********************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef int  WM_tfHandlePID(void);
N
N
N/*********************************************************************
N*
N*       Cursors
N*
N**********************************************************************
N*/
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowS[45];
Xextern const unsigned char  GUI_Pixels_ArrowS[45];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowM[60];
Xextern const unsigned char  GUI_Pixels_ArrowM[60];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowL[150];
Xextern const unsigned char  GUI_Pixels_ArrowL[150];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossS[33];
Xextern const unsigned char  GUI_Pixels_CrossS[33];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossM[126];
Xextern const unsigned char  GUI_Pixels_CrossM[126];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossL[248];
Xextern const unsigned char  GUI_Pixels_CrossL[248];
Nextern GUI_CONST_STORAGE unsigned char  GUI_PixelsHeaderM[5 * 17];
Xextern const unsigned char  GUI_PixelsHeaderM[5 * 17];
N
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPal;
Xextern const GUI_LOGPALETTE GUI_CursorPal;
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPalI;
Xextern const GUI_LOGPALETTE GUI_CursorPalI;
N
N
N/*********************************************************************
N*
N*       Text rotation
N*
N**********************************************************************
N*/
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Flag for setting transparency for 'EXT' fonts
N*
N**********************************************************************
N*/
Nextern U8 GUI__CharHasTrans;
Xextern unsigned char GUI__CharHasTrans;
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*       Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
Nint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const U8 * pData, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const unsigned char * pData, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Xvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid      GUI__SetPixelAlpha   (int x, int y, U8 Alpha, LCD_COLOR Color);
Xvoid      GUI__SetPixelAlpha   (int x, int y, unsigned char Alpha, LCD_COLOR Color);
NLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      GUI__MixColorsBulk   (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xvoid      GUI__MixColorsBulk   (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/*********************************************************************
N*
N*       LCDDEV_L0_xxx
N*
N**********************************************************************
N*/
N#define LCDDEV_L0_Color2Index         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfColor2Index
N#define LCDDEV_L0_Index2Color         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfIndex2Color
N
N#define LCDDEV_L0_DrawBitmap          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawBitmap
N#define LCDDEV_L0_DrawHLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawHLine
N#define LCDDEV_L0_DrawVLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawVLine
N#define LCDDEV_L0_DrawPixel           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawPixel
N#define LCDDEV_L0_FillRect            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfFillRect
N#define LCDDEV_L0_GetPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixel
N#define LCDDEV_L0_GetRect             GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetRect
N#define LCDDEV_L0_GetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixelIndex
N#define LCDDEV_L0_SetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfSetPixelIndex
N#define LCDDEV_L0_XorPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfXorPixel
N#define LCDDEV_L0_GetDevFunc          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetDevFunc
N
Nvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
Nvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       Internal color management
N*
N**********************************************************************
N*/
Ntypedef struct {
N  void         (* pfSetColor)   (LCD_COLOR Index);
N  void         (* pfSetBkColor) (LCD_COLOR Index);
N  LCD_DRAWMODE (* pfSetDrawMode)(LCD_DRAWMODE dm);
N} LCD_SET_COLOR_API;
N
Nextern const LCD_SET_COLOR_API * LCD__pSetColorAPI;
N
N#define LCD__SetBkColorIndex(Index) (*GUI_pContext->LCD_pBkColorIndex = Index)
N#define LCD__SetColorIndex(Index)   (*GUI_pContext->LCD_pColorIndex   = Index)
N#define LCD__GetBkColorIndex()      (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD__GetColorIndex()        (*GUI_pContext->LCD_pColorIndex)
N
N/* The following 2 defines are only required for compatibility to older versions of the TTF library */
N#define LCD_BKCOLORINDEX (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD_COLORINDEX   (*GUI_pContext->LCD_pColorIndex)
N
N/*********************************************************************
N*
N*       EXTERNs for GL_CORE
N*
N**********************************************************************
N*/
Nextern const GUI_FONT * GUI__pFontDefault;
N
Nextern GUI_SADDR GUI_CONTEXT * GUI_pContext;
Xextern  GUI_CONTEXT * GUI_pContext;
N
Nextern GUI_DEVICE * GUI__apDevice[GUI_NUM_LAYERS];
Xextern GUI_DEVICE * GUI__apDevice[2];
N
N//
N// Function pointer for converting a palette containing a color array into an index array
N//
Nextern LCD_PIXELINDEX * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xextern unsigned long * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N//
N// Function pointer for mixing up 2 colors
N//
Nextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for mixing up arrays of colors
N//
Nextern void (* GUI__pfMixColorsBulk)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xextern void (* GUI__pfMixColorsBulk)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
N//
N// API list to be used for MultiBuffering
N//
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIList;
Nextern const GUI_MULTIBUF_API_EX GUI_MULTIBUF_APIListEx;
N
N#ifdef  GL_CORE_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN   int  (* GUI_pfUpdateSoftLayer)(void);
Xextern   int  (* GUI_pfUpdateSoftLayer)(void);
N
N#ifdef WIN32
S  GUI_EXTERN void (* GUI_pfSoftlayerGetPixel)(int x, int y, void * p);
N#endif
N
NGUI_EXTERN void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
Xextern void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
N
NGUI_EXTERN const GUI_UC_ENC_APILIST * GUI_pUC_API; /* Unicode encoding API */
Xextern const GUI_UC_ENC_APILIST * GUI_pUC_API;  
N
NGUI_EXTERN GUI_SADDR char             GUI_DecChar;
Xextern  char             GUI_DecChar;
NGUI_EXTERN           GUI_tfTimer    * GUI_pfTimerExec;
Xextern           GUI_tfTimer    * GUI_pfTimerExec;
NGUI_EXTERN           WM_tfHandlePID * WM_pfHandlePID;
Xextern           WM_tfHandlePID * WM_pfHandlePID;
NGUI_EXTERN   void (* GUI_pfDispCharStyle)(U16 Char);
Xextern   void (* GUI_pfDispCharStyle)(unsigned short Char);
N
NGUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
Xextern           int GUI__BufferSize; 
NGUI_EXTERN           int GUI_AA__ClipX0;  // x0-clipping value for AA module
Xextern           int GUI_AA__ClipX0;  
N
NGUI_EXTERN           I8  GUI__aNumBuffers[GUI_NUM_LAYERS]; // Number of buffers used per layer
Xextern           signed char  GUI__aNumBuffers[2]; 
NGUI_EXTERN           U8  GUI__PreserveTrans;
Xextern           unsigned char  GUI__PreserveTrans;
NGUI_EXTERN           U8  GUI__IsInitialized;
Xextern           unsigned char  GUI__IsInitialized;
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N  GUI_EXTERN const tLCD_APIList * GUI_pLCD_APIList; /* Used for rotating text */
X  extern const tLCD_APIList * GUI_pLCD_APIList;  
N#endif
N
NGUI_EXTERN I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
N
N#undef GUI_EXTERN
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif /* GUI_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 59 "..\STemWin\inc\WM_Intern.h" 2
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#if GUI_WINSUPPORT
X#if (1)
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N
N  The following could be placed in a file of its own as it is not
N  used outside of the window manager
N
N*/
N/* Basic Windows status flags.
N   For module-internally use only !
N*/
N#define WM_SF_HASTRANS          WM_CF_HASTRANS
N#define WM_SF_MEMDEV            WM_CF_MEMDEV
N#define WM_SF_MEMDEV_ON_REDRAW  WM_CF_MEMDEV_ON_REDRAW
N#define WM_SF_DISABLED          WM_CF_DISABLED  /* Disabled: Does not receive PID (mouse & touch) input */
N#define WM_SF_ISVIS             WM_CF_SHOW      /* Is visible flag */
N
N#define WM_SF_STAYONTOP         WM_CF_STAYONTOP
N#define WM_SF_LATE_CLIP         WM_CF_LATE_CLIP
N#define WM_SF_ANCHOR_RIGHT      WM_CF_ANCHOR_RIGHT
N#define WM_SF_ANCHOR_BOTTOM     WM_CF_ANCHOR_BOTTOM
N#define WM_SF_ANCHOR_LEFT       WM_CF_ANCHOR_LEFT
N#define WM_SF_ANCHOR_TOP        WM_CF_ANCHOR_TOP
N
N#define WM_SF_INVALID           WM_CF_ACTIVATE  /* We reuse this flag, as it is create only and Invalid is status only */
N
N#define WM_SF_CONST_OUTLINE     WM_CF_CONST_OUTLINE       /* Constant outline.*/
N
N#define WM_H2P(hWin)            ((WM_Obj*)GUI_ALLOC_h2p(hWin))
N
N
N#if GUI_DEBUG_LEVEL  >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 1  >= 4
S  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt) \
S                                       GUI_DEBUG_ERROROUT("Function may not be called from within a paint event"); \
S                                   }
X  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt)                                        GUI_DEBUG_ERROROUT("Function may not be called from within a paint event");                                    }
N#else
N  #define WM_ASSERT_NOT_IN_PAINT()
N#endif
N
N/*********************************************************************
N*
N*       Data types & structures
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN hOld;
X  GUI_HWIN hOld;
N  WM_HWIN hNew;
X  GUI_HWIN hNew;
N} WM_NOTIFY_CHILD_HAS_FOCUS_INFO;
N
Ntypedef struct WM_CRITICAL_HANDLE {
N  struct  WM_CRITICAL_HANDLE * pNext;
N  volatile WM_HWIN hWin;
X  volatile GUI_HWIN hWin;
N} WM_CRITICAL_HANDLE;
N
N/*********************************************************************
N*
N*       Data (extern)
N*
N**********************************************************************
N*/
Nextern U32            WM__CreateFlags;
Xextern unsigned long            WM__CreateFlags;
Nextern WM_HWIN        WM__ahCapture[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahCapture[2];
Nextern WM_HWIN        WM__ahWinFocus[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahWinFocus[2];
Nextern char           WM__CaptureReleaseAuto;
Nextern WM_tfPollPID * WM_pfPollPID;
Nextern U8             WM__PaintCallbackCnt;      /* Public for assertions only */
Xextern unsigned char             WM__PaintCallbackCnt;       
Nextern WM_HWIN        WM__hCreateStatic;
Xextern GUI_HWIN        WM__hCreateStatic;
N
N#if WM_SUPPORT_TRANSPARENCY
X#if 1
N  extern int     WM__TransWindowCnt;
N  extern WM_HWIN WM__hATransWindow;
X  extern GUI_HWIN WM__hATransWindow;
N#endif
N
N#if WM_SUPPORT_DIAG
X#if 0
S  extern void (*WM__pfShowInvalid)(WM_HWIN hWin);
N#endif
N
Nextern WM_CRITICAL_HANDLE     WM__aCHWinModal[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinModal[2];
Nextern WM_CRITICAL_HANDLE     WM__aCHWinLast[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinLast[2];
Nextern int                    WM__ModalLayer;
N
N#if GUI_SUPPORT_MOUSE
X#if (1)
N  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[GUI_NUM_LAYERS];
X  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[2];
N#endif
N
N#ifdef WM_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
N#if (GUI_NUM_LAYERS > 1)
X#if (2 > 1)
N  GUI_EXTERN unsigned                  WM__TouchedLayer;
X  extern unsigned                  WM__TouchedLayer;
N  #define WM__TOUCHED_LAYER            WM__TouchedLayer
N#else
S  #define WM__TOUCHED_LAYER            GUI_CURSOR_LAYER
N#endif
N
NGUI_EXTERN U16     WM__NumWindows;
Xextern unsigned short     WM__NumWindows;
NGUI_EXTERN U16     WM__NumInvalidWindows;
Xextern unsigned short     WM__NumInvalidWindows;
NGUI_EXTERN WM_HWIN WM__FirstWin;
Xextern GUI_HWIN WM__FirstWin;
NGUI_EXTERN WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
Xextern WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
N
NGUI_EXTERN WM_HWIN   WM__ahDesktopWin[GUI_NUM_LAYERS];
Xextern GUI_HWIN   WM__ahDesktopWin[2];
NGUI_EXTERN GUI_COLOR WM__aBkColor[GUI_NUM_LAYERS];
Xextern GUI_COLOR WM__aBkColor[2];
N
N#undef GUI_EXTERN
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
Nvoid    WM__ActivateClipRect        (void);
Nint     WM__ClipAtParentBorders     (GUI_RECT * pRect, WM_HWIN hWin);
Xint     WM__ClipAtParentBorders     (GUI_RECT * pRect, GUI_HWIN hWin);
Nvoid    WM__Client2Screen           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__DeleteAssocTimer        (WM_HWIN hWin);
Xvoid    WM__DeleteAssocTimer        (GUI_HWIN hWin);
Nvoid    WM__DeleteSecure            (WM_HWIN hWin);
Xvoid    WM__DeleteSecure            (GUI_HWIN hWin);
Nvoid    WM__DetachWindow            (WM_HWIN hChild);
Xvoid    WM__DetachWindow            (GUI_HWIN hChild);
Nvoid    WM__ForEachDesc             (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid    WM__ForEachDesc             (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid    WM__GetClientRectWin        (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
NWM_HWIN WM__GetFirstSibling         (WM_HWIN hWin);
XGUI_HWIN WM__GetFirstSibling         (GUI_HWIN hWin);
NWM_HWIN WM__GetFocussedChild        (WM_HWIN hWin);
XGUI_HWIN WM__GetFocussedChild        (GUI_HWIN hWin);
Nint     WM__GetHasFocus             (WM_HWIN hWin);
Xint     WM__GetHasFocus             (GUI_HWIN hWin);
NWM_HWIN WM__GetLastSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetLastSibling          (GUI_HWIN hWin);
NWM_HWIN WM__GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetPrevSibling          (GUI_HWIN hWin);
Nint     WM__GetTopLevelLayer        (WM_HWIN hWin);
Xint     WM__GetTopLevelLayer        (GUI_HWIN hWin);
Nint     WM__GetWindowSizeX          (const WM_Obj * pWin);
Nint     WM__GetWindowSizeY          (const WM_Obj * pWin);
Nvoid    WM__InsertWindowIntoList    (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM__InsertWindowIntoList    (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM__Invalidate1Abs          (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM__Invalidate1Abs          (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM__InvalidateAreaBelow     (const GUI_RECT * pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateAreaBelow     (const GUI_RECT * pRect, GUI_HWIN StopWin);
Nvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid    WM__InvalidateTransAreaAbove(const GUI_RECT * pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateTransAreaAbove(const GUI_RECT * pRect, GUI_HWIN StopWin);
Nint     WM__IntersectRect           (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint     WM__IsAncestor              (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestor              (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsAncestorOrSelf        (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestorOrSelf        (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsChild                 (WM_HWIN hWin, WM_HWIN hParent);
Xint     WM__IsChild                 (GUI_HWIN hWin, GUI_HWIN hParent);
Nint     WM__IsEnabled               (WM_HWIN hWin);
Xint     WM__IsEnabled               (GUI_HWIN hWin);
Nint     WM__IsInModalArea           (WM_HWIN hWin);
Xint     WM__IsInModalArea           (GUI_HWIN hWin);
Nint     WM__IsInWindow              (WM_Obj * pWin, int x, int y);
Nint     WM__IsWindow                (WM_HWIN hWin);
Xint     WM__IsWindow                (GUI_HWIN hWin);
Nvoid    WM__LeaveIVRSearch          (void);
Nvoid    WM__MoveTo                  (WM_HWIN hWin, int x, int y);
Xvoid    WM__MoveTo                  (GUI_HWIN hWin, int x, int y);
Nvoid    WM__MoveWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid    WM__MoveWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid    WM__NotifyVisChanged        (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__NotifyVisChanged        (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM__RectIsNZ                (const GUI_RECT * pr);
Nvoid    WM__RemoveWindowFromList    (WM_HWIN hWin);
Xvoid    WM__RemoveWindowFromList    (GUI_HWIN hWin);
Nvoid    WM__Screen2Client           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__SelectTopLevelLayer     (WM_HWIN  hWin);
Xvoid    WM__SelectTopLevelLayer     (GUI_HWIN  hWin);
Nvoid    WM__SendMsgNoData           (WM_HWIN hWin, U8 MsgId);
Xvoid    WM__SendMsgNoData           (GUI_HWIN hWin, unsigned char MsgId);
Nvoid    WM__SendMessage             (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessage             (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageIfEnabled    (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessageIfEnabled    (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageNoPara       (WM_HWIN hWin, int MsgId);
Xvoid    WM__SendMessageNoPara       (GUI_HWIN hWin, int MsgId);
Nvoid    WM__SendPIDMessage          (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendPIDMessage          (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint     WM__SetScrollbarH           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarH           (GUI_HWIN hWin, int OnOff);
Nint     WM__SetScrollbarV           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarV           (GUI_HWIN hWin, int OnOff);
Nvoid    WM__UpdateChildPositions    (WM_Obj * pObj, int dx0, int dy0, int dx1, int dy1);
Nvoid    WM_PID__GetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM_PID__SetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM__SendTouchMessage        (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendTouchMessage        (GUI_HWIN hWin, WM_MESSAGE * pMsg);
N
NU16     WM_GetFlags                 (WM_HWIN hWin);
Xunsigned short     WM_GetFlags                 (GUI_HWIN hWin);
Nint     WM__Paint                   (WM_HWIN hWin);
Xint     WM__Paint                   (GUI_HWIN hWin);
Nvoid    WM__Paint1                  (WM_HWIN hWin);
Xvoid    WM__Paint1                  (GUI_HWIN hWin);
Nvoid    WM__AddCriticalHandle       (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__RemoveCriticalHandle    (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__SetLastTouched          (WM_HWIN hWin);
Xvoid    WM__SetLastTouched          (GUI_HWIN hWin);
N
N#if WM_SUPPORT_STATIC_MEMDEV
X#if (1)
N  void    WM__InvalidateDrawAndDescs(WM_HWIN hWin);
X  void    WM__InvalidateDrawAndDescs(GUI_HWIN hWin);
N#else
S  #define WM__InvalidateDrawAndDescs(hWin)
N#endif
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if ((1))
N  typedef struct {
N    int xSize, ySize; // Size of bk window
N  } EFFECT_CONTEXT;
N
N  int  GUI_MEMDEV__CalcParaFadeIn    (int Period, int TimeUsed);
N  void GUI_MEMDEV__ClipBK            (EFFECT_CONTEXT * pContext);
N  void GUI_MEMDEV__RemoveStaticDevice(WM_HWIN hWin);
X  void GUI_MEMDEV__RemoveStaticDevice(GUI_HWIN hWin);
N  void GUI_MEMDEV__UndoClipBK        (EFFECT_CONTEXT * pContext);
N#endif
N
Nvoid WM__InvalidateParent(const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid WM__InvalidateParent(const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid WM__InvalidateRect  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop, U16 Flags);
Xvoid WM__InvalidateRect  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop, unsigned short Flags);
N
NWM_tfInvalidateParent   WM__SetInvalidateParentFunc(WM_tfInvalidateParent pfInvalidateParentFunc);
NWM_tfInvalidateDrawFunc WM__SetInvalidateDrawFunc  (WM_tfInvalidateDrawFunc pfInvalidateDrawFunc);
NWM_tfPaint1Func         WM__SetPaint1Func          (WM_tfPaint1Func pfPaint1Func);
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* WM_INTERN_H */
N
N/*************************** End of file ****************************/
L 62 "..\STemWin\inc\WIDGET.h" 2
N
N#if GUI_WINSUPPORT
X#if (1)
N
N/*********************************************************************
N*
N*       Typedefs
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN    hWin;
X  GUI_HWIN    hWin;
N  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
N  int        ItemIndex;
N  int        Col;
N  int        x0, y0, x1, y1;
N  void     * p;
N} WIDGET_ITEM_DRAW_INFO;
N
Ntypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Ntypedef void WIDGET_PAINT         (WM_HWIN hObj);
Xtypedef void WIDGET_PAINT         (GUI_HWIN hObj);
Ntypedef void WIDGET_CREATE        (WM_HWIN hObj);
Xtypedef void WIDGET_CREATE        (GUI_HWIN hObj);
N
Ntypedef struct {
N  WIDGET_PAINT  * pfPaint;
N  WIDGET_CREATE * pfCreate;
N  void          * pSkinPrivate;
N} WIDGET_SKIN;
N
N/*********************************************************************
N*
N*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
N*                  in SCROLLBAR.h!
N*
N**********************************************************************
N*/
N#include "SCROLLBAR.h"
L 1 "..\STemWin\inc\SCROLLBAR.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : SCROLLBAR.h
NPurpose     : SCROLLBAR include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef SCROLLBAR_H
N#define SCROLLBAR_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
L 1 "..\STemWin\inc\WIDGET.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
S#define WIDGET_H
S
S#if defined(__cplusplus)
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
S
S#if GUI_WINSUPPORT
S
S/*********************************************************************
S*
S*       Typedefs
S*
S**********************************************************************
S*/
Stypedef struct {
S  WM_HWIN    hWin;
S  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
S  int        ItemIndex;
S  int        Col;
S  int        x0, y0, x1, y1;
S  void     * p;
S} WIDGET_ITEM_DRAW_INFO;
S
Stypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Stypedef void WIDGET_PAINT         (WM_HWIN hObj);
Stypedef void WIDGET_CREATE        (WM_HWIN hObj);
S
Stypedef struct {
S  WIDGET_PAINT  * pfPaint;
S  WIDGET_CREATE * pfCreate;
S  void          * pSkinPrivate;
S} WIDGET_SKIN;
S
S/*********************************************************************
S*
S*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
S*                  in SCROLLBAR.h!
S*
S**********************************************************************
S*/
S#include "SCROLLBAR.h"
S
S/*********************************************************************
S*
S*       Defines
S*
S**********************************************************************
S*/
S/*********************************************************************
S*
S*       Unique widget id's
S*/
S#define BUTTON_ID    0x42555454UL /* BUTT */
S#define CHECKBOX_ID  0x43484543UL /* CHEC */
S#define DROPDOWN_ID  0x44524f50UL /* DROP */
S#define EDIT_ID      0x45444954UL /* EDIT */
S#define FRAMEWIN_ID  0x4652414dUL /* FRAM */
S#define FRAMECLNT_ID 0x46524143UL /* FRAC */
S#define GRAPH_ID     0x47524150UL /* GRAP */
S#define HEADER_ID    0x48454144UL /* HEAD */
S#define LISTBOX_ID   0x4C495342UL /* LISB */
S#define LISTVIEW_ID  0x4C495356UL /* LISV */
S#define LISTWHEEL_ID 0x4C495357UL /* LISW */
S#define MENU_ID      0x4d454e55UL /* MENU */
S#define MULTIEDIT_ID 0x4d554c45UL /* MULE */
S#define MULTIPAGE_ID 0x4d554c50UL /* MULP */
S#define MPAGECLNT_ID 0x4d50434CUL /* MPCL */
S#define PROGBAR_ID   0x50524f47UL /* PROG */
S#define RADIO_ID     0x52414449UL /* RADI */
S#define SCROLLBAR_ID 0x5343524fUL /* SCRO */
S#define SLIDER_ID    0x534c4944UL /* SLID */
S#define SWIPELIST_ID 0x53574950UL /* SWIP */
S#define TEXT_ID      0x54455854UL /* TEXT */
S#define TREEVIEW_ID  0x54524545UL /* TREE */
S#define ICONVIEW_ID  0x49434f4eUL /* ICON */
S#define IMAGE_ID     0x494d4147UL /* IMAG */
S#define SPINBOX_ID   0x5350494eUL /* SPIN */
S#define KNOB_ID      0x4b4e4f42UL /* KNOB */
S#define WINDOW_ID    0x57494e44UL /* WIND */
S
S#define WIDGET_LOCK(hWin)       ((WIDGET*)GUI_LOCK_H(hWin))
S
S/*********************************************************************
S*
S*       Config switches
S*/
S
S#ifndef   WIDGET_USE_PARENT_EFFECT
S  #define WIDGET_USE_PARENT_EFFECT 0
S#endif
S#ifndef   WIDGET_USE_FLEX_SKIN
S  #define WIDGET_USE_FLEX_SKIN     1
S#endif
S#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
S  #define WIDGET_USE_SCHEME_SMALL  1
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S#endif
S#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
S  #error Only one scheme can be selected!
S#endif
S
S/*********************************************************************
S*
S*       States
S*/
S
S#define WIDGET_STATE_FOCUS              (1 << 0)
S#define WIDGET_STATE_VERTICAL           (1 << 3)
S#define WIDGET_STATE_FOCUSSABLE         (1 << 4)
S
S#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
S
S/*********************************************************************
S*
S*       Skinning message identifiers
S*/
S#define WIDGET_ITEM_CREATE              0
S#define WIDGET_ITEM_DRAW                1
S#define WIDGET_ITEM_DRAW_ARROW          2
S#define WIDGET_ITEM_DRAW_ARROW_L        3
S#define WIDGET_ITEM_DRAW_ARROW_R        4
S#define WIDGET_ITEM_DRAW_BACKGROUND     5
S#define WIDGET_ITEM_DRAW_BITMAP         6
S#define WIDGET_ITEM_DRAW_BUTTON         7
S#define WIDGET_ITEM_DRAW_BUTTON_L       8
S#define WIDGET_ITEM_DRAW_BUTTON_R       9
S#define WIDGET_ITEM_DRAW_FOCUS         10
S#define WIDGET_ITEM_DRAW_FRAME         11
S#define WIDGET_ITEM_DRAW_OVERLAP       12
S#define WIDGET_ITEM_DRAW_OVERLAY       13
S#define WIDGET_ITEM_DRAW_SEP           14
S#define WIDGET_ITEM_DRAW_SHAFT         15
S#define WIDGET_ITEM_DRAW_SHAFT_L       16
S#define WIDGET_ITEM_DRAW_SHAFT_R       17
S#define WIDGET_ITEM_DRAW_TEXT          18
S#define WIDGET_ITEM_DRAW_THUMB         19
S#define WIDGET_ITEM_DRAW_TICKS         20
S#define WIDGET_ITEM_GET_BORDERSIZE_B   21
S#define WIDGET_ITEM_GET_BORDERSIZE_L   22
S#define WIDGET_ITEM_GET_BORDERSIZE_R   23
S#define WIDGET_ITEM_GET_BORDERSIZE_T   24
S#define WIDGET_ITEM_GET_BUTTONSIZE     25
S#define WIDGET_ITEM_GET_XSIZE          26
S#define WIDGET_ITEM_GET_YSIZE          27
S#define WIDGET_ITEM_GET_RADIUS         28
S#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
S                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
S
S#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY   
S#define WIDGET_DRAW_BACKGROUND WIDGET_ITEM_DRAW_BACKGROUND
S
S/*********************************************************************
S*
S*       Messages
S*/
S
S#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
S
S/*********************************************************************
S*
S*       Create flags
S*/
S
S#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
S
S/*********************************************************************
S*
S*        Widget object
S*
S* The widget object is the base class for most widgets
S*/
Stypedef struct {
S  int EffectSize;
S  void (* pfDrawUp)      (void);
S  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
S  void (* pfDrawDown)    (void);
S  void (* pfDrawDownRect)(const GUI_RECT * pRect);
S  void (* pfDrawFlat)    (void);
S  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
S} WIDGET_EFFECT;
S
Stypedef struct {
S  WM_Obj      Win;
S  const WIDGET_EFFECT* pEffect;
S  I16 Id;
S  U16 State;
S  #if GUI_DEBUG_LEVEL > 1
S    U32 DebugId;
S  #endif  
S} WIDGET;
S
S
S/*********************************************************************
S*
S*         GUI_DRAW
S*
S* The GUI_DRAW object is used as base class for selfdrawing,
S* non-windows objects. They are used as content of different widgets,
S* such as the bitmap or header widgets.
S*/
S/* Declare Object struct */
Stypedef struct GUI_DRAW GUI_DRAW;
Stypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Stypedef WM_HMEM GUI_DRAW_HANDLE;
S
S/* Declare Object constants (member functions etc)  */
Stypedef struct {
S  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
S  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
S  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
S} GUI_DRAW_CONSTS;
S
S/* Declare Object */
Sstruct GUI_DRAW {
S  const GUI_DRAW_CONSTS* pConsts;
S  union {
S    const void * pData;
S    GUI_DRAW_SELF_CB* pfDraw;
S  } Data;
S  I16 xOff, yOff;
S};
S
S/* GUI_DRAW_ API */
Svoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Sint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
S
S/* GUI_DRAW_ Constructurs for different objects */
SWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
SWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
S
S/*********************************************************************
S*
S*       Global data
S*
S**********************************************************************
S*/
S
Sextern const WIDGET_EFFECT WIDGET_Effect_3D;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Sextern const WIDGET_EFFECT WIDGET_Effect_None;
Sextern const WIDGET_EFFECT WIDGET_Effect_Simple;
S
S/*********************************************************************
S*
S*       Internal API routines
S*
S**********************************************************************
S*/
S
Svoid      WIDGET__DrawFocusRect      (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Svoid      WIDGET__DrawHLine          (WIDGET * pWidget, int y, int x0, int x1);
Svoid      WIDGET__DrawTriangle       (WIDGET * pWidget, int x, int y, int Size, int Inc);
Svoid      WIDGET__DrawVLine          (WIDGET * pWidget, int x, int y0, int y1);
Svoid      WIDGET__EFFECT_DrawDownRect(WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__EFFECT_DrawDown    (WIDGET * pWidget);
Svoid      WIDGET__EFFECT_DrawUpRect  (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__FillRectEx         (WIDGET * pWidget, const GUI_RECT * pRect);
Sint       WIDGET__GetWindowSizeX     (WM_HWIN hWin);
SGUI_COLOR WIDGET__GetBkColor         (WM_HWIN hObj);
Sint       WIDGET__GetXSize           (const WIDGET * pWidget);
Sint       WIDGET__GetYSize           (const WIDGET * pWidget);
Svoid      WIDGET__GetClientRect      (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__GetInsideRect      (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__Init               (WIDGET * pWidget, int Id, U16 State);
Svoid      WIDGET__RotateRect90       (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Svoid      WIDGET__SetScrollState     (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Svoid      WIDGET__FillStringInRect   (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
S
S/*********************************************************************
S*
S*       API routines
S*
S**********************************************************************
S*/
Svoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Svoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Svoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Sint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Sint   WIDGET_GetState     (WM_HWIN hObj);
Sint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
S
Svoid  WIDGET_EFFECT_3D_DrawUp(void);
S
Sconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
S
Svoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
S
Sconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
S
Svoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
S
SGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
S
Sint WIDGET_EFFECT_3D_GetNumColors(void);
Sint WIDGET_EFFECT_3D1L_GetNumColors(void);
Sint WIDGET_EFFECT_3D2L_GetNumColors(void);
Sint WIDGET_EFFECT_Simple_GetNumColors(void);
S
S/*********************************************************************
S*
S*       Compatibility macros
S*
S**********************************************************************
S*/
S#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
S#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
S#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
S#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
S#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
S
S#endif /* GUI_WINSUPPORT */
S
S#if defined(__cplusplus)
S  }
S#endif
S
N#endif   /* SLIDER_H */
N
N
N
N
L 60 "..\STemWin\inc\SCROLLBAR.h" 2
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define SCROLLBAR_CI_THUMB 0
N#define SCROLLBAR_CI_SHAFT 1
N#define SCROLLBAR_CI_ARROW 2
N
N/*********************************************************************
N*
N*       States
N*/
N#define SCROLLBAR_STATE_PRESSED   WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define SCROLLBAR_CF_VERTICAL     WIDGET_CF_VERTICAL
N#define SCROLLBAR_CF_FOCUSSABLE   WIDGET_STATE_FOCUSSABLE
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SCROLLBAR_SKINFLEX_PI_PRESSED   0
N#define SCROLLBAR_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SCROLLBAR_Handle;
Xtypedef signed long SCROLLBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR aColorShaft[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorGrasp;
N} SCROLLBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int State;
N} SCROLLBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateAttached(WM_HWIN hParent, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_CreateAttached(GUI_HWIN hParent, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SCROLLBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
Nvoid      SCROLLBAR_AddValue   (SCROLLBAR_Handle hObj, int Add);
Nvoid      SCROLLBAR_Dec        (SCROLLBAR_Handle hObj);
Nvoid      SCROLLBAR_Inc        (SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetUserData(SCROLLBAR_Handle hObj, void * pDest, int NumBytes);
NGUI_COLOR SCROLLBAR_SetColor   (SCROLLBAR_Handle hObj, int Index, GUI_COLOR Color);
Nvoid      SCROLLBAR_SetNumItems(SCROLLBAR_Handle hObj, int NumItems);
Nvoid      SCROLLBAR_SetPageSize(SCROLLBAR_Handle hObj, int PageSize);
Nvoid      SCROLLBAR_SetValue   (SCROLLBAR_Handle hObj, int v);
Nint       SCROLLBAR_SetWidth   (SCROLLBAR_Handle hObj, int Width);
Nvoid      SCROLLBAR_SetState   (SCROLLBAR_Handle hObj, const WM_SCROLL_STATE* pState);
Nint       SCROLLBAR_SetUserData(SCROLLBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SCROLLBAR_GetSkinFlexProps     (SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetSkinClassic       (SCROLLBAR_Handle hObj);
Nvoid SCROLLBAR_SetSkin              (SCROLLBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SCROLLBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SCROLLBAR_SetSkinFlexProps     (const SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SCROLLBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SCROLLBAR_SKIN_FLEX    SCROLLBAR_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetDefaultWidth(void);
NGUI_COLOR SCROLLBAR_SetDefaultColor(GUI_COLOR Color, unsigned int Index); /* Not yet documented */
Nint       SCROLLBAR_SetDefaultWidth(int DefaultWidth);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetThumbSizeMin(void);
Nint       SCROLLBAR_SetThumbSizeMin(int ThumbSizeMin);
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
Nint SCROLLBAR_GetNumItems(SCROLLBAR_Handle hObj);
Nint SCROLLBAR_GetPageSize(SCROLLBAR_Handle hObj);
Nint SCROLLBAR_GetValue   (SCROLLBAR_Handle hObj);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define SCROLLBAR_BKCOLOR0_DEFAULT SCROLLBAR_COLOR_ARROW_DEFAULT
N#define SCROLLBAR_BKCOLOR1_DEFAULT SCROLLBAR_COLOR_SHAFT_DEFAULT
N#define SCROLLBAR_COLOR0_DEFAULT   SCROLLBAR_COLOR_THUMB_DEFAULT
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SCROLLBAR_H
N
N/*************************** End of file ****************************/
L 98 "..\STemWin\inc\WIDGET.h" 2
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Unique widget id's
N*/
N#define BUTTON_ID    0x42555454UL /* BUTT */
N#define CHECKBOX_ID  0x43484543UL /* CHEC */
N#define DROPDOWN_ID  0x44524f50UL /* DROP */
N#define EDIT_ID      0x45444954UL /* EDIT */
N#define FRAMEWIN_ID  0x4652414dUL /* FRAM */
N#define FRAMECLNT_ID 0x46524143UL /* FRAC */
N#define GRAPH_ID     0x47524150UL /* GRAP */
N#define HEADER_ID    0x48454144UL /* HEAD */
N#define LISTBOX_ID   0x4C495342UL /* LISB */
N#define LISTVIEW_ID  0x4C495356UL /* LISV */
N#define LISTWHEEL_ID 0x4C495357UL /* LISW */
N#define MENU_ID      0x4d454e55UL /* MENU */
N#define MULTIEDIT_ID 0x4d554c45UL /* MULE */
N#define MULTIPAGE_ID 0x4d554c50UL /* MULP */
N#define MPAGECLNT_ID 0x4d50434CUL /* MPCL */
N#define PROGBAR_ID   0x50524f47UL /* PROG */
N#define RADIO_ID     0x52414449UL /* RADI */
N#define SCROLLBAR_ID 0x5343524fUL /* SCRO */
N#define SLIDER_ID    0x534c4944UL /* SLID */
N#define SWIPELIST_ID 0x53574950UL /* SWIP */
N#define TEXT_ID      0x54455854UL /* TEXT */
N#define TREEVIEW_ID  0x54524545UL /* TREE */
N#define ICONVIEW_ID  0x49434f4eUL /* ICON */
N#define IMAGE_ID     0x494d4147UL /* IMAG */
N#define SPINBOX_ID   0x5350494eUL /* SPIN */
N#define KNOB_ID      0x4b4e4f42UL /* KNOB */
N#define WINDOW_ID    0x57494e44UL /* WIND */
N
N#define WIDGET_LOCK(hWin)       ((WIDGET*)GUI_LOCK_H(hWin))
N
N/*********************************************************************
N*
N*       Config switches
N*/
N
N#ifndef   WIDGET_USE_PARENT_EFFECT
N  #define WIDGET_USE_PARENT_EFFECT 0
N#endif
N#ifndef   WIDGET_USE_FLEX_SKIN
N  #define WIDGET_USE_FLEX_SKIN     1
N#endif
N#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
X#if !0L && !0L && !0L
N  #define WIDGET_USE_SCHEME_SMALL  1
N  #define WIDGET_USE_SCHEME_MEDIUM 0
N  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
N#endif
N#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
X#if (1 + 0 + 0) > 1
S  #error Only one scheme can be selected!
N#endif
N
N/*********************************************************************
N*
N*       States
N*/
N
N#define WIDGET_STATE_FOCUS              (1 << 0)
N#define WIDGET_STATE_VERTICAL           (1 << 3)
N#define WIDGET_STATE_FOCUSSABLE         (1 << 4)
N
N#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
N
N/*********************************************************************
N*
N*       Skinning message identifiers
N*/
N#define WIDGET_ITEM_CREATE              0
N#define WIDGET_ITEM_DRAW                1
N#define WIDGET_ITEM_DRAW_ARROW          2
N#define WIDGET_ITEM_DRAW_ARROW_L        3
N#define WIDGET_ITEM_DRAW_ARROW_R        4
N#define WIDGET_ITEM_DRAW_BACKGROUND     5
N#define WIDGET_ITEM_DRAW_BITMAP         6
N#define WIDGET_ITEM_DRAW_BUTTON         7
N#define WIDGET_ITEM_DRAW_BUTTON_L       8
N#define WIDGET_ITEM_DRAW_BUTTON_R       9
N#define WIDGET_ITEM_DRAW_FOCUS         10
N#define WIDGET_ITEM_DRAW_FRAME         11
N#define WIDGET_ITEM_DRAW_OVERLAP       12
N#define WIDGET_ITEM_DRAW_OVERLAY       13
N#define WIDGET_ITEM_DRAW_SEP           14
N#define WIDGET_ITEM_DRAW_SHAFT         15
N#define WIDGET_ITEM_DRAW_SHAFT_L       16
N#define WIDGET_ITEM_DRAW_SHAFT_R       17
N#define WIDGET_ITEM_DRAW_TEXT          18
N#define WIDGET_ITEM_DRAW_THUMB         19
N#define WIDGET_ITEM_DRAW_TICKS         20
N#define WIDGET_ITEM_GET_BORDERSIZE_B   21
N#define WIDGET_ITEM_GET_BORDERSIZE_L   22
N#define WIDGET_ITEM_GET_BORDERSIZE_R   23
N#define WIDGET_ITEM_GET_BORDERSIZE_T   24
N#define WIDGET_ITEM_GET_BUTTONSIZE     25
N#define WIDGET_ITEM_GET_XSIZE          26
N#define WIDGET_ITEM_GET_YSIZE          27
N#define WIDGET_ITEM_GET_RADIUS         28
N#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
N                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
N
N#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY   
N#define WIDGET_DRAW_BACKGROUND WIDGET_ITEM_DRAW_BACKGROUND
N
N/*********************************************************************
N*
N*       Messages
N*/
N
N#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
N
N/*********************************************************************
N*
N*       Create flags
N*/
N
N#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
N
N/*********************************************************************
N*
N*        Widget object
N*
N* The widget object is the base class for most widgets
N*/
Ntypedef struct {
N  int EffectSize;
N  void (* pfDrawUp)      (void);
N  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
N  void (* pfDrawDown)    (void);
N  void (* pfDrawDownRect)(const GUI_RECT * pRect);
N  void (* pfDrawFlat)    (void);
N  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
N} WIDGET_EFFECT;
N
Ntypedef struct {
N  WM_Obj      Win;
N  const WIDGET_EFFECT* pEffect;
N  I16 Id;
X  signed short Id;
N  U16 State;
X  unsigned short State;
N  #if GUI_DEBUG_LEVEL > 1
X  #if 1 > 1
S    U32 DebugId;
N  #endif  
N} WIDGET;
N
N
N/*********************************************************************
N*
N*         GUI_DRAW
N*
N* The GUI_DRAW object is used as base class for selfdrawing,
N* non-windows objects. They are used as content of different widgets,
N* such as the bitmap or header widgets.
N*/
N/* Declare Object struct */
Ntypedef struct GUI_DRAW GUI_DRAW;
Ntypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Xtypedef void   GUI_DRAW_SELF_CB (GUI_HWIN hWin);
Ntypedef WM_HMEM GUI_DRAW_HANDLE;
Xtypedef signed long GUI_DRAW_HANDLE;
N
N/* Declare Object constants (member functions etc)  */
Ntypedef struct {
N  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
X  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
N  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
N  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
N} GUI_DRAW_CONSTS;
N
N/* Declare Object */
Nstruct GUI_DRAW {
N  const GUI_DRAW_CONSTS* pConsts;
N  union {
N    const void * pData;
N    GUI_DRAW_SELF_CB* pfDraw;
N  } Data;
N  I16 xOff, yOff;
X  signed short xOff, yOff;
N};
N
N/* GUI_DRAW_ API */
Nvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Xvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
Nint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
N
N/* GUI_DRAW_ Constructurs for different objects */
NWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
Xsigned long GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
Xsigned long GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
NWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Xsigned long GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
Xsigned long GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
N
Nextern const WIDGET_EFFECT WIDGET_Effect_3D;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Nextern const WIDGET_EFFECT WIDGET_Effect_None;
Nextern const WIDGET_EFFECT WIDGET_Effect_Simple;
N
N/*********************************************************************
N*
N*       Internal API routines
N*
N**********************************************************************
N*/
N
Nvoid      WIDGET__DrawFocusRect      (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Nvoid      WIDGET__DrawHLine          (WIDGET * pWidget, int y, int x0, int x1);
Nvoid      WIDGET__DrawTriangle       (WIDGET * pWidget, int x, int y, int Size, int Inc);
Nvoid      WIDGET__DrawVLine          (WIDGET * pWidget, int x, int y0, int y1);
Nvoid      WIDGET__EFFECT_DrawDownRect(WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__EFFECT_DrawDown    (WIDGET * pWidget);
Nvoid      WIDGET__EFFECT_DrawUpRect  (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__FillRectEx         (WIDGET * pWidget, const GUI_RECT * pRect);
Nint       WIDGET__GetWindowSizeX     (WM_HWIN hWin);
Xint       WIDGET__GetWindowSizeX     (GUI_HWIN hWin);
NGUI_COLOR WIDGET__GetBkColor         (WM_HWIN hObj);
XGUI_COLOR WIDGET__GetBkColor         (GUI_HWIN hObj);
Nint       WIDGET__GetXSize           (const WIDGET * pWidget);
Nint       WIDGET__GetYSize           (const WIDGET * pWidget);
Nvoid      WIDGET__GetClientRect      (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__GetInsideRect      (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__Init               (WIDGET * pWidget, int Id, U16 State);
Xvoid      WIDGET__Init               (WIDGET * pWidget, int Id, unsigned short State);
Nvoid      WIDGET__RotateRect90       (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Nvoid      WIDGET__SetScrollState     (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Xvoid      WIDGET__SetScrollState     (GUI_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Nvoid      WIDGET__FillStringInRect   (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
N
N/*********************************************************************
N*
N*       API routines
N*
N**********************************************************************
N*/
Nvoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_AndState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Xvoid  WIDGET_OrState      (GUI_HWIN hObj, int State);
Nint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Xint   WIDGET_HandleActive (GUI_HWIN hObj, WM_MESSAGE* pMsg);
Nint   WIDGET_GetState     (WM_HWIN hObj);
Xint   WIDGET_GetState     (GUI_HWIN hObj);
Nint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
Xint   WIDGET_SetWidth     (GUI_HWIN hObj, int Width);
N
Nvoid  WIDGET_EFFECT_3D_DrawUp(void);
N
Nconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
N
Nvoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
Xvoid  WIDGET_SetEffect              (GUI_HWIN hObj, const WIDGET_EFFECT* pEffect);
N
Nconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
N
Nvoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
N
NGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
N
Nint WIDGET_EFFECT_3D_GetNumColors(void);
Nint WIDGET_EFFECT_3D1L_GetNumColors(void);
Nint WIDGET_EFFECT_3D2L_GetNumColors(void);
Nint WIDGET_EFFECT_Simple_GetNumColors(void);
N
N/*********************************************************************
N*
N*       Compatibility macros
N*
N**********************************************************************
N*/
N#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
N#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
N#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
N#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
N#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
N
N#endif /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SLIDER_H */
N
N
N
N
L 60 "..\STemWin\inc\BUTTON.h" 2
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Create flags
N*/
N/* For compatibility only ! */
N#define BUTTON_CF_HIDE   WM_CF_HIDE
N#define BUTTON_CF_SHOW   WM_CF_SHOW
N#define BUTTON_CF_MEMDEV WM_CF_MEMDEV
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define BUTTON_CI_UNPRESSED 0
N#define BUTTON_CI_PRESSED   1
N#define BUTTON_CI_DISABLED  2
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define BUTTON_BI_UNPRESSED 0
N#define BUTTON_BI_PRESSED   1
N#define BUTTON_BI_DISABLED  2
N
N/*********************************************************************
N*
N*       States
N*/
N#define BUTTON_STATE_FOCUS      WIDGET_STATE_FOCUS
N#define BUTTON_STATE_PRESSED    WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define BUTTON_SKINFLEX_PI_PRESSED     0
N#define BUTTON_SKINFLEX_PI_FOCUSSED    1
N#define BUTTON_SKINFLEX_PI_ENABLED     2
N#define BUTTON_SKINFLEX_PI_DISABLED    3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM BUTTON_Handle;
Xtypedef signed long BUTTON_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  int Radius;
N} BUTTON_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
N
NBUTTON_Handle BUTTON_Create        (int x0, int y0, int xSize, int ySize, int ID, int Flags);
NBUTTON_Handle BUTTON_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XBUTTON_Handle BUTTON_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NBUTTON_Handle BUTTON_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XBUTTON_Handle BUTTON_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NBUTTON_Handle BUTTON_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XBUTTON_Handle BUTTON_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NBUTTON_Handle BUTTON_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XBUTTON_Handle BUTTON_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        BUTTON_GetDefaultBkColor   (unsigned Index);
Nconst GUI_FONT * BUTTON_GetDefaultFont      (void);
Nint              BUTTON_GetDefaultTextAlign (void);
NGUI_COLOR        BUTTON_GetDefaultTextColor (unsigned Index);
Nvoid             BUTTON_SetDefaultBkColor   (GUI_COLOR Color, unsigned Index);
NGUI_COLOR        BUTTON_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             BUTTON_SetDefaultFont      (const GUI_FONT * pFont);
Nvoid             BUTTON_SetDefaultTextAlign (int Align);
Nvoid             BUTTON_SetDefaultTextColor (GUI_COLOR Color, unsigned Index);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid BUTTON_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
NGUI_COLOR          BUTTON_GetBkColor         (BUTTON_Handle hObj, unsigned int Index);
Nconst GUI_BITMAP * BUTTON_GetBitmap(BUTTON_Handle hObj,unsigned int Index);
Nconst GUI_FONT   * BUTTON_GetFont  (BUTTON_Handle hObj);
NGUI_COLOR          BUTTON_GetFrameColor      (BUTTON_Handle hObj);
NWIDGET           * BUTTON_GetpWidget         (BUTTON_Handle hObj);
Nvoid               BUTTON_GetText            (BUTTON_Handle hObj, char * pBuffer, int MaxLen);
NGUI_COLOR          BUTTON_GetTextColor       (BUTTON_Handle hObj, unsigned int Index);
Nint                BUTTON_GetTextAlign       (BUTTON_Handle hObj);
Nint                BUTTON_GetUserData        (BUTTON_Handle hObj, void * pDest, int NumBytes);
Nunsigned           BUTTON_IsPressed          (BUTTON_Handle hObj);
Nvoid               BUTTON_SetBitmap          (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap);
Nvoid               BUTTON_SetBitmapEx        (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid               BUTTON_SetBkColor         (BUTTON_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid               BUTTON_SetBMP             (BUTTON_Handle hObj, unsigned int Index, const void * pBitmap);
Nvoid               BUTTON_SetBMPEx           (BUTTON_Handle hObj, unsigned int Index, const void * pBitmap, int x, int y);
Nvoid               BUTTON_SetFont            (BUTTON_Handle hObj, const GUI_FONT * pfont);
Nvoid               BUTTON_SetFrameColor      (BUTTON_Handle hObj, GUI_COLOR Color);
Nvoid               BUTTON_SetState           (BUTTON_Handle hObj, int State);                                    /* Not to be doc. */
Nvoid               BUTTON_SetPressed         (BUTTON_Handle hObj, int State);
NGUI_COLOR          BUTTON_SetFocusColor      (BUTTON_Handle hObj, GUI_COLOR Color);
Nvoid               BUTTON_SetFocussable      (BUTTON_Handle hObj, int State);
Nvoid               BUTTON_SetStreamedBitmap  (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap);
Nvoid               BUTTON_SetStreamedBitmapEx(BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Nint                BUTTON_SetText            (BUTTON_Handle hObj, const char* s);
Nvoid               BUTTON_SetTextAlign       (BUTTON_Handle hObj, int Align);
Nvoid               BUTTON_SetTextColor       (BUTTON_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid               BUTTON_SetTextOffset      (BUTTON_Handle hObj, int xPos, int yPos);
Nvoid               BUTTON_SetSelfDrawEx      (BUTTON_Handle hObj, unsigned int Index, GUI_DRAW_SELF_CB * pDraw, int x, int y); /* Not to be doc. */
Nvoid               BUTTON_SetSelfDraw        (BUTTON_Handle hObj, unsigned int Index, GUI_DRAW_SELF_CB * pDraw);               /* Not to be doc. */
Nvoid               BUTTON_SetReactOnLevel    (void);
Nvoid               BUTTON_SetReactOnTouch    (void);
Nint                BUTTON_SetUserData        (BUTTON_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid BUTTON_GetSkinFlexProps     (BUTTON_SKINFLEX_PROPS * pProps, int Index);
Nvoid BUTTON_SetSkinClassic       (BUTTON_Handle hObj);
Nvoid BUTTON_SetSkin              (BUTTON_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  BUTTON_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid BUTTON_SetSkinFlexProps     (const BUTTON_SKINFLEX_PROPS * pProps, int Index);
Nvoid BUTTON_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * BUTTON_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define BUTTON_SKIN_FLEX    BUTTON_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   // GUI_WINSUPPORT
N#endif   // BUTTON_H
N
N/*************************** End of file ****************************/
L 59 "..\STemWin\inc\DIALOG.h" 2
N#include "CALENDAR.h"
L 1 "..\STemWin\inc\CALENDAR.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : CALENDAR.h
NPurpose     : Message box interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef CALENDAR_H
N#define CALENDAR_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CALENDAR_CI_WEEKEND 0
N#define CALENDAR_CI_WEEKDAY 1
N#define CALENDAR_CI_SEL     2
N
N#define CALENDAR_CI_HEADER  3
N#define CALENDAR_CI_MONTH   4
N#define CALENDAR_CI_LABEL   5
N#define CALENDAR_CI_FRAME   6
N
N#define CALENDAR_FI_CONTENT 0
N#define CALENDAR_FI_HEADER  1
N
N#define CALENDAR_SI_HEADER  0
N#define CALENDAR_SI_CELL_X  1
N#define CALENDAR_SI_CELL_Y  2
N
N/*********************************************************************
N*
N*       Notification codes
N*
N* The following is the list of notification codes specific to this widget,
N* Send with the WM_NOTIFY_PARENT message
N*/
N#define CALENDAR_NOTIFICATION_MONTH_CLICKED  (WM_NOTIFICATION_WIDGET + 0)
N#define CALENDAR_NOTIFICATION_MONTH_RELEASED (WM_NOTIFICATION_WIDGET + 1)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CALENDAR_DATE
N*/
Ntypedef struct {
N  int Year;
N  int Month;
N  int Day;
N} CALENDAR_DATE;
N
N/*********************************************************************
N*
N*       CALENDAR_SKINFLEX_PROPS
N*/
Ntypedef struct {
N  GUI_COLOR aColorFrame[3]; // Frame colors of buttons
N  GUI_COLOR aColorUpper[2]; // Upper gradient colors of buttons
N  GUI_COLOR aColorLower[2]; // Lower gradient colors of buttons
N  GUI_COLOR ColorArrow;     // Arrow colors
N} CALENDAR_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
NWM_HWIN CALENDAR_Create           (WM_HWIN hParent, int xPos, int yPos, unsigned Year, unsigned Month, unsigned Day, unsigned FirstDayOfWeek, int Id, int Flags);
XGUI_HWIN CALENDAR_Create           (GUI_HWIN hParent, int xPos, int yPos, unsigned Year, unsigned Month, unsigned Day, unsigned FirstDayOfWeek, int Id, int Flags);
Nvoid    CALENDAR_GetDate          (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_GetDate          (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_GetSel           (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_GetSel           (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_SetDate          (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_SetDate          (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_SetSel           (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_SetSel           (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_ShowDate         (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_ShowDate         (GUI_HWIN hWin, CALENDAR_DATE * pDate);
N
N/*********************************************************************
N*
N*       Default related
N*/
Nvoid    CALENDAR_SetDefaultBkColor(unsigned Index, GUI_COLOR Color);
Nvoid    CALENDAR_SetDefaultColor  (unsigned Index, GUI_COLOR Color);
Nvoid    CALENDAR_SetDefaultDays   (const char ** apDays);
Nvoid    CALENDAR_SetDefaultFont   (unsigned Index, const GUI_FONT * pFont);
Nvoid    CALENDAR_SetDefaultMonths (const char ** apMonths);
Nvoid    CALENDAR_SetDefaultSize   (unsigned Index, unsigned Size);
N
N/*********************************************************************
N*
N*       Skinning related
N*/
Nvoid    CALENDAR_GetSkinFlexProps (CALENDAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid    CALENDAR_SetSkinFlexProps (const CALENDAR_SKINFLEX_PROPS * pProps, int Index);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CALENDAR_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif // GUI_WINSUPPORT
N#endif // CALENDAR_H
N
N/*************************** End of file ****************************/
L 60 "..\STemWin\inc\DIALOG.h" 2
N#include "CHECKBOX.h"
L 1 "..\STemWin\inc\CHECKBOX.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : CHECKBOX.h
NPurpose     : CHECKBOX include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef CHECKBOX_H
N#define CHECKBOX_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define CHECKBOX_CI_DISABLED 0
N#define CHECKBOX_CI_ENABLED  1
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define CHECKBOX_BI_INACTIV_UNCHECKED 0
N#define CHECKBOX_BI_ACTIV_UNCHECKED   1
N#define CHECKBOX_BI_INACTIV_CHECKED   2
N#define CHECKBOX_BI_ACTIV_CHECKED     3
N#define CHECKBOX_BI_INACTIV_3STATE    4
N#define CHECKBOX_BI_ACTIV_3STATE      5
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define CHECKBOX_SKINFLEX_PI_ENABLED     0
N#define CHECKBOX_SKINFLEX_PI_DISABLED    1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM CHECKBOX_Handle;
Xtypedef signed long CHECKBOX_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorInner[2];
N  GUI_COLOR ColorCheck;
N  int       ButtonSize;
N} CHECKBOX_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NCHECKBOX_Handle CHECKBOX_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XCHECKBOX_Handle CHECKBOX_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NCHECKBOX_Handle CHECKBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XCHECKBOX_Handle CHECKBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NCHECKBOX_Handle CHECKBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XCHECKBOX_Handle CHECKBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NCHECKBOX_Handle CHECKBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XCHECKBOX_Handle CHECKBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CHECKBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nint              CHECKBOX_GetDefaultAlign     (void);
NGUI_COLOR        CHECKBOX_GetDefaultBkColor   (void);
Nconst GUI_FONT * CHECKBOX_GetDefaultFont      (void);
Nint              CHECKBOX_GetDefaultSpacing   (void);
Nint              CHECKBOX_GetDefaultTextAlign (void);
NGUI_COLOR        CHECKBOX_GetDefaultTextColor (void);
Nint              CHECKBOX_GetUserData         (CHECKBOX_Handle hObj, void * pDest, int NumBytes);
Nvoid             CHECKBOX_SetDefaultAlign     (int Align);
Nvoid             CHECKBOX_SetDefaultBkColor   (GUI_COLOR Color);
NGUI_COLOR        CHECKBOX_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             CHECKBOX_SetDefaultFont      (const GUI_FONT * pFont);
Nvoid             CHECKBOX_SetDefaultImage     (const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid             CHECKBOX_SetDefaultSpacing   (int Spacing);
Nvoid             CHECKBOX_SetDefaultTextAlign (int Align);
Nvoid             CHECKBOX_SetDefaultTextColor (GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nint       CHECKBOX_GetState     (CHECKBOX_Handle hObj);
Nint       CHECKBOX_GetText      (CHECKBOX_Handle hObj, char * pBuffer, int MaxLen);
Nint       CHECKBOX_IsChecked    (CHECKBOX_Handle hObj);
Nvoid      CHECKBOX_SetBkColor   (CHECKBOX_Handle hObj, GUI_COLOR Color);
NGUI_COLOR CHECKBOX_SetBoxBkColor(CHECKBOX_Handle hObj, GUI_COLOR Color, int Index);
NGUI_COLOR CHECKBOX_SetFocusColor(CHECKBOX_Handle hObj, GUI_COLOR Color);
Nvoid      CHECKBOX_SetFont      (CHECKBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid      CHECKBOX_SetImage     (CHECKBOX_Handle hObj, const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid      CHECKBOX_SetNumStates (CHECKBOX_Handle hObj, unsigned NumStates);
Nvoid      CHECKBOX_SetSpacing   (CHECKBOX_Handle hObj, unsigned Spacing);
Nvoid      CHECKBOX_SetState     (CHECKBOX_Handle hObj, unsigned State);
Nvoid      CHECKBOX_SetText      (CHECKBOX_Handle hObj, const char * pText);
Nvoid      CHECKBOX_SetTextAlign (CHECKBOX_Handle hObj, int Align);
Nvoid      CHECKBOX_SetTextColor (CHECKBOX_Handle hObj, GUI_COLOR Color);
Nint       CHECKBOX_SetUserData  (CHECKBOX_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid CHECKBOX_GetSkinFlexProps      (CHECKBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid CHECKBOX_SetSkinClassic        (CHECKBOX_Handle hObj);
Nvoid CHECKBOX_SetSkin               (CHECKBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  CHECKBOX_DrawSkinFlex          (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid CHECKBOX_SetSkinFlexProps      (const CHECKBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid CHECKBOX_SetDefaultSkinClassic (void);
Nint  CHECKBOX_GetSkinFlexButtonSize (CHECKBOX_Handle hObj);
Nvoid CHECKBOX_SetSkinFlexButtonSize (CHECKBOX_Handle hObj, int ButtonSize);
NWIDGET_DRAW_ITEM_FUNC * CHECKBOX_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define CHECKBOX_SKIN_FLEX    CHECKBOX_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N
N#define CHECKBOX_Check(hObj)   CHECKBOX_SetState(hObj, 1)
N#define CHECKBOX_Uncheck(hObj) CHECKBOX_SetState(hObj, 0)
N
N#define CHECKBOX_BI_INACTIV    CHECKBOX_BI_INACTIV_CHECKED
N#define CHECKBOX_BI_ACTIV      CHECKBOX_BI_ACTIV_CHECKED
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // CHECKBOX_H
N
N/*************************** End of file ****************************/
L 61 "..\STemWin\inc\DIALOG.h" 2
N#include "CHOOSECOLOR.h"
L 1 "..\STemWin\inc\CHOOSECOLOR.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : CHOOSECOLOR.h
NPurpose     : Message box interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef CHOOSECOLOR_H
N#define CHOOSECOLOR_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CHOOSECOLOR_CF_MOVEABLE FRAMEWIN_CF_MOVEABLE
N
N#define CHOOSECOLOR_CI_FRAME 0
N#define CHOOSECOLOR_CI_FOCUS 1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CHOOSECOLOR_PROPS
N*/
Ntypedef struct {
N  unsigned  aBorder[2];
N  unsigned  aSpace[2];
N  unsigned  aButtonSize[2];
N  GUI_COLOR aColor[2];
N} CHOOSECOLOR_PROPS;
N
N/*********************************************************************
N*
N*       CHOOSECOLOR_CONTEXT
N*/
Ntypedef struct {
N  U32               LastColor;
X  unsigned long               LastColor;
N  const GUI_COLOR * pColor;
N  unsigned          NumColors;
N  unsigned          NumColorsPerLine;
N  int               SelOld;
N  int               Sel;
N  WM_HWIN           hParent;
X  GUI_HWIN           hParent;
N  CHOOSECOLOR_PROPS Props;
N} CHOOSECOLOR_CONTEXT;
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
NWM_HWIN CHOOSECOLOR_Create(WM_HWIN           hParent,
XGUI_HWIN CHOOSECOLOR_Create(GUI_HWIN           hParent,
N                           int               xPos,
N                           int               yPos,
N                           int               xSize,
N                           int               ySize,
N                           const GUI_COLOR * pColor,
N                           unsigned          NumColors,
N                           unsigned          NumColorsPerLine,
N                           int               Sel,
N                           const char      * sCaption,
N                           int               Flags);
N
Nint  CHOOSECOLOR_GetSel(WM_HWIN hObj);
Xint  CHOOSECOLOR_GetSel(GUI_HWIN hObj);
Nvoid CHOOSECOLOR_SetSel(WM_HWIN hObj, int Sel);
Xvoid CHOOSECOLOR_SetSel(GUI_HWIN hObj, int Sel);
N
Nvoid CHOOSECOLOR_SetDefaultColor     (unsigned Index, GUI_COLOR Color);
Nvoid CHOOSECOLOR_SetDefaultSpace     (unsigned Index, unsigned Space);
Nvoid CHOOSECOLOR_SetDefaultBorder    (unsigned Index, unsigned Border);
Nvoid CHOOSECOLOR_SetDefaultButtonSize(unsigned Index, unsigned ButtonSize);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CHOOSECOLOR_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* CHOOSECOLOR_H */
L 62 "..\STemWin\inc\DIALOG.h" 2
N#include "CHOOSEFILE.h"
L 1 "..\STemWin\inc\CHOOSEFILE.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : CHOOSEFILE.h
NPurpose     : File dialog interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef CHOOSEFILE_H
N#define CHOOSEFILE_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CHOOSEFILE_FINDFIRST 0
N#define CHOOSEFILE_FINDNEXT  1
N
N#define CHOOSEFILE_FLAG_DIRECTORY (1 << 0)
N
N#ifndef   CHOOSEFILE_MAXLEN
N  #define CHOOSEFILE_MAXLEN 256
N#endif
N
N#define CHOOSEFILE_BI_CANCEL 0
N#define CHOOSEFILE_BI_OK     1
N#define CHOOSEFILE_BI_UP     2
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CHOOSEFILE_INFO
N*/
Ntypedef struct CHOOSEFILE_INFO CHOOSEFILE_INFO;
N
Nstruct CHOOSEFILE_INFO {
N  int               Cmd;                                 // Command for GetData() function
N  int               Id;                                  // Id of pressed button (for internal use only)
N  const char      * pMask;                               // Mask to be used for searching files
N  char            * pName;                               // (for internal use only)
N  char            * pExt;                                // (for internal use only)
N  char            * pAttrib;                             // (for internal use only)
N  WM_TOOLTIP_HANDLE hToolTip;                            // (for internal use only)
N  U32               SizeL;                               // FileSize low word
X  unsigned long               SizeL;                               
N  U32               SizeH;                               // FileSize high word
X  unsigned long               SizeH;                               
N  U32               Flags;                               // File flags
X  unsigned long               Flags;                               
N  char              pRoot[CHOOSEFILE_MAXLEN];            // Buffer used internally and for passing result
X  char              pRoot[256];            
N  int            (* pfGetData)(CHOOSEFILE_INFO * pInfo); // Pointer to GetData() function
N};
N
N/*********************************************************************
N*
N*       Functions
N*
N**********************************************************************
N*/
NWM_HWIN CHOOSEFILE_Create(WM_HWIN           hParent,  // Parent window
XGUI_HWIN CHOOSEFILE_Create(GUI_HWIN           hParent,  
N                          int               xPos,     // xPosition in window coordinates
N                          int               yPos,     // yPosition in window coordinates
N                          int               xSize,    // xSize in pixels
N                          int               ySize,    // ySize in pixels
N                          const char      * apRoot[], // Pointers to root strings
N                          int               NumRoot,  // Number of roots
N                          int               SelRoot,  // Root to be selected at first
N                          const char      * sCaption, // Shown in title bar
N                          int               Flags,    // Flags for FRAMEWINDOW
N                          CHOOSEFILE_INFO * pInfo     // Pointer to CHOOSEFILE_INFO structure
N                          );
N
Nvoid    CHOOSEFILE_Callback            (WM_MESSAGE * pMsg);
Nvoid    CHOOSEFILE_EnableToolTips      (void);
Nvoid    CHOOSEFILE_SetButtonText       (WM_HWIN hWin, unsigned ButtonIndex, const char * pText);
Xvoid    CHOOSEFILE_SetButtonText       (GUI_HWIN hWin, unsigned ButtonIndex, const char * pText);
Nvoid    CHOOSEFILE_SetDefaultButtonText(unsigned ButtonIndex, const char * pText);
Nvoid    CHOOSEFILE_SetDelim            (char Delim);
Nvoid    CHOOSEFILE_SetToolTips         (const TOOLTIP_INFO * pInfo, int NumItems);
Nvoid    CHOOSEFILE_SetTopMode          (unsigned OnOff);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* CHOOSEFILE_H */
L 63 "..\STemWin\inc\DIALOG.h" 2
N#include "DROPDOWN.h"
L 1 "..\STemWin\inc\DROPDOWN.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : DROPDOWN.h
NPurpose     : Multiple choice object include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef DROPDOWN_H
N#define DROPDOWN_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "LISTBOX.h"
L 1 "..\STemWin\inc\LISTBOX.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : LISTBOX.h
NPurpose     : LISTBOX widget include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef LISTBOX_H
N#define LISTBOX_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N*/
N
N#define LISTBOX_ALL_ITEMS  -1
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define LISTBOX_CI_UNSEL    0
N#define LISTBOX_CI_SEL      1
N#define LISTBOX_CI_SELFOCUS 2
N#define LISTBOX_CI_DISABLED 3
N
N/************************************************************
N*
N*       States
N*/
Ntypedef WM_HMEM LISTBOX_Handle;
Xtypedef signed long LISTBOX_Handle;
N
N/*********************************************************************
N*
N*               Notification codes
N*
N* The following is the list of notification codes specific to this widget,
N* Send with the WM_NOTIFY_PARENT message
N*/
N#define LISTBOX_NOTIFICATION_LOST_FOCUS    (WM_NOTIFICATION_WIDGET + 0)
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define LISTBOX_CF_AUTOSCROLLBAR_H   (1<<0)
N#define LISTBOX_CF_AUTOSCROLLBAR_V   (1<<1)
N#define LISTBOX_CF_MULTISEL          (1<<2)
N#define LISTBOX_CF_WRAP              (1<<3)
N#define LISTBOX_SF_AUTOSCROLLBAR_H   LISTBOX_CF_AUTOSCROLLBAR_H
N#define LISTBOX_SF_AUTOSCROLLBAR_V   LISTBOX_CF_AUTOSCROLLBAR_V
N#define LISTBOX_SF_MULTISEL          LISTBOX_CF_MULTISEL
N#define LISTBOX_SF_WRAP              LISTBOX_CF_WRAP
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NLISTBOX_Handle LISTBOX_Create        (const GUI_ConstString * ppText, int x0, int y0, int xSize, int ySize, int Flags);
NLISTBOX_Handle LISTBOX_CreateAsChild (const GUI_ConstString * ppText, WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XLISTBOX_Handle LISTBOX_CreateAsChild (const GUI_ConstString * ppText, GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NLISTBOX_Handle LISTBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
XLISTBOX_Handle LISTBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
NLISTBOX_Handle LISTBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
XLISTBOX_Handle LISTBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
NLISTBOX_Handle LISTBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTBOX_Handle LISTBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nint          LISTBOX_AddKey          (LISTBOX_Handle hObj, int Key);
Nvoid         LISTBOX_AddString       (LISTBOX_Handle hObj, const char * s);
Nvoid         LISTBOX_AddStringH      (LISTBOX_Handle hObj, WM_HMEM hString); /* Not to be documented!!! */
Xvoid         LISTBOX_AddStringH      (LISTBOX_Handle hObj, signed long hString);  
Nvoid         LISTBOX_DecSel          (LISTBOX_Handle hObj);
Nvoid         LISTBOX_DeleteItem      (LISTBOX_Handle hObj, unsigned int Index);
Nvoid         LISTBOX_EnableWrapMode  (LISTBOX_Handle hObj, int OnOff);
Nunsigned     LISTBOX_GetItemSpacing  (LISTBOX_Handle hObj);
Nunsigned     LISTBOX_GetNumItems     (LISTBOX_Handle hObj);
Nint          LISTBOX_GetSel          (LISTBOX_Handle hObj);
Nconst GUI_FONT * LISTBOX_GetFont     (LISTBOX_Handle hObj);
Nint          LISTBOX_GetItemDisabled (LISTBOX_Handle hObj, unsigned Index);
Nint          LISTBOX_GetItemSel      (LISTBOX_Handle hObj, unsigned Index);
Nvoid         LISTBOX_GetItemText     (LISTBOX_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint          LISTBOX_GetMulti        (LISTBOX_Handle hObj);
Nint          LISTBOX_GetScrollStepH  (LISTBOX_Handle hObj);
Nint          LISTBOX_GetTextAlign    (LISTBOX_Handle hObj);
Nint          LISTBOX_GetUserData     (LISTBOX_Handle hObj, void * pDest, int NumBytes);
Nvoid         LISTBOX_IncSel          (LISTBOX_Handle hObj);
Nvoid         LISTBOX_InsertString    (LISTBOX_Handle hObj, const char * s, unsigned int Index);
Nvoid         LISTBOX_InvalidateItem  (LISTBOX_Handle hObj, int Index);
Nint          LISTBOX_OwnerDraw       (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid         LISTBOX_SetAutoScrollH  (LISTBOX_Handle hObj, int OnOff);
Nvoid         LISTBOX_SetAutoScrollV  (LISTBOX_Handle hObj, int OnOff);
Nvoid         LISTBOX_SetBkColor      (LISTBOX_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid         LISTBOX_SetFont         (LISTBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid         LISTBOX_SetItemDisabled (LISTBOX_Handle hObj, unsigned Index, int OnOff);
Nvoid         LISTBOX_SetItemSel      (LISTBOX_Handle hObj, unsigned Index, int OnOff);
Nvoid         LISTBOX_SetItemSpacing  (LISTBOX_Handle hObj, unsigned Value);
Nvoid         LISTBOX_SetMulti        (LISTBOX_Handle hObj, int Mode);
Nvoid         LISTBOX_SetOwner        (LISTBOX_Handle hObj, WM_HWIN hOwner);
Xvoid         LISTBOX_SetOwner        (LISTBOX_Handle hObj, GUI_HWIN hOwner);
Nvoid         LISTBOX_SetOwnerDraw    (LISTBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid         LISTBOX_SetScrollStepH  (LISTBOX_Handle hObj, int Value);
Nvoid         LISTBOX_SetSel          (LISTBOX_Handle hObj, int Sel);
Nvoid         LISTBOX_SetScrollbarColor(LISTBOX_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid         LISTBOX_SetScrollbarWidth(LISTBOX_Handle hObj, unsigned Width);
Nvoid         LISTBOX_SetString       (LISTBOX_Handle hObj, const char * s, unsigned int Index);
Nvoid         LISTBOX_SetText         (LISTBOX_Handle hObj, const GUI_ConstString * ppText);
Nvoid         LISTBOX_SetTextAlign    (LISTBOX_Handle hObj, int Align);
NGUI_COLOR    LISTBOX_SetTextColor    (LISTBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nint          LISTBOX_SetUserData     (LISTBOX_Handle hObj, const void * pSrc, int NumBytes);
Nint          LISTBOX_UpdateScrollers (LISTBOX_Handle hObj);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT * LISTBOX_GetDefaultFont(void);
Nint              LISTBOX_GetDefaultScrollStepH (void);
NGUI_COLOR        LISTBOX_GetDefaultBkColor     (unsigned Index);
Nint              LISTBOX_GetDefaultTextAlign   (void);
NGUI_COLOR        LISTBOX_GetDefaultTextColor   (unsigned Index);
Nvoid             LISTBOX_SetDefaultFont        (const GUI_FONT * pFont);
Nvoid             LISTBOX_SetDefaultScrollStepH (int Value);
Nvoid             LISTBOX_SetDefaultBkColor     (unsigned Index, GUI_COLOR Color);
Nvoid             LISTBOX_SetDefaultTextAlign   (int Align);
Nvoid             LISTBOX_SetDefaultTextColor   (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Compatibility to older versions
N*
N**********************************************************************
N*/
N
N#define LISTBOX_SetBackColor(hObj, Index, Color) LISTBOX_SetBkColor(hObj, Index, Color)
N#define LISTBOX_DeleteString  LISTBOX_DeleteItem
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTBOX_H
N
N/*************************** End of file ****************************/
L 60 "..\STemWin\inc\DROPDOWN.h" 2
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Create flags
N*/
N#define DROPDOWN_CF_AUTOSCROLLBAR   (1 << 0)
N#define DROPDOWN_CF_UP              (1 << 1)
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define DROPDOWN_CI_UNSEL    0
N#define DROPDOWN_CI_SEL      1
N#define DROPDOWN_CI_SELFOCUS 2
N
N#define DROPDOWN_CI_ARROW    0
N#define DROPDOWN_CI_BUTTON   1
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define DROPDOWN_SKINFLEX_PI_EXPANDED 0
N#define DROPDOWN_SKINFLEX_PI_FOCUSSED 1
N#define DROPDOWN_SKINFLEX_PI_ENABLED  2
N#define DROPDOWN_SKINFLEX_PI_DISABLED 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM DROPDOWN_Handle;
Xtypedef signed long DROPDOWN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorText;
N  GUI_COLOR ColorSep;
N  int Radius;
N} DROPDOWN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NDROPDOWN_Handle DROPDOWN_Create        (WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XDROPDOWN_Handle DROPDOWN_Create        (GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NDROPDOWN_Handle DROPDOWN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XDROPDOWN_Handle DROPDOWN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NDROPDOWN_Handle DROPDOWN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XDROPDOWN_Handle DROPDOWN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NDROPDOWN_Handle DROPDOWN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XDROPDOWN_Handle DROPDOWN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid DROPDOWN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid     DROPDOWN_AddKey           (DROPDOWN_Handle hObj, int Key);
Nvoid     DROPDOWN_AddString        (DROPDOWN_Handle hObj, const char* s);
Nvoid     DROPDOWN_Collapse         (DROPDOWN_Handle hObj);
Nvoid     DROPDOWN_DecSel           (DROPDOWN_Handle hObj);
Nvoid     DROPDOWN_DecSelExp        (DROPDOWN_Handle hObj);
Nvoid     DROPDOWN_DeleteItem       (DROPDOWN_Handle hObj, unsigned int Index);
Nvoid     DROPDOWN_Expand           (DROPDOWN_Handle hObj);
Nunsigned DROPDOWN_GetItemDisabled  (DROPDOWN_Handle hObj, unsigned Index);
Nunsigned DROPDOWN_GetItemSpacing   (DROPDOWN_Handle hObj);
Nint      DROPDOWN_GetItemText      (DROPDOWN_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
NLISTBOX_Handle DROPDOWN_GetListbox (DROPDOWN_Handle hObj);
Nint      DROPDOWN_GetNumItems      (DROPDOWN_Handle hObj);
Nint      DROPDOWN_GetSel           (DROPDOWN_Handle hObj);
Nint      DROPDOWN_GetSelExp        (DROPDOWN_Handle hObj);
Nint      DROPDOWN_GetUserData      (DROPDOWN_Handle hObj, void * pDest, int NumBytes);
Nvoid     DROPDOWN_IncSel           (DROPDOWN_Handle hObj);
Nvoid     DROPDOWN_IncSelExp        (DROPDOWN_Handle hObj);
Nvoid     DROPDOWN_InsertString     (DROPDOWN_Handle hObj, const char* s, unsigned int Index);
Nvoid     DROPDOWN_SetAutoScroll    (DROPDOWN_Handle hObj, int OnOff);
Nvoid     DROPDOWN_SetBkColor       (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid     DROPDOWN_SetColor         (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid     DROPDOWN_SetFont          (DROPDOWN_Handle hObj, const GUI_FONT * pfont);
Nvoid     DROPDOWN_SetItemDisabled  (DROPDOWN_Handle hObj, unsigned Index, int OnOff);
Nvoid     DROPDOWN_SetItemSpacing   (DROPDOWN_Handle hObj, unsigned Value);
Nint      DROPDOWN_SetListHeight    (DROPDOWN_Handle hObj, unsigned Height);
Nvoid     DROPDOWN_SetScrollbarColor(DROPDOWN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid     DROPDOWN_SetScrollbarWidth(DROPDOWN_Handle hObj, unsigned Width);
Nvoid     DROPDOWN_SetSel           (DROPDOWN_Handle hObj, int Sel);
Nvoid     DROPDOWN_SetSelExp        (DROPDOWN_Handle hObj, int Sel);
Nvoid     DROPDOWN_SetTextAlign     (DROPDOWN_Handle hObj, int Align);
Nvoid     DROPDOWN_SetTextColor     (DROPDOWN_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid     DROPDOWN_SetTextHeight    (DROPDOWN_Handle hObj, unsigned TextHeight);
Nint      DROPDOWN_SetUpMode        (DROPDOWN_Handle hObj, int OnOff);
Nint      DROPDOWN_SetUserData      (DROPDOWN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid DROPDOWN_GetSkinFlexProps     (DROPDOWN_SKINFLEX_PROPS * pProps, int Index);
Nvoid DROPDOWN_SetSkinClassic       (DROPDOWN_Handle hObj);
Nvoid DROPDOWN_SetSkin              (DROPDOWN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  DROPDOWN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid DROPDOWN_SetSkinFlexProps     (const DROPDOWN_SKINFLEX_PROPS * pProps, int Index);
Nvoid DROPDOWN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * DROPDOWN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define DROPDOWN_SKIN_FLEX    DROPDOWN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        DROPDOWN_GetDefaultBkColor       (int Index);
NGUI_COLOR        DROPDOWN_GetDefaultColor         (int Index);
Nconst GUI_FONT * DROPDOWN_GetDefaultFont          (void);
NGUI_COLOR        DROPDOWN_GetDefaultScrollbarColor(int Index);
Nvoid             DROPDOWN_SetDefaultFont          (const GUI_FONT * pFont);
NGUI_COLOR        DROPDOWN_SetDefaultBkColor       (int Index, GUI_COLOR Color);
NGUI_COLOR        DROPDOWN_SetDefaultColor         (int Index, GUI_COLOR Color);
NGUI_COLOR        DROPDOWN_SetDefaultScrollbarColor(int Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DROPDOWN_H
N
N/*************************** End of file ****************************/
L 64 "..\STemWin\inc\DIALOG.h" 2
N#include "EDIT.h"
L 1 "..\STemWin\inc\EDIT.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : EDIT.h
NPurpose     : EDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef EDIT_H
N#define EDIT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h" // Required for Create indirect data structure
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defaults for configuration switches
N*
N*  The following are defaults for config switches which affect the
N*  interface specified in this module
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Create / Status flags
N//
N#define EDIT_CF_LEFT    GUI_TA_LEFT
N#define EDIT_CF_RIGHT   GUI_TA_RIGHT
N#define EDIT_CF_HCENTER GUI_TA_HCENTER
N#define EDIT_CF_VCENTER GUI_TA_VCENTER
N#define EDIT_CF_TOP     GUI_TA_TOP
N#define EDIT_CF_BOTTOM  GUI_TA_BOTTOM
N
N//
N// Color indices
N//
N#define EDIT_CI_DISABLED 0
N#define EDIT_CI_ENABLED  1
N#define EDIT_CI_CURSOR   2
N
N//
N// Signed or normal mode
N//
N#define GUI_EDIT_NORMAL                  (0 << 0)
N#define GUI_EDIT_SIGNED                  (1 << 0)
N#define GUI_EDIT_SUPPRESS_LEADING_ZEROES (1 << 1)
N
N//
N// Cursor coloring
N//
N#define GUI_EDIT_SHOWCURSOR              (1 << 2)
N#define GUI_EDIT_CUSTCOLORMODE           (1 << 3)
N
N//
N// Edit modes
N//
N#define GUI_EDIT_MODE_INSERT    0
N#define GUI_EDIT_MODE_OVERWRITE 1
N
N//
N// Compatibility macros
N//
N#define EDIT_CI_DISABELD EDIT_CI_DISABLED
N#define EDIT_CI_ENABELD  EDIT_CI_ENABLED
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM EDIT_Handle;
Xtypedef signed long EDIT_Handle;
Ntypedef void tEDIT_AddKeyEx    (EDIT_Handle hObj, int Key);
Ntypedef void tEDIT_UpdateBuffer(EDIT_Handle hObj);
N
N/*********************************************************************
N*
N*             Create functions
N*/
NEDIT_Handle EDIT_Create        (int x0, int y0, int xSize, int ySize, int Id, int MaxLen, int Flags);
NEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int MaxLen);
XEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int MaxLen);
NEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen);
XEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen);
NEDIT_Handle EDIT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen, int NumExtraBytes);
XEDIT_Handle EDIT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen, int NumExtraBytes);
NEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid EDIT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nvoid EDIT_SetDefaultBkColor  (unsigned int Index, GUI_COLOR Color);
Nvoid EDIT_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid EDIT_SetDefaultTextAlign(int Align);
Nvoid EDIT_SetDefaultTextColor(unsigned int Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*             Individual member functions
N*/
N//
N// Query preferences
N//
NGUI_COLOR        EDIT_GetDefaultBkColor(unsigned int Index);
Nconst GUI_FONT * EDIT_GetDefaultFont(void);
Nint              EDIT_GetDefaultTextAlign(void);
NGUI_COLOR        EDIT_GetDefaultTextColor(unsigned int Index);
N//
N// Methods changing properties
N//
Nvoid EDIT_AddKey           (EDIT_Handle hObj, int Key);
Nvoid EDIT_EnableBlink      (EDIT_Handle hObj, int Period, int OnOff);
NGUI_COLOR EDIT_GetBkColor  (EDIT_Handle hObj, unsigned int Index);
Nvoid EDIT_SetBkColor       (EDIT_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid EDIT_SetCursorAtChar  (EDIT_Handle hObj, int Pos);
Nvoid EDIT_SetCursorAtPixel (EDIT_Handle hObj, int xPos);
Nvoid EDIT_SetFocussable    (EDIT_Handle hObj, int State);
Nvoid EDIT_SetFont          (EDIT_Handle hObj, const GUI_FONT * pFont);
Nint  EDIT_SetInsertMode    (EDIT_Handle hObj, int OnOff);
Nvoid EDIT_SetMaxLen        (EDIT_Handle hObj, int MaxLen);
Nvoid EDIT_SetpfAddKeyEx    (EDIT_Handle hObj, tEDIT_AddKeyEx * pfAddKeyEx);
Nvoid EDIT_SetpfUpdateBuffer(EDIT_Handle hObj, tEDIT_UpdateBuffer * pfUpdateBuffer);
Nvoid EDIT_SetText          (EDIT_Handle hObj, const char * s);
Nvoid EDIT_SetTextAlign     (EDIT_Handle hObj, int Align);
NGUI_COLOR EDIT_GetTextColor(EDIT_Handle hObj, unsigned int Index);
Nvoid EDIT_SetTextColor     (EDIT_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid EDIT_SetSel           (EDIT_Handle hObj, int FirstChar, int LastChar);
Nint  EDIT_SetUserData      (EDIT_Handle hObj, const void * pSrc, int NumBytes);
Nint  EDIT_EnableInversion  (EDIT_Handle hObj, int OnOff);
N//
N// Get/Set user input
N//
Nint   EDIT_GetCursorCharPos  (EDIT_Handle hObj);
Nvoid  EDIT_GetCursorPixelPos (EDIT_Handle hObj, int * pxPos, int * pyPos);
Nfloat EDIT_GetFloatValue     (EDIT_Handle hObj);
Nconst GUI_FONT * EDIT_GetFont(EDIT_Handle hObj);
Nint   EDIT_GetNumChars       (EDIT_Handle hObj);
Nvoid  EDIT_GetText           (EDIT_Handle hObj, char * sDest, int MaxLen);
NI32   EDIT_GetValue          (EDIT_Handle hObj);
Xsigned long   EDIT_GetValue          (EDIT_Handle hObj);
Nvoid  EDIT_SetFloatValue     (EDIT_Handle hObj, float Value);
Nint   EDIT_GetUserData       (EDIT_Handle hObj, void * pDest, int NumBytes);
Nvoid  EDIT_SetValue          (EDIT_Handle hObj, I32 Value);
Xvoid  EDIT_SetValue          (EDIT_Handle hObj, signed long Value);
N
N/*********************************************************************
N*
N*             Routines for editing values
N*
N**********************************************************************
N*/
Nvoid  EDIT_SetHexMode  (EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetHexMode  (EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetBinMode  (EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetBinMode  (EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetDecMode  (EDIT_Handle hEdit, I32 Value, I32 Min, I32 Max, int Shift, U8 Flags);
Xvoid  EDIT_SetDecMode  (EDIT_Handle hEdit, signed long Value, signed long Min, signed long Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, U8 Flags);
Xvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetTextMode (EDIT_Handle hEdit);
Nvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
N
NU32   GUI_EditHex      (U32 Value, U32 Min, U32 Max, int Len, int xSize);
Xunsigned long   GUI_EditHex      (unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xSize);
NU32   GUI_EditBin      (U32 Value, U32 Min, U32 Max, int Len, int xSize);
Xunsigned long   GUI_EditBin      (unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xSize);
NI32   GUI_EditDec      (I32 Value, I32 Min, I32 Max, int Len, int xSize, int Shift, U8 Flags);
Xsigned long   GUI_EditDec      (signed long Value, signed long Min, signed long Max, int Len, int xSize, int Shift, unsigned char Flags);
Nfloat GUI_EditFloat    (float Value, float Min, float Max, int Len, int xSize, int Shift, U8 Flags);
Xfloat GUI_EditFloat    (float Value, float Min, float Max, int Len, int xSize, int Shift, unsigned char Flags);
Nvoid  GUI_EditString   (char * pString, int Len, int xSize);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // EDIT_H
N
N/*************************** End of file ****************************/
L 65 "..\STemWin\inc\DIALOG.h" 2
N#include "FRAMEWIN.h"
L 1 "..\STemWin\inc\FRAMEWIN.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : FRAMEWIN.h
NPurpose     : Frame window include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef FRAMEWIN_H
N#define FRAMEWIN_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
N#if GUI_WINSUPPORT
X#if (1)
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Configuration
N*/
N#ifndef   FRAMEWIN_ALLOW_DRAG_ON_FRAME
N  #define FRAMEWIN_ALLOW_DRAG_ON_FRAME 1
N#endif
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define FRAMEWIN_CI_INACTIVE 0
N#define FRAMEWIN_CI_ACTIVE   1
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define FRAMEWIN_CF_ACTIVE     (1<<3)
N#define FRAMEWIN_CF_MOVEABLE   (1<<4)
N#define FRAMEWIN_CF_TITLEVIS   (1<<5)
N#define FRAMEWIN_CF_MINIMIZED  (1<<6)
N#define FRAMEWIN_CF_MAXIMIZED  (1<<7)
N#define FRAMEWIN_CF_DRAGGING   (1<<8)
N
N#define FRAMEWIN_SF_ACTIVE     FRAMEWIN_CF_ACTIVE
N#define FRAMEWIN_SF_MOVEABLE   FRAMEWIN_CF_MOVEABLE
N#define FRAMEWIN_SF_TITLEVIS   FRAMEWIN_CF_TITLEVIS
N#define FRAMEWIN_SF_MINIMIZED  FRAMEWIN_CF_MINIMIZED
N#define FRAMEWIN_SF_MAXIMIZED  FRAMEWIN_CF_MAXIMIZED
N#define FRAMEWIN_SF_DRAGGING   FRAMEWIN_CF_DRAGGING
N
N/*********************************************************************
N*
N*       BUTTON Flags
N*/
N#define FRAMEWIN_BUTTON_RIGHT   (1<<0)
N#define FRAMEWIN_BUTTON_LEFT    (1<<1)
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define FRAMEWIN_SKINFLEX_PI_ACTIVE   0
N#define FRAMEWIN_SKINFLEX_PI_INACTIVE 1
N
N/*********************************************************************
N*
N*       Getting border size
N*/
N#define FRAMEWIN_BORDERSIZE_T 0
N#define FRAMEWIN_BORDERSIZE_L 1
N#define FRAMEWIN_BORDERSIZE_B 2
N#define FRAMEWIN_BORDERSIZE_R 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM FRAMEWIN_Handle;
Xtypedef signed long FRAMEWIN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorTitle[2];
N  int Radius;
N  int SpaceX;
N  int BorderSizeL;
N  int BorderSizeR;
N  int BorderSizeT;
N  int BorderSizeB;
N} FRAMEWIN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NFRAMEWIN_Handle FRAMEWIN_Create        (const char * pTitle, WM_CALLBACK * cb, int Flags, int x0, int y0, int xSize, int ySize);
NFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
XFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
NFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
NFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
XFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
NFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid FRAMEWIN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions: Set Properties
N*
N**********************************************************************
N*/
NWM_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
XGUI_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
NWM_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
NWM_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, WM_HWIN hMenu);
Xvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, GUI_HWIN hMenu);
NWM_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_Minimize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Maximize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Restore       (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_SetActive     (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetBarColor   (FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetBorderSize (FRAMEWIN_Handle hObj, unsigned Size);
Nvoid    FRAMEWIN_SetClientColor(FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetFont       (FRAMEWIN_Handle hObj, const GUI_FONT * pFont);
Nvoid    FRAMEWIN_SetMoveable   (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetOwnerDraw  (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid    FRAMEWIN_SetResizeable (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetText       (FRAMEWIN_Handle hObj, const char* s);
Nvoid    FRAMEWIN_SetTextAlign  (FRAMEWIN_Handle hObj, int Align);
Nvoid    FRAMEWIN_SetTextColor  (FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTextColorEx(FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTitleVis   (FRAMEWIN_Handle hObj, int Show);
Nint     FRAMEWIN_SetTitleHeight(FRAMEWIN_Handle hObj, int Height);
Nint     FRAMEWIN_SetUserData   (FRAMEWIN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid FRAMEWIN_GetSkinFlexProps     (FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetSkinClassic       (FRAMEWIN_Handle hObj);
Nvoid FRAMEWIN_SetSkin              (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  FRAMEWIN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid FRAMEWIN_SetSkinFlexProps     (const FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * FRAMEWIN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define FRAMEWIN_SKIN_FLEX    FRAMEWIN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Member functions: Get Properties
N*
N**********************************************************************
N*/
Nconst GUI_FONT * FRAMEWIN_GetFont(FRAMEWIN_Handle hObj);
N
Nint       FRAMEWIN_GetActive      (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetTitleHeight (FRAMEWIN_Handle hObj);
NGUI_COLOR FRAMEWIN_GetBarColor    (FRAMEWIN_Handle hObj, unsigned Index);
Nint       FRAMEWIN_GetBorderSize  (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetBorderSizeEx(FRAMEWIN_Handle hObj, unsigned Edge);
Nvoid      FRAMEWIN_GetText        (FRAMEWIN_Handle hObj, char * pBuffer, int MaxLen);
Nint       FRAMEWIN_GetTextAlign   (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetUserData    (FRAMEWIN_Handle hObj, void * pDest, int NumBytes);
Nint       FRAMEWIN_IsMinimized    (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_IsMaximized    (FRAMEWIN_Handle hObj);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        FRAMEWIN_GetDefaultBarColor   (unsigned Index);
Nint              FRAMEWIN_GetDefaultBorderSize (void);
Nint              FRAMEWIN_GetDefaultTitleHeight(void);
NGUI_COLOR        FRAMEWIN_GetDefaultClientColor(void);
Nconst GUI_FONT * FRAMEWIN_GetDefaultFont       (void);
NGUI_COLOR        FRAMEWIN_GetDefaultTextColor  (unsigned Index);
Nint              FRAMEWIN_OwnerDraw            (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid             FRAMEWIN_SetDefaultBarColor   (unsigned Index, GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultBorderSize (int DefaultBorderSize);
Nvoid             FRAMEWIN_SetDefaultTitleHeight(int DefaultTitleHeight);
Nvoid             FRAMEWIN_SetDefaultClientColor(GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultFont       (const GUI_FONT * pFont);
Nint              FRAMEWIN_SetDefaultTextAlign  (int TextAlign);
Nvoid             FRAMEWIN_SetDefaultTextColor  (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define         FRAMEWIN_SetDefaultCaptionSize(Height)       FRAMEWIN_SetDefaultTitleHeight(Height)
N#define         FRAMEWIN_GetDefaultCaptionSize()             FRAMEWIN_GetDefaultTitleHeight()
N#define         FRAMEWIN_CreateButton(hObj, Flags, Off, Id)  FRAMEWIN_AddButton(hObj, Flags, Off, Id) 
N#define         FRAMEWIN_CreateCloseButton(hObj, Flags, Off) FRAMEWIN_AddCloseButton(hObj, Flags, Off)
N#define         FRAMEWIN_CreateMaxButton(hObj, Flags, Off)   FRAMEWIN_AddMaxButton(hObj, Flags, Off)  
N#define         FRAMEWIN_CreateMinButton(hObj, Flags, Off)   FRAMEWIN_AddMinButton(hObj, Flags, Off)  
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // FRAMEWIN_H
N
N/*************************** End of file ****************************/
L 66 "..\STemWin\inc\DIALOG.h" 2
N#include "GRAPH.h"
L 1 "..\STemWin\inc\GRAPH.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : GRAPH.h
NPurpose     : GRAPH include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef GRAPH_H
N#define GRAPH_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define GRAPH_CI_BK                  0
N#define GRAPH_CI_BORDER              1
N#define GRAPH_CI_FRAME               2
N#define GRAPH_CI_GRID                3
N
N#define GRAPH_SCALE_CF_HORIZONTAL    (0 << 0)
N#define GRAPH_SCALE_CF_VERTICAL      (1 << 0)
N
N#define GRAPH_SCALE_SF_HORIZONTAL    GRAPH_SCALE_CF_HORIZONTAL
N#define GRAPH_SCALE_SF_VERTICAL      GRAPH_SCALE_CF_VERTICAL
N
N#define GRAPH_DRAW_FIRST             0
N#define GRAPH_DRAW_AFTER_BORDER      1
N#define GRAPH_DRAW_LAST              2
N
N#define GRAPH_ALIGN_RIGHT            (0 << 0)
N#define GRAPH_ALIGN_LEFT             (1 << 0)
N
N//
N// Creation flags (ExFlags)
N//
N#define GRAPH_CF_GRID_FIXED_X        (1 << 0)
N#define GRAPH_CF_AVOID_SCROLLBAR_H   (1 << 1)
N#define GRAPH_CF_AVOID_SCROLLBAR_V   (1 << 2)
N
N//
N// Status flags
N//
N#define GRAPH_SF_AVOID_SCROLLBAR_H   GRAPH_CF_AVOID_SCROLLBAR_H
N#define GRAPH_SF_AVOID_SCROLLBAR_V   GRAPH_CF_AVOID_SCROLLBAR_V
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM GRAPH_Handle;
Xtypedef signed long GRAPH_Handle;
Ntypedef WM_HMEM GRAPH_DATA_Handle;
Xtypedef signed long GRAPH_DATA_Handle;
Ntypedef WM_HMEM GRAPH_SCALE_Handle;
Xtypedef signed long GRAPH_SCALE_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NGRAPH_Handle GRAPH_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XGRAPH_Handle GRAPH_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NGRAPH_Handle GRAPH_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XGRAPH_Handle GRAPH_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NGRAPH_Handle GRAPH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGRAPH_Handle GRAPH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
NGRAPH_DATA_Handle  GRAPH_DATA_XY_Create(GUI_COLOR Color, unsigned MaxNumItems, GUI_POINT * pData, unsigned NumItems);
NGRAPH_DATA_Handle  GRAPH_DATA_YT_Create(GUI_COLOR Color, unsigned MaxNumItems, I16 * pData, unsigned NumItems);
XGRAPH_DATA_Handle  GRAPH_DATA_YT_Create(GUI_COLOR Color, unsigned MaxNumItems, signed short * pData, unsigned NumItems);
NGRAPH_SCALE_Handle GRAPH_SCALE_Create  (int Pos, int TextAlign, unsigned Flags, unsigned TickDist);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid GRAPH_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      GRAPH_AttachData             (GRAPH_Handle hObj, GRAPH_DATA_Handle hData);
Nvoid      GRAPH_AttachScale            (GRAPH_Handle hObj, GRAPH_SCALE_Handle hScale);
Nvoid      GRAPH_DetachData             (GRAPH_Handle hObj, GRAPH_DATA_Handle hData);
Nvoid      GRAPH_DetachScale            (GRAPH_Handle hObj, GRAPH_SCALE_Handle hScale);
NI32       GRAPH_GetScrollValue         (GRAPH_Handle hObj, U8 Coord);
Xsigned long       GRAPH_GetScrollValue         (GRAPH_Handle hObj, unsigned char Coord);
Nint       GRAPH_GetUserData            (GRAPH_Handle hObj, void * pDest, int NumBytes);
Nvoid      GRAPH_SetAutoScrollbar       (GRAPH_Handle hObj, U8 Coord, U8 OnOff);
Xvoid      GRAPH_SetAutoScrollbar       (GRAPH_Handle hObj, unsigned char Coord, unsigned char OnOff);
Nvoid      GRAPH_SetBorder              (GRAPH_Handle hObj, unsigned BorderL, unsigned BorderT, unsigned BorderR, unsigned BorderB);
NGUI_COLOR GRAPH_SetColor               (GRAPH_Handle hObj, GUI_COLOR Color, unsigned Index);
Nunsigned  GRAPH_SetGridFixedX          (GRAPH_Handle hObj, unsigned OnOff);
Nunsigned  GRAPH_SetGridOffY            (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridVis             (GRAPH_Handle hObj, unsigned OnOff);
Nunsigned  GRAPH_SetGridDistX           (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridDistY           (GRAPH_Handle hObj, unsigned Value);
NU8        GRAPH_SetLineStyleH          (GRAPH_Handle hObj, U8 Value);
Xunsigned char        GRAPH_SetLineStyleH          (GRAPH_Handle hObj, unsigned char Value);
NU8        GRAPH_SetLineStyleV          (GRAPH_Handle hObj, U8 Value);
Xunsigned char        GRAPH_SetLineStyleV          (GRAPH_Handle hObj, unsigned char Value);
Nvoid      GRAPH_SetLineStyle           (GRAPH_Handle hObj, U8 Value);
Xvoid      GRAPH_SetLineStyle           (GRAPH_Handle hObj, unsigned char Value);
Nvoid      GRAPH_SetScrollValue         (GRAPH_Handle hObj, U8 Coord, U32 Value);
Xvoid      GRAPH_SetScrollValue         (GRAPH_Handle hObj, unsigned char Coord, unsigned long Value);
Nunsigned  GRAPH_SetVSizeX              (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetVSizeY              (GRAPH_Handle hObj, unsigned Value);
Nint       GRAPH_SetUserData            (GRAPH_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      GRAPH_SetUserDraw            (GRAPH_Handle hObj, void (* pOwnerDraw)(WM_HWIN, int));
Xvoid      GRAPH_SetUserDraw            (GRAPH_Handle hObj, void (* pOwnerDraw)(GUI_HWIN, int));
N
Nvoid      GRAPH_DATA_YT_AddValue       (GRAPH_DATA_Handle hDataObj, I16 Value);
Xvoid      GRAPH_DATA_YT_AddValue       (GRAPH_DATA_Handle hDataObj, signed short Value);
Nvoid      GRAPH_DATA_YT_Clear          (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_YT_Delete         (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_YT_SetAlign       (GRAPH_DATA_Handle hDataObj, int Align);
Nvoid      GRAPH_DATA_YT_SetOffY        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_YT_MirrorX        (GRAPH_DATA_Handle hDataObj, int OnOff);
N
Nvoid      GRAPH_DATA_XY_AddPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint);
Nvoid      GRAPH_DATA_XY_Clear          (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_XY_Delete         (GRAPH_DATA_Handle hDataObj);
Nunsigned  GRAPH_DATA_XY_GetLineVis     (GRAPH_DATA_Handle hDataObj);
Nunsigned  GRAPH_DATA_XY_GetPointVis    (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_XY_SetLineStyle   (GRAPH_DATA_Handle hDataObj, U8 LineStyle);
Xvoid      GRAPH_DATA_XY_SetLineStyle   (GRAPH_DATA_Handle hDataObj, unsigned char LineStyle);
Nunsigned  GRAPH_DATA_XY_SetLineVis     (GRAPH_DATA_Handle hDataObj, unsigned OnOff);
Nvoid      GRAPH_DATA_XY_SetOffX        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_XY_SetOffY        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_XY_SetPenSize     (GRAPH_DATA_Handle hDataObj, U8 PenSize);
Xvoid      GRAPH_DATA_XY_SetPenSize     (GRAPH_DATA_Handle hDataObj, unsigned char PenSize);
Nvoid      GRAPH_DATA_XY_SetPointSize   (GRAPH_DATA_Handle hDataObj, unsigned PointSize);
Nunsigned  GRAPH_DATA_XY_SetPointVis    (GRAPH_DATA_Handle hDataObj, unsigned OnOff);
Nvoid      GRAPH_DATA_XY_SetOwnerDraw   (GRAPH_DATA_Handle hDataObj, WIDGET_DRAW_ITEM_FUNC * pOwnerDraw);
N
Nvoid             GRAPH_SCALE_Delete      (GRAPH_SCALE_Handle hScaleObj);
Nfloat            GRAPH_SCALE_SetFactor   (GRAPH_SCALE_Handle hScaleObj, float Factor);
Nconst GUI_FONT * GRAPH_SCALE_SetFont     (GRAPH_SCALE_Handle hScaleObj, const GUI_FONT * pFont);
Nint              GRAPH_SCALE_SetNumDecs  (GRAPH_SCALE_Handle hScaleObj, int NumDecs);
Nint              GRAPH_SCALE_SetOff      (GRAPH_SCALE_Handle hScaleObj, int Off);
Nint              GRAPH_SCALE_SetPos      (GRAPH_SCALE_Handle hScaleObj, int Pos);
NGUI_COLOR        GRAPH_SCALE_SetTextColor(GRAPH_SCALE_Handle hScaleObj, GUI_COLOR Color);
Nunsigned         GRAPH_SCALE_SetTickDist (GRAPH_SCALE_Handle hScaleObj, unsigned Value);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // GRAPH_H
N
N/*************************** End of file ****************************/
L 67 "..\STemWin\inc\DIALOG.h" 2
N#include "HEADER.h"
L 1 "..\STemWin\inc\HEADER.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : HEADER.h
NPurpose     : HEADER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef HEADER_H
N#define HEADER_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM HEADER_Handle;
Xtypedef signed long HEADER_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR ColorArrow;
N} HEADER_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NHEADER_Handle HEADER_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XHEADER_Handle HEADER_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NHEADER_Handle HEADER_CreateAttached(WM_HWIN hParent, int Id, int SpecialFlags);
XHEADER_Handle HEADER_CreateAttached(GUI_HWIN hParent, int Id, int SpecialFlags);
NHEADER_Handle HEADER_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XHEADER_Handle HEADER_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NHEADER_Handle HEADER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XHEADER_Handle HEADER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NHEADER_Handle HEADER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XHEADER_Handle HEADER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid HEADER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N/* Set defaults */
NGUI_COLOR          HEADER_SetDefaultArrowColor(GUI_COLOR Color);
NGUI_COLOR          HEADER_SetDefaultBkColor   (GUI_COLOR Color);
Nconst GUI_CURSOR * HEADER_SetDefaultCursor    (const GUI_CURSOR * pCursor);
Nconst GUI_FONT *   HEADER_SetDefaultFont      (const GUI_FONT * pFont);
Nint                HEADER_SetDefaultBorderH   (int Spacing);
Nint                HEADER_SetDefaultBorderV   (int Spacing);
NGUI_COLOR          HEADER_SetDefaultTextColor (GUI_COLOR Color);
N
N/* Get defaults */
NGUI_COLOR          HEADER_GetDefaultArrowColor(void);
NGUI_COLOR          HEADER_GetDefaultBkColor   (void);
Nconst GUI_CURSOR * HEADER_GetDefaultCursor    (void);
Nconst GUI_FONT *   HEADER_GetDefaultFont      (void);
Nint                HEADER_GetDefaultBorderH   (void);
Nint                HEADER_GetDefaultBorderV   (void);
NGUI_COLOR          HEADER_GetDefaultTextColor (void);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      HEADER_AddItem            (HEADER_Handle hObj, int Width, const char * s, int Align);
Nvoid      HEADER_DeleteItem         (HEADER_Handle hObj, unsigned Index);
NGUI_COLOR HEADER_GetArrowColor      (HEADER_Handle hObj);
NGUI_COLOR HEADER_GetBkColor         (HEADER_Handle hObj);
Nint       HEADER_GetHeight          (HEADER_Handle hObj);
Nint       HEADER_GetItemWidth       (HEADER_Handle hObj, unsigned int Index);
Nint       HEADER_GetNumItems        (HEADER_Handle hObj);
Nint       HEADER_GetSel             (HEADER_Handle hObj);
NGUI_COLOR HEADER_GetTextColor       (HEADER_Handle hObj);
Nint       HEADER_GetUserData        (HEADER_Handle hObj, void * pDest, int NumBytes);
Nvoid      HEADER_SetArrowColor      (HEADER_Handle hObj, GUI_COLOR Color);
Nvoid      HEADER_SetBitmap          (HEADER_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap);
Nvoid      HEADER_SetBitmapEx        (HEADER_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid      HEADER_SetBkColor         (HEADER_Handle hObj, GUI_COLOR Color);
Nvoid      HEADER_SetBMP             (HEADER_Handle hObj, unsigned int Index, const void * pBitmap);
Nvoid      HEADER_SetBMPEx           (HEADER_Handle hObj, unsigned int Index, const void * pBitmap, int x, int y);
Nvoid      HEADER_SetDirIndicator    (HEADER_Handle hObj, int Column, int Reverse); /* !!!Not to be documented!!! */
Nvoid      HEADER_SetDragLimit       (HEADER_Handle hObj, unsigned DragLimit);
Nunsigned  HEADER_SetFixed           (HEADER_Handle hObj, unsigned Fixed);
Nvoid      HEADER_SetFont            (HEADER_Handle hObj, const GUI_FONT * pFont);
Nvoid      HEADER_SetHeight          (HEADER_Handle hObj, int Height);
Nvoid      HEADER_SetTextAlign       (HEADER_Handle hObj, unsigned int Index, int Align);
Nvoid      HEADER_SetItemText        (HEADER_Handle hObj, unsigned int Index, const char * s);
Nvoid      HEADER_SetItemWidth       (HEADER_Handle hObj, unsigned int Index, int Width);
Nvoid      HEADER_SetScrollPos       (HEADER_Handle hObj, int ScrollPos);
Nvoid      HEADER_SetStreamedBitmap  (HEADER_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap);
Nvoid      HEADER_SetStreamedBitmapEx(HEADER_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Nvoid      HEADER_SetTextColor       (HEADER_Handle hObj, GUI_COLOR Color);
Nint       HEADER_SetUserData        (HEADER_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid HEADER_GetSkinFlexProps     (HEADER_SKINFLEX_PROPS * pProps, int Index);
Nvoid HEADER_SetSkinClassic       (HEADER_Handle hObj);
Nvoid HEADER_SetSkin              (HEADER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  HEADER_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid HEADER_SetSkinFlexProps     (const HEADER_SKINFLEX_PROPS * pProps, int Index);
Nvoid HEADER_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * HEADER_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define HEADER_SKIN_FLEX          HEADER_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*
N**********************************************************************
N*/
N
N#ifdef HEADER_SPACING_H
S  #define HEADER_BORDER_H_DEFAULT HEADER_SPACING_H
N#endif
N#ifdef HEADER_SPACING_V
S  #define HEADER_BORDER_V_DEFAULT HEADER_SPACING_V
N#endif
N#define HEADER_SetDefaultSpacingH(Value) HEADER_SetDefaultBorderH(Value)
N#define HEADER_SetDefaultSpacingV(Value) HEADER_SetDefaultBorderV(Value)
N#define HEADER_GetDefaultSpacingH()      HEADER_GetDefaultBorderH()
N#define HEADER_GetDefaultSpacingV()      HEADER_GetDefaultBorderV()
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // HEADER_H
N
N/*************************** End of file ****************************/
L 68 "..\STemWin\inc\DIALOG.h" 2
N#include "ICONVIEW.h"
L 1 "..\STemWin\inc\ICONVIEW.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : ICONVIEW.h
NPurpose     : ICONVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef ICONVIEW_H
N#define ICONVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Status- and create flags
N//
N#define ICONVIEW_CF_AUTOSCROLLBAR_V (1 << 1)
N#define ICONVIEW_SF_AUTOSCROLLBAR_V ICONVIEW_CF_AUTOSCROLLBAR_V
N
N//
N// Color indices
N//
N#define ICONVIEW_CI_BK              0
N#define ICONVIEW_CI_UNSEL           0
N#define ICONVIEW_CI_SEL             1
N#define ICONVIEW_CI_DISABLED        2
N
N//
N// Icon alignment flags, horizontal
N//
N#define ICONVIEW_IA_HCENTER         (0 << 0)
N#define ICONVIEW_IA_LEFT            (1 << 0)
N#define ICONVIEW_IA_RIGHT           (2 << 0)
N
N//
N// Icon alignment flags, vertical
N//
N#define ICONVIEW_IA_VCENTER         (0 << 2)
N#define ICONVIEW_IA_BOTTOM          (1 << 2)
N#define ICONVIEW_IA_TOP             (2 << 2)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM ICONVIEW_Handle;
Xtypedef signed long ICONVIEW_Handle;
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NICONVIEW_Handle ICONVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems);
XICONVIEW_Handle ICONVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems);
NICONVIEW_Handle ICONVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems, int NumExtraBytes);
XICONVIEW_Handle ICONVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems, int NumExtraBytes);
NICONVIEW_Handle ICONVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XICONVIEW_Handle ICONVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
Nint  ICONVIEW_AddBitmapItem           (ICONVIEW_Handle hObj, const GUI_BITMAP * pBitmap, const char * pText);
Nint  ICONVIEW_AddBMPItem              (ICONVIEW_Handle hObj, const U8 * pBMP, const char * pText);
Xint  ICONVIEW_AddBMPItem              (ICONVIEW_Handle hObj, const unsigned char * pBMP, const char * pText);
Nint  ICONVIEW_AddBMPItemEx            (ICONVIEW_Handle hObj, const void * pBMP, GUI_GET_DATA_FUNC * pfGetData, const char * pText);
Nint  ICONVIEW_AddStreamedBitmapItem   (ICONVIEW_Handle hObj, const void * pStreamedBitmap, const char * pText);
Nvoid ICONVIEW_DeleteItem              (ICONVIEW_Handle hObj, unsigned Index);
Nvoid ICONVIEW_EnableStreamAuto        (void);
NU32  ICONVIEW_GetItemUserData         (ICONVIEW_Handle hObj, int Index);
Xunsigned long  ICONVIEW_GetItemUserData         (ICONVIEW_Handle hObj, int Index);
Nint  ICONVIEW_GetNumItems             (ICONVIEW_Handle hObj);
Nint  ICONVIEW_GetItemText             (ICONVIEW_Handle hObj, int Index, char * pBuffer, int MaxSize);
Nint  ICONVIEW_GetSel                  (ICONVIEW_Handle hObj);
Nint  ICONVIEW_GetUserData             (ICONVIEW_Handle hObj, void * pDest, int NumBytes);
Nint  ICONVIEW_InsertBitmapItem        (ICONVIEW_Handle hObj, const GUI_BITMAP * pBitmap, const char * pText, int Index);
Nint  ICONVIEW_InsertBMPItem           (ICONVIEW_Handle hObj, const U8 * pBMP, const char * pText, int Index);
Xint  ICONVIEW_InsertBMPItem           (ICONVIEW_Handle hObj, const unsigned char * pBMP, const char * pText, int Index);
Nint  ICONVIEW_InsertBMPItemEx         (ICONVIEW_Handle hObj, const void * pBMP, GUI_GET_DATA_FUNC * pfGetData, const char * pText, int Index);
Nint  ICONVIEW_InsertStreamedBitmapItem(ICONVIEW_Handle hObj, const void * pStreamedBitmap, const char * pText, int Index);
Nint  ICONVIEW_SetBitmapItem           (ICONVIEW_Handle hObj, int Index, const GUI_BITMAP * pBitmap);
Nvoid ICONVIEW_SetBkColor              (ICONVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint  ICONVIEW_SetBMPItem              (ICONVIEW_Handle hObj, const U8 * pBMP, int Index);
Xint  ICONVIEW_SetBMPItem              (ICONVIEW_Handle hObj, const unsigned char * pBMP, int Index);
Nint  ICONVIEW_SetBMPItemEx            (ICONVIEW_Handle hObj, const void * pBMP, GUI_GET_DATA_FUNC * pfGetData, int Index);
Nvoid ICONVIEW_SetFont                 (ICONVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid ICONVIEW_SetFrame                (ICONVIEW_Handle hObj, int Coord, int Value);
Nvoid ICONVIEW_SetItemText             (ICONVIEW_Handle hObj, int Index, const char * pText);
Nvoid ICONVIEW_SetItemUserData         (ICONVIEW_Handle hObj, int Index, U32 UserData);
Xvoid ICONVIEW_SetItemUserData         (ICONVIEW_Handle hObj, int Index, unsigned long UserData);
Nvoid ICONVIEW_SetSel                  (ICONVIEW_Handle hObj, int Sel);
Nvoid ICONVIEW_SetSpace                (ICONVIEW_Handle hObj, int Coord, int Value);
Nint  ICONVIEW_SetStreamedBitmapItem   (ICONVIEW_Handle hObj, int Index, const void * pStreamedBitmap);
Nvoid ICONVIEW_SetIconAlign            (ICONVIEW_Handle hObj, int IconAlign);
Nvoid ICONVIEW_SetTextAlign            (ICONVIEW_Handle hObj, int TextAlign);
Nvoid ICONVIEW_SetTextColor            (ICONVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint  ICONVIEW_SetUserData             (ICONVIEW_Handle hObj, const void * pSrc, int NumBytes);
Nvoid ICONVIEW_SetWrapMode             (ICONVIEW_Handle hObj, GUI_WRAPMODE WrapMode);
N
Nvoid ICONVIEW_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // ICONVIEW_H
N
N/*************************** End of file ****************************/
L 69 "..\STemWin\inc\DIALOG.h" 2
N#include "IMAGE.h"
L 1 "..\STemWin\inc\IMAGE.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : IMAGE.h
NPurpose     : Image include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef IMAGE_H
N#define IMAGE_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" { // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define IMAGE_CF_MEMDEV   (1 << 0) // Widget uses an internal memory device which speeds up use of compressed images (GIF, JPEG, PNG)
N#define IMAGE_CF_TILE     (1 << 1) // Uses tiling to fill up the whole area of the widget
N#define IMAGE_CF_ALPHA    (1 << 2) // Needs to be set if alpha blending is required (PNG)
N#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
N#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM IMAGE_Handle;
Xtypedef signed long IMAGE_Handle;
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NIMAGE_Handle IMAGE_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XIMAGE_Handle IMAGE_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NIMAGE_Handle IMAGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XIMAGE_Handle IMAGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NIMAGE_Handle IMAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XIMAGE_Handle IMAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
Nvoid IMAGE_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint  IMAGE_GetUserData(IMAGE_Handle hObj, void * pDest, int NumBytes);
Nvoid IMAGE_SetBitmap  (IMAGE_Handle hWin, const GUI_BITMAP * pBitmap);
Nvoid IMAGE_SetBMP     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetBMP     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetBMPEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetDTA     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetDTA     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetDTAEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetGIF     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetGIF     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetGIFEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetJPEG    (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetJPEG    (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetJPEGEx  (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetPNG     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetPNG     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetPNGEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nint  IMAGE_SetUserData(IMAGE_Handle hObj, const void * pSrc, int NumBytes);
N
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif // GUI_WINSUPPORT
N#endif // IMAGE_H
N
N/*************************** End of file ****************************/
L 70 "..\STemWin\inc\DIALOG.h" 2
N#include "LISTBOX.h"
N#include "LISTVIEW.h"
L 1 "..\STemWin\inc\LISTVIEW.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : LISTVIEW.h
NPurpose     : LISTVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef LISTVIEW_H
N#define LISTVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      // Req. for Create indirect data structure
N#include "ICONVIEW.h"
N#include "HEADER.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*/
N#define LISTVIEW_ALL_ITEMS  -1
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define LISTVIEW_CI_UNSEL       0
N#define LISTVIEW_CI_SEL         1
N#define LISTVIEW_CI_SELFOCUS    2
N#define LISTVIEW_CI_DISABLED    3
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define LISTVIEW_CF_AUTOSCROLLBAR_H   (1 << 0)
N#define LISTVIEW_CF_AUTOSCROLLBAR_V   (1 << 1)
N#define LISTVIEW_CF_CELL_SELECT       (1 << 2)                     // Create Flag used to enable cell selection
N#define LISTVIEW_SF_AUTOSCROLLBAR_H   LISTVIEW_CF_AUTOSCROLLBAR_H
N#define LISTVIEW_SF_AUTOSCROLLBAR_V   LISTVIEW_CF_AUTOSCROLLBAR_V
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM LISTVIEW_Handle;
Xtypedef signed long LISTVIEW_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NLISTVIEW_Handle LISTVIEW_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XLISTVIEW_Handle LISTVIEW_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NLISTVIEW_Handle LISTVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XLISTVIEW_Handle LISTVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NLISTVIEW_Handle LISTVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XLISTVIEW_Handle LISTVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NLISTVIEW_Handle LISTVIEW_CreateAttached(WM_HWIN hParent, int Id, int SpecialFlags);
XLISTVIEW_Handle LISTVIEW_CreateAttached(GUI_HWIN hParent, int Id, int SpecialFlags);
NLISTVIEW_Handle LISTVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTVIEW_Handle LISTVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTVIEW_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint              LISTVIEW_AddColumn           (LISTVIEW_Handle hObj, int Width, const char * s, int Align);
Nint              LISTVIEW_AddRow              (LISTVIEW_Handle hObj, const GUI_ConstString * ppText);
Nint              LISTVIEW_CompareText         (const void * p0, const void * p1);
Nint              LISTVIEW_CompareDec          (const void * p0, const void * p1);
Nvoid             LISTVIEW_DecSel              (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_DeleteAllRows       (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_DeleteColumn        (LISTVIEW_Handle hObj, unsigned Index);
Nvoid             LISTVIEW_DeleteRow           (LISTVIEW_Handle hObj, unsigned Index);
Nvoid             LISTVIEW_DeleteRowSorted     (LISTVIEW_Handle hObj, int Row);
Nvoid             LISTVIEW_DisableRow          (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_DisableSort         (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_EnableCellSelect    (LISTVIEW_Handle hObj, unsigned OnOff);  // Enables/disables cell selection
Nvoid             LISTVIEW_EnableRow           (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_EnableSort          (LISTVIEW_Handle hObj);
NGUI_COLOR        LISTVIEW_GetBkColor          (LISTVIEW_Handle hObj, unsigned Index);
Nconst GUI_FONT * LISTVIEW_GetFont             (LISTVIEW_Handle hObj);
NHEADER_Handle    LISTVIEW_GetHeader           (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_GetItemRect         (LISTVIEW_Handle hObj, U32 Col, U32 Row, GUI_RECT * pRect);
Xvoid             LISTVIEW_GetItemRect         (LISTVIEW_Handle hObj, unsigned long Col, unsigned long Row, GUI_RECT * pRect);
Nvoid             LISTVIEW_GetItemText         (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, char * pBuffer, unsigned MaxSize);
Nunsigned         LISTVIEW_GetItemTextLen      (LISTVIEW_Handle hObj, unsigned Column, unsigned Row);
Nvoid             LISTVIEW_GetItemTextSorted   (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, char * pBuffer, unsigned MaxSize);
Nunsigned         LISTVIEW_GetLBorder          (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetNumColumns       (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetNumRows          (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetRBorder          (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSel              (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSelCol           (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSelUnsorted      (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetTextAlign        (LISTVIEW_Handle hObj, unsigned ColIndex);
NGUI_COLOR        LISTVIEW_GetTextColor        (LISTVIEW_Handle hObj, unsigned Index);
Nint              LISTVIEW_GetUserData         (LISTVIEW_Handle hObj, void * pDest, int NumBytes);
NU32              LISTVIEW_GetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row);
Xunsigned long              LISTVIEW_GetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row);
NGUI_WRAPMODE     LISTVIEW_GetWrapMode         (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_IncSel              (LISTVIEW_Handle hObj);
Nint              LISTVIEW_InsertRow           (LISTVIEW_Handle hObj, unsigned Index, const GUI_ConstString * ppText);
Nint              LISTVIEW_OwnerDraw           (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nunsigned         LISTVIEW_RowIsDisabled       (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_SetAutoScrollH      (LISTVIEW_Handle hObj, int OnOff);
Nvoid             LISTVIEW_SetAutoScrollV      (LISTVIEW_Handle hObj, int OnOff);
Nvoid             LISTVIEW_SetItemBitmap       (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, int xOff, int yOff, const GUI_BITMAP * pBitmap);
Nvoid             LISTVIEW_SetBkColor          (LISTVIEW_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetColumnWidth      (LISTVIEW_Handle hObj, unsigned int Index, int Width);
Nvoid             LISTVIEW_SetCompareFunc      (LISTVIEW_Handle hObj, unsigned Column, int (* fpCompare)(const void * p0, const void * p1));
Nunsigned         LISTVIEW_SetFixed            (LISTVIEW_Handle hObj, unsigned Fixed);
Nvoid             LISTVIEW_SetFont             (LISTVIEW_Handle hObj, const GUI_FONT * pFont);
Nint              LISTVIEW_SetGridVis          (LISTVIEW_Handle hObj, int Show);
Nvoid             LISTVIEW_SetHeaderHeight     (LISTVIEW_Handle hObj, unsigned HeaderHeight);
Nvoid             LISTVIEW_SetItemBkColor      (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetItemText         (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, const char * s);
Nvoid             LISTVIEW_SetItemTextColor    (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetItemTextSorted   (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, const char * pText);
Nvoid             LISTVIEW_SetLBorder          (LISTVIEW_Handle hObj, unsigned BorderSize);
Nvoid             LISTVIEW_SetOwnerDraw        (LISTVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             LISTVIEW_SetRBorder          (LISTVIEW_Handle hObj, unsigned BorderSize);
Nunsigned         LISTVIEW_SetRowHeight        (LISTVIEW_Handle hObj, unsigned RowHeight);
Nvoid             LISTVIEW_SetSel              (LISTVIEW_Handle hObj, int Sel);
Nvoid             LISTVIEW_SetSelCol           (LISTVIEW_Handle hObj, int NewCol);
Nvoid             LISTVIEW_SetSelUnsorted      (LISTVIEW_Handle hObj, int Sel);
Nunsigned         LISTVIEW_SetSort             (LISTVIEW_Handle hObj, unsigned Column, unsigned Reverse);
Nvoid             LISTVIEW_SetTextAlign        (LISTVIEW_Handle hObj, unsigned int Index, int Align);
Nvoid             LISTVIEW_SetTextColor        (LISTVIEW_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nint              LISTVIEW_SetUserData         (LISTVIEW_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             LISTVIEW_SetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row, U32 UserData);
Xvoid             LISTVIEW_SetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row, unsigned long UserData);
Nvoid             LISTVIEW_SetWrapMode         (LISTVIEW_Handle hObj, GUI_WRAPMODE WrapMode);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
NGUI_COLOR        LISTVIEW_SetDefaultBkColor  (unsigned  Index, GUI_COLOR Color);
Nconst GUI_FONT * LISTVIEW_SetDefaultFont     (const GUI_FONT * pFont);
NGUI_COLOR        LISTVIEW_SetDefaultGridColor(GUI_COLOR Color);
NGUI_COLOR        LISTVIEW_SetDefaultTextColor(unsigned  Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTVIEW_H
N
N/*************************** End of file ****************************/
L 72 "..\STemWin\inc\DIALOG.h" 2
N#include "LISTWHEEL.h"
L 1 "..\STemWin\inc\LISTWHEEL.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : LISTWHEEL.h
NPurpose     : LISTWHEEL widget include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef LISTWHEEL_H
N#define LISTWHEEL_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define LISTWHEEL_CI_UNSEL 0
N#define LISTWHEEL_CI_SEL   1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM LISTWHEEL_Handle;
Xtypedef signed long LISTWHEEL_Handle;
N
N/*********************************************************************
N*
N*       Standard member functions
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NLISTWHEEL_Handle LISTWHEEL_Create        (const GUI_ConstString * ppText, int x0, int y0, int xSize, int ySize, int Flags);
NLISTWHEEL_Handle LISTWHEEL_CreateAsChild (const GUI_ConstString * ppText, WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XLISTWHEEL_Handle LISTWHEEL_CreateAsChild (const GUI_ConstString * ppText, GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NLISTWHEEL_Handle LISTWHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTWHEEL_Handle LISTWHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NLISTWHEEL_Handle LISTWHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent,
XLISTWHEEL_Handle LISTWHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
NLISTWHEEL_Handle LISTWHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent,
XLISTWHEEL_Handle LISTWHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTWHEEL_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      LISTWHEEL_AddString      (LISTWHEEL_Handle hObj, const char * s);
Nvoid *    LISTWHEEL_GetItemData    (LISTWHEEL_Handle hObj, unsigned Index); /* not to be documented */
Nvoid      LISTWHEEL_GetItemText    (LISTWHEEL_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint       LISTWHEEL_GetItemFromPos (LISTWHEEL_Handle hObj, int yPos);
Nint       LISTWHEEL_GetLBorder     (LISTWHEEL_Handle hObj);
Nunsigned  LISTWHEEL_GetLineHeight  (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetNumItems    (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetPos         (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetRBorder     (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetSel         (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetSnapPosition(LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetTextAlign   (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetUserData    (LISTWHEEL_Handle hObj, void * pDest, int NumBytes);
Nint       LISTWHEEL_IsMoving       (LISTWHEEL_Handle hObj);
Nvoid      LISTWHEEL_MoveToPos      (LISTWHEEL_Handle hObj, unsigned int Index);
Nint       LISTWHEEL_OwnerDraw      (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid      LISTWHEEL_SetBkColor     (LISTWHEEL_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid      LISTWHEEL_SetDeceleration(LISTWHEEL_Handle hObj, unsigned Deceleration);
Nvoid      LISTWHEEL_SetFont        (LISTWHEEL_Handle hObj, const GUI_FONT * pFont);
Nvoid      LISTWHEEL_SetItemData    (LISTWHEEL_Handle hObj, unsigned Index, void * pData); /* not to be documented */
Nvoid      LISTWHEEL_SetLBorder     (LISTWHEEL_Handle hObj, unsigned BorderSize);
Nvoid      LISTWHEEL_SetLineHeight  (LISTWHEEL_Handle hObj, unsigned LineHeight);
Nvoid      LISTWHEEL_SetOwnerDraw   (LISTWHEEL_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfOwnerDraw);
Nvoid      LISTWHEEL_SetPos         (LISTWHEEL_Handle hObj, unsigned int Index);
Nvoid      LISTWHEEL_SetRBorder     (LISTWHEEL_Handle hObj, unsigned BorderSize);
Nvoid      LISTWHEEL_SetSel         (LISTWHEEL_Handle hObj, int Sel);
Nvoid      LISTWHEEL_SetSnapPosition(LISTWHEEL_Handle hObj, int SnapPosition);
Nvoid      LISTWHEEL_SetText        (LISTWHEEL_Handle hObj, const GUI_ConstString * ppText);
Nvoid      LISTWHEEL_SetTextAlign   (LISTWHEEL_Handle hObj, int Align);
Nvoid      LISTWHEEL_SetTextColor   (LISTWHEEL_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid      LISTWHEEL_SetTimerPeriod (LISTWHEEL_Handle hObj, GUI_TIMER_TIME TimerPeriod);
Xvoid      LISTWHEEL_SetTimerPeriod (LISTWHEEL_Handle hObj, int TimerPeriod);
Nint       LISTWHEEL_SetUserData    (LISTWHEEL_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      LISTWHEEL_SetVelocity    (LISTWHEEL_Handle hObj, int Velocity);
N
Nconst GUI_FONT * LISTWHEEL_GetFont(LISTWHEEL_Handle hObj);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTWHEEL_H
N
N/*************************** End of file ****************************/
L 73 "..\STemWin\inc\DIALOG.h" 2
N#include "MENU.h"
L 1 "..\STemWin\inc\MENU.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : MENU.h
NPurpose     : MENU include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef MENU_H
N#define MENU_H
N
N#include "WM.h"
N#include "WIDGET.h"
N#include "DIALOG_Intern.h"      // Required for Create indirect data structure
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define MENU_SKIN_FLEX    MENU_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Create flags
N*/
N#define MENU_CF_HORIZONTAL              (0<<0)
N#define MENU_CF_VERTICAL                (1<<0)
N#define MENU_CF_OPEN_ON_POINTEROVER     (1<<1)  // Normally a menu opens first when clicked on it
N#define MENU_CF_CLOSE_ON_SECOND_CLICK   (1<<2)  // Normally a menu closes only when clicked outside it
N#define MENU_CF_HIDE_DISABLED_SEL       (1<<3)  // Hides the selection when a disabled item is selected
N
N/*********************************************************************
N*
N*       Menu item flags
N*/
N#define MENU_IF_DISABLED                (1<<0)  // Indicates that item is disabled
N#define MENU_IF_SEPARATOR               (1<<1)  // Indicates that item is a separator
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define MENU_CI_ENABLED                 0
N#define MENU_CI_SELECTED                1
N#define MENU_CI_DISABLED                2
N#define MENU_CI_DISABLED_SEL            3
N#define MENU_CI_ACTIVE_SUBMENU          4
N
N/*********************************************************************
N*
N*       Border indices
N*/
N#define MENU_BI_LEFT                    0
N#define MENU_BI_RIGHT                   1
N#define MENU_BI_TOP                     2
N#define MENU_BI_BOTTOM                  3
N
N/*********************************************************************
N*
N*       Message types
N*/
N#define MENU_ON_ITEMSELECT              0   // Send to owner when selecting a menu item
N#define MENU_ON_INITMENU                1   // Send to owner when for the first time selecting a submenu
N#define MENU_ON_INITSUBMENU             2   // Send to owner when selecting a submenu
N#define MENU_ON_OPEN                    3   // Internal message of menu widget (only send to submenus)
N#define MENU_ON_CLOSE                   4   // Internal message of menu widget (only send to submenus)
N#define MENU_IS_MENU                    5   // Internal message of menu widget. Owner must call
N                                            // WM_DefaultProc() when not handle the message
N#define MENU_ON_ITEMACTIVATE            6   // Send to owner when highlighting a menu item
N#define MENU_ON_ITEMPRESSED             7   // Send to owner when a menu item has been pressed
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define MENU_SKINFLEX_PI_ENABLED        0
N#define MENU_SKINFLEX_PI_SELECTED       1
N#define MENU_SKINFLEX_PI_DISABLED       2
N#define MENU_SKINFLEX_PI_DISABLED_SEL   3
N#define MENU_SKINFLEX_PI_ACTIVE_SUBMENU 4
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM MENU_Handle;
Xtypedef signed long MENU_Handle;
N
Ntypedef struct {
N  //
N  // Background
N  //  
N  GUI_COLOR aBkColorH[2];
N  GUI_COLOR BkColorV;
N  GUI_COLOR FrameColorH;
N  GUI_COLOR FrameColorV;
N  //
N  // Selection
N  //
N  GUI_COLOR aSelColorH[2];
N  GUI_COLOR aSelColorV[2];
N  GUI_COLOR FrameColorSelH;
N  GUI_COLOR FrameColorSelV;
N  //
N  // Separator
N  //
N  GUI_COLOR aSepColorH[2];
N  GUI_COLOR aSepColorV[2];
N  //
N  // Arrow
N  //
N  GUI_COLOR ArrowColor;
N  //
N  // Text
N  //
N  GUI_COLOR TextColor;
N} MENU_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Menu message data
N*/
Ntypedef struct {
N  U16 MsgType;
X  unsigned short MsgType;
N  U16 ItemId;
X  unsigned short ItemId;
N} MENU_MSG_DATA;
N
N/*********************************************************************
N*
N*       Menu item data
N*/
Ntypedef struct {
N  const char  * pText;
N  U16           Id;
X  unsigned short           Id;
N  U16           Flags;
X  unsigned short           Flags;
N  MENU_Handle   hSubmenu;
N} MENU_ITEM_DATA;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NMENU_Handle MENU_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMENU_Handle MENU_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NMENU_Handle MENU_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XMENU_Handle MENU_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NMENU_Handle MENU_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMENU_Handle MENU_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MENU_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Individual member functions
N*
N**********************************************************************
N*/
Nvoid      MENU_AddItem      (MENU_Handle hObj, const MENU_ITEM_DATA * pItemData);
Nvoid      MENU_Attach       (MENU_Handle hObj, WM_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Xvoid      MENU_Attach       (MENU_Handle hObj, GUI_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Nvoid      MENU_DeleteItem   (MENU_Handle hObj, U16 ItemId);
Xvoid      MENU_DeleteItem   (MENU_Handle hObj, unsigned short ItemId);
Nvoid      MENU_DisableItem  (MENU_Handle hObj, U16 ItemId);
Xvoid      MENU_DisableItem  (MENU_Handle hObj, unsigned short ItemId);
Nvoid      MENU_EnableItem   (MENU_Handle hObj, U16 ItemId);
Xvoid      MENU_EnableItem   (MENU_Handle hObj, unsigned short ItemId);
Nvoid      MENU_GetItem      (MENU_Handle hObj, U16 ItemId, MENU_ITEM_DATA * pItemData);
Xvoid      MENU_GetItem      (MENU_Handle hObj, unsigned short ItemId, MENU_ITEM_DATA * pItemData);
Nvoid      MENU_GetItemText  (MENU_Handle hObj, U16 ItemId, char * pBuffer, unsigned BufferSize);
Xvoid      MENU_GetItemText  (MENU_Handle hObj, unsigned short ItemId, char * pBuffer, unsigned BufferSize);
Nunsigned  MENU_GetNumItems  (MENU_Handle hObj);
NWM_HWIN   MENU_GetOwner     (MENU_Handle hObj);
XGUI_HWIN   MENU_GetOwner     (MENU_Handle hObj);
Nint       MENU_GetUserData  (MENU_Handle hObj, void * pDest, int NumBytes);
Nvoid      MENU_InsertItem   (MENU_Handle hObj, U16 ItemId, const MENU_ITEM_DATA * pItemData);
Xvoid      MENU_InsertItem   (MENU_Handle hObj, unsigned short ItemId, const MENU_ITEM_DATA * pItemData);
Nvoid      MENU_Popup        (MENU_Handle hObj, WM_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Xvoid      MENU_Popup        (MENU_Handle hObj, GUI_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Nvoid      MENU_SetBkColor   (MENU_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nvoid      MENU_SetBorderSize(MENU_Handle hObj, unsigned BorderIndex, U8 BorderSize);
Xvoid      MENU_SetBorderSize(MENU_Handle hObj, unsigned BorderIndex, unsigned char BorderSize);
Nvoid      MENU_SetFont      (MENU_Handle hObj, const GUI_FONT * pFont);
Nvoid      MENU_SetItem      (MENU_Handle hObj, U16 ItemId, const MENU_ITEM_DATA * pItemData);
Xvoid      MENU_SetItem      (MENU_Handle hObj, unsigned short ItemId, const MENU_ITEM_DATA * pItemData);
Nvoid      MENU_SetOwner     (MENU_Handle hObj, WM_HWIN hOwner);
Xvoid      MENU_SetOwner     (MENU_Handle hObj, GUI_HWIN hOwner);
Nint       MENU_SetSel       (MENU_Handle hObj, int Sel);
Nvoid      MENU_SetTextColor (MENU_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nint       MENU_SetUserData  (MENU_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR             MENU_GetDefaultTextColor  (unsigned ColorIndex);
NGUI_COLOR             MENU_GetDefaultBkColor    (unsigned ColorIndex);
NU8                    MENU_GetDefaultBorderSize (unsigned BorderIndex);
Xunsigned char                    MENU_GetDefaultBorderSize (unsigned BorderIndex);
Nconst WIDGET_EFFECT * MENU_GetDefaultEffect     (void);
Nconst GUI_FONT      * MENU_GetDefaultFont       (void);
Nvoid                  MENU_SetDefaultTextColor  (unsigned ColorIndex, GUI_COLOR Color);
Nvoid                  MENU_SetDefaultBkColor    (unsigned ColorIndex, GUI_COLOR Color);
Nvoid                  MENU_SetDefaultBorderSize (unsigned BorderIndex, U8 BorderSize);
Xvoid                  MENU_SetDefaultBorderSize (unsigned BorderIndex, unsigned char BorderSize);
Nvoid                  MENU_SetDefaultEffect     (const WIDGET_EFFECT * pEffect);
Nvoid                  MENU_SetDefaultFont       (const GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint                     MENU_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    MENU_GetSkinFlexProps     (MENU_SKINFLEX_PROPS * pProps, int Index);
NWIDGET_DRAW_ITEM_FUNC * MENU_SetDefaultSkin       (WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MENU_SetDefaultSkinClassic(void);
Nvoid                    MENU_SetSkinClassic       (MENU_Handle hObj);
Nvoid                    MENU_SetSkin              (MENU_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MENU_SetSkinFlexProps     (const MENU_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    MENU_SkinEnableArrow      (MENU_Handle hObj, int OnOff);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MENU_H
N
N/*************************** End of file ****************************/
L 74 "..\STemWin\inc\DIALOG.h" 2
N#include "MULTIEDIT.h"
L 1 "..\STemWin\inc\MULTIEDIT.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : MULTIEDIT.h
NPurpose     : MULTIEDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef MULTIEDIT_H
N#define MULTIEDIT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#define MULTIEDIT_CF_READONLY        (1 << 0)
N#define MULTIEDIT_CF_INSERT          (1 << 2)
N#define MULTIEDIT_CF_AUTOSCROLLBAR_V (1 << 3)
N#define MULTIEDIT_CF_AUTOSCROLLBAR_H (1 << 4)
N#define MULTIEDIT_CF_PASSWORD        (1 << 5)
N
N#define MULTIEDIT_SF_READONLY        MULTIEDIT_CF_READONLY
N#define MULTIEDIT_SF_INSERT          MULTIEDIT_CF_INSERT
N#define MULTIEDIT_SF_AUTOSCROLLBAR_V MULTIEDIT_CF_AUTOSCROLLBAR_V
N#define MULTIEDIT_SF_AUTOSCROLLBAR_H MULTIEDIT_CF_AUTOSCROLLBAR_H
N#define MULTIEDIT_SF_PASSWORD        MULTIEDIT_CF_PASSWORD
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define MULTIEDIT_CI_EDIT     0
N#define MULTIEDIT_CI_READONLY 1
N
N/*********************************************************************
N*
N*                         Public Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM MULTIEDIT_HANDLE;
Xtypedef signed long MULTIEDIT_HANDLE;
N
N/*********************************************************************
N*
N*                 Create functions
N*
N**********************************************************************
N*/
NMULTIEDIT_HANDLE MULTIEDIT_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int ExFlags, const char * pText, int MaxLen);
XMULTIEDIT_HANDLE MULTIEDIT_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int ExFlags, const char * pText, int MaxLen);
NMULTIEDIT_HANDLE MULTIEDIT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText);
XMULTIEDIT_HANDLE MULTIEDIT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText);
NMULTIEDIT_HANDLE MULTIEDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMULTIEDIT_HANDLE MULTIEDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NMULTIEDIT_HANDLE MULTIEDIT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText, int NumExtraBytes);
XMULTIEDIT_HANDLE MULTIEDIT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MULTIEDIT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*                 Member functions
N*
N**********************************************************************
N*/
N
Nint  MULTIEDIT_AddKey           (MULTIEDIT_HANDLE hObj, U16 Key);
Xint  MULTIEDIT_AddKey           (MULTIEDIT_HANDLE hObj, unsigned short Key);
Nint  MULTIEDIT_AddText          (MULTIEDIT_HANDLE hObj, const char * s);
Nvoid MULTIEDIT_EnableBlink      (MULTIEDIT_HANDLE hObj, int Period, int OnOff);
Nint  MULTIEDIT_GetCursorCharPos (MULTIEDIT_HANDLE hObj);
Nvoid MULTIEDIT_GetCursorPixelPos(MULTIEDIT_HANDLE hObj, int * pxPos, int * pyPos);
Nvoid MULTIEDIT_GetPrompt        (MULTIEDIT_HANDLE hObj, char* sDest, int MaxNumChars);
Nint  MULTIEDIT_GetTextSize      (MULTIEDIT_HANDLE hObj);
Nvoid MULTIEDIT_GetText          (MULTIEDIT_HANDLE hObj, char* sDest, int MaxNumChars);
Nint  MULTIEDIT_GetUserData      (MULTIEDIT_HANDLE hObj, void * pDest, int NumBytes);
Nvoid MULTIEDIT_SetTextAlign     (MULTIEDIT_HANDLE hObj, int Align);
Nvoid MULTIEDIT_SetAutoScrollH   (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid MULTIEDIT_SetAutoScrollV   (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid MULTIEDIT_SetBkColor       (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nvoid MULTIEDIT_SetCursorCharPos (MULTIEDIT_HANDLE hObj, int x, int y);       /* Not yet implemented */
Nvoid MULTIEDIT_SetCursorPixelPos(MULTIEDIT_HANDLE hObj, int x, int y);       /* Not yet implemented */
Nvoid MULTIEDIT_SetCursorOffset  (MULTIEDIT_HANDLE hObj, int Offset);
Nvoid MULTIEDIT_SetHBorder       (MULTIEDIT_HANDLE hObj, unsigned HBorder);
Nvoid MULTIEDIT_SetFocussable    (MULTIEDIT_HANDLE hObj, int State);
Nvoid MULTIEDIT_SetFont          (MULTIEDIT_HANDLE hObj, const GUI_FONT * pFont);
Nvoid MULTIEDIT_SetInsertMode    (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid MULTIEDIT_SetBufferSize    (MULTIEDIT_HANDLE hObj, int BufferSize);
Nvoid MULTIEDIT_SetMaxNumChars   (MULTIEDIT_HANDLE hObj, unsigned MaxNumChars);
Nvoid MULTIEDIT_SetPrompt        (MULTIEDIT_HANDLE hObj, const char* sPrompt);
Nvoid MULTIEDIT_SetReadOnly      (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid MULTIEDIT_SetPasswordMode  (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid MULTIEDIT_SetText          (MULTIEDIT_HANDLE hObj, const char* s);
Nvoid MULTIEDIT_SetTextColor     (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nint  MULTIEDIT_SetUserData      (MULTIEDIT_HANDLE hObj, const void * pSrc, int NumBytes);
Nvoid MULTIEDIT_SetWrapNone      (MULTIEDIT_HANDLE hObj);
Nvoid MULTIEDIT_SetWrapChar      (MULTIEDIT_HANDLE hObj);
Nvoid MULTIEDIT_SetWrapWord      (MULTIEDIT_HANDLE hObj);
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*
N**********************************************************************
N*/
N
N#define MULTIEDIT_SetMaxLen(hObj, MaxLen) MULTIEDIT_SetBufferSize(hObj, MaxLen)
N#define MULTIEDIT_GetStringSize           MULTIEDIT_GetTextSize
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIEDIT_H
N
N/*************************** End of file ****************************/
L 75 "..\STemWin\inc\DIALOG.h" 2
N#include "MULTIPAGE.h"
L 1 "..\STemWin\inc\MULTIPAGE.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : MULTIPAGE.h
NPurpose     : MULTIPAGE include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef MULTIPAGE_H
N#define MULTIPAGE_H
N
N#include "WM.h"
N#include "DIALOG.h"   // Required for Create indirect data structure
L 1 "..\STemWin\inc\DIALOG.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef DIALOG_H
S#define DIALOG_H
S
S#include "WM.h"
S#include "BUTTON.h"
S#include "CALENDAR.h"
S#include "CHECKBOX.h"
S#include "CHOOSECOLOR.h"
S#include "CHOOSEFILE.h"
S#include "DROPDOWN.h"
S#include "EDIT.h"
S#include "FRAMEWIN.h"
S#include "GRAPH.h"
S#include "HEADER.h"
S#include "ICONVIEW.h"
S#include "IMAGE.h"
S#include "LISTBOX.h"
S#include "LISTVIEW.h"
S#include "LISTWHEEL.h"
S#include "MENU.h"
S#include "MULTIEDIT.h"
S#include "MULTIPAGE.h"
S#include "PROGBAR.h"
S#include "RADIO.h"
S#include "SCROLLBAR.h"
S#include "SLIDER.h"
S#include "SPINBOX.h"
S#include "TEXT.h"
S#include "TREEVIEW.h"
S#include "KNOB.h"
S
S#if GUI_WINSUPPORT
S
S#if defined(__cplusplus)
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S/*********************************************************************
S*
S*       WINDOW API
S*/
SWM_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
SWM_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
SWM_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
SGUI_COLOR WINDOW_GetDefaultBkColor(void);
Sint       WINDOW_GetUserData      (WM_HWIN hObj, void * pDest, int NumBytes);
Svoid      WINDOW_SetBkColor       (WM_HWIN hObj, GUI_COLOR Color);
Svoid      WINDOW_SetDefaultBkColor(GUI_COLOR Color);
Sint       WINDOW_SetUserData      (WM_HWIN hObj, const void * pSrc, int NumBytes);
S
Svoid WINDOW_Callback(WM_MESSAGE * pMsg);
S
S#if defined(__cplusplus)
S  }
S#endif
S
S#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_H
N
N/*************************** End of file ****************************/
L 59 "..\STemWin\inc\MULTIPAGE.h" 2
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define MULTIPAGE_ALIGN_LEFT           (0 << 0)
N#define MULTIPAGE_ALIGN_RIGHT          (1 << 0)
N#define MULTIPAGE_ALIGN_TOP            (0 << 2)
N#define MULTIPAGE_ALIGN_BOTTOM         (1 << 2)
N
N#define MULTIPAGE_CF_ROTATE_CW          WIDGET_CF_VERTICAL
N
N#define MULTIPAGE_CI_DISABLED           0
N#define MULTIPAGE_CI_ENABLED            1
N
N#define MULTIPAGE_SKIN_FRAME_LEFT      (1 << 0)
N#define MULTIPAGE_SKIN_FRAME_RIGHT     (1 << 1)
N#define MULTIPAGE_SKIN_FRAME_TOP       (1 << 2)
N#define MULTIPAGE_SKIN_FRAME_BOTTOM    (1 << 3)
N#define MULTIPAGE_SKIN_FRAME_ALL       (MULTIPAGE_SKIN_FRAME_LEFT | MULTIPAGE_SKIN_FRAME_RIGHT | MULTIPAGE_SKIN_FRAME_TOP | MULTIPAGE_SKIN_FRAME_BOTTOM)
N
N#define MULTIPAGE_SKINFLEX_PI_ENABLED   0
N#define MULTIPAGE_SKINFLEX_PI_SELECTED  1
N#define MULTIPAGE_SKINFLEX_PI_DISABLED  2
N
N#define SCROLLBAR_SIZE                 32 // Defines the space for the scrollbar arrows
N
N#define MULTIPAGE_BI_SELECTED           0
N#define MULTIPAGE_BI_UNSELECTED         1
N#define MULTIPAGE_BI_DISABLED           2
N#define MULTIPAGE_BI_MAX                3  // The defines above are used as array indices.
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM MULTIPAGE_Handle;
Xtypedef signed long MULTIPAGE_Handle;
N
Ntypedef struct {
N  GUI_COLOR BkColor;
N  GUI_COLOR aBkUpper[2];
N  GUI_COLOR aBkLower[2];
N  GUI_COLOR FrameColor;
N  GUI_COLOR TextColor;
N} MULTIPAGE_SKINFLEX_PROPS;
N
Ntypedef struct {
N  U8  SelSideBorderInc;         // Number of pixels to add on both sides when drawing the selected item.
X  unsigned char  SelSideBorderInc;         
N  U8  SelTopBorderInc;          // Number of pixels to add on top of selected items.
X  unsigned char  SelTopBorderInc;          
N} MULTIPAGE_SKIN_PROPS;
N
Ntypedef struct {
N  #if GUI_SUPPORT_ROTATION
X  #if 1
N    GUI_ROTATION  * pRotation;
X    tLCD_APIList  * pRotation;
N  #endif
N  unsigned          Align;
N  int               Sel;
N  U16               State;
X  unsigned short               State;
N  U8                FrameFlags;    // Flags to let the drawing function know which parts of the frame to display.
X  unsigned char                FrameFlags;    
N  U8                PageStatus;
X  unsigned char                PageStatus;
N  GUI_DRAW_HANDLE * pDrawObj;
N} MULTIPAGE_SKIN_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NMULTIPAGE_Handle MULTIPAGE_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XMULTIPAGE_Handle MULTIPAGE_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NMULTIPAGE_Handle MULTIPAGE_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XMULTIPAGE_Handle MULTIPAGE_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NMULTIPAGE_Handle MULTIPAGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMULTIPAGE_Handle MULTIPAGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NMULTIPAGE_Handle MULTIPAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMULTIPAGE_Handle MULTIPAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MULTIPAGE_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             MULTIPAGE_AddEmptyPage   (MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char * pText);
Xvoid             MULTIPAGE_AddEmptyPage   (MULTIPAGE_Handle hObj, GUI_HWIN hWin ,const char * pText);
Nvoid             MULTIPAGE_AddPage        (MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char * pText);
Xvoid             MULTIPAGE_AddPage        (MULTIPAGE_Handle hObj, GUI_HWIN hWin ,const char * pText);
NWM_HWIN          MULTIPAGE_AttachWindow   (MULTIPAGE_Handle hObj, unsigned Index, WM_HWIN hWin);
XGUI_HWIN          MULTIPAGE_AttachWindow   (MULTIPAGE_Handle hObj, unsigned Index, GUI_HWIN hWin);
Nvoid             MULTIPAGE_DeletePage     (MULTIPAGE_Handle hObj, unsigned Index, int Delete);
Nvoid             MULTIPAGE_DisablePage    (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_EnablePage     (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_EnableScrollbar(MULTIPAGE_Handle hObj, unsigned OnOff);
Nconst GUI_FONT * MULTIPAGE_GetFont        (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetSelection   (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetPageText    (MULTIPAGE_Handle hObj, unsigned Index, char * pBuffer, int MaxLen);
Nint              MULTIPAGE_GetUserData    (MULTIPAGE_Handle hObj, void * pDest, int NumBytes);
NWM_HWIN          MULTIPAGE_GetWindow      (MULTIPAGE_Handle hObj, unsigned Index);
XGUI_HWIN          MULTIPAGE_GetWindow      (MULTIPAGE_Handle hObj, unsigned Index);
Nint              MULTIPAGE_IsPageEnabled  (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_SelectPage     (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_SetAlign       (MULTIPAGE_Handle hObj, unsigned Align);
Nint              MULTIPAGE_SetBitmapEx    (MULTIPAGE_Handle hObj, const GUI_BITMAP * pBitmap, int x, int y, int Index, int State);
Nint              MULTIPAGE_SetBitmap      (MULTIPAGE_Handle hObj, const GUI_BITMAP * pBitmap, int Index, int State);
Nvoid             MULTIPAGE_SetBkColor     (MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index);
Nvoid             MULTIPAGE_SetFont        (MULTIPAGE_Handle hObj, const GUI_FONT * pFont);
Nvoid             MULTIPAGE_SetRotation    (MULTIPAGE_Handle hObj, unsigned Rotation);
Nvoid             MULTIPAGE_SetTabWidth    (MULTIPAGE_Handle hObj, int Width, int Index);
Nvoid             MULTIPAGE_SetTabHeight   (MULTIPAGE_Handle hObj, int Height);
Nvoid             MULTIPAGE_SetTextAlign   (MULTIPAGE_Handle hObj, unsigned Align);
Nvoid             MULTIPAGE_SetText        (MULTIPAGE_Handle hObj, const char * pText, unsigned Index);
Nvoid             MULTIPAGE_SetTextColor   (MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index);
Nint              MULTIPAGE_SetUserData    (MULTIPAGE_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nunsigned         MULTIPAGE_GetDefaultAlign      (void);
NGUI_COLOR        MULTIPAGE_GetDefaultBkColor    (unsigned Index);
Nconst GUI_FONT * MULTIPAGE_GetDefaultFont       (void);
NGUI_COLOR        MULTIPAGE_GetDefaultTextColor  (unsigned Index);
N
Nvoid             MULTIPAGE_SetDefaultAlign      (unsigned Align);
Nvoid             MULTIPAGE_SetDefaultBkColor    (GUI_COLOR Color, unsigned Index);
Nvoid             MULTIPAGE_SetDefaultBorderSizeX(unsigned Size);
Nvoid             MULTIPAGE_SetDefaultBorderSizeY(unsigned Size);
Nvoid             MULTIPAGE_SetDefaultFont       (const GUI_FONT * pFont);
Nvoid             MULTIPAGE_SetDefaultTextColor  (GUI_COLOR Color, unsigned Index);
N
Nvoid             MULTIPAGE_SetEffectColor       (unsigned Index, GUI_COLOR Color);
NGUI_COLOR        MULTIPAGE_GetEffectColor       (unsigned Index);
Nint              MULTIPAGE_GetNumEffectColors   (void);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint                     MULTIPAGE_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    MULTIPAGE_GetSkinFlexProps     (MULTIPAGE_SKINFLEX_PROPS * pProps, int Index);
NWIDGET_DRAW_ITEM_FUNC * MULTIPAGE_SetDefaultSkin       (WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MULTIPAGE_SetDefaultSkinClassic(void);
Nvoid                    MULTIPAGE_SetSkinClassic       (MULTIPAGE_Handle hObj);
Nvoid                    MULTIPAGE_SetSkin              (MULTIPAGE_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MULTIPAGE_SetSkinFlexProps     (const MULTIPAGE_SKINFLEX_PROPS * pProps, int Index);
N
N#define MULTIPAGE_SKIN_FLEX MULTIPAGE_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIPAGE_H
N
N/*************************** End of file ****************************/
L 76 "..\STemWin\inc\DIALOG.h" 2
N#include "PROGBAR.h"
L 1 "..\STemWin\inc\PROGBAR.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : PROGBAR.h
NPurpose     : Progressbar include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef PROGBAR_H        /* Avoid multiple inclusion  */
N#define PROGBAR_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create flags
N*/
N#define PROGBAR_CF_HORIZONTAL (0 << 0)
N#define PROGBAR_CF_VERTICAL   (1 << 0)
N#define PROGBAR_CF_USER       (1 << 1)
N
N/*********************************************************************
N*
N*       Skinning constants
N*/
N#define PROGBAR_SKINFLEX_L 0
N#define PROGBAR_SKINFLEX_R 1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM PROGBAR_Handle;
Xtypedef signed long PROGBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorUpperL[2];
N  GUI_COLOR aColorLowerL[2];
N  GUI_COLOR aColorUpperR[2];
N  GUI_COLOR aColorLowerR[2];
N  GUI_COLOR ColorFrame;
N  GUI_COLOR ColorText;
N} PROGBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int Index;
N  const char * pText;
N} PROGBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NPROGBAR_Handle PROGBAR_Create        (int x0, int y0, int xSize, int ySize, int Flags);
NPROGBAR_Handle PROGBAR_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XPROGBAR_Handle PROGBAR_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NPROGBAR_Handle PROGBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XPROGBAR_Handle PROGBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NPROGBAR_Handle PROGBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XPROGBAR_Handle PROGBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NPROGBAR_Handle PROGBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XPROGBAR_Handle PROGBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid PROGBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Individual member functions
N*
N**********************************************************************
N*/
N
Nvoid PROGBAR_GetMinMax   (PROGBAR_Handle hObj, int * pMin, int * pMax);
Nint  PROGBAR_GetUserData (PROGBAR_Handle hObj, void * pDest, int NumBytes);
Nint  PROGBAR_GetValue    (PROGBAR_Handle hObj);
Nvoid PROGBAR_SetBarColor (PROGBAR_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid PROGBAR_SetFont     (PROGBAR_Handle hObj, const GUI_FONT * pfont);
Nvoid PROGBAR_SetMinMax   (PROGBAR_Handle hObj, int Min, int Max);
Nvoid PROGBAR_SetText     (PROGBAR_Handle hObj, const char* s);
Nvoid PROGBAR_SetTextAlign(PROGBAR_Handle hObj, int Align);
Nvoid PROGBAR_SetTextColor(PROGBAR_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid PROGBAR_SetTextPos  (PROGBAR_Handle hObj, int XOff, int YOff);
Nvoid PROGBAR_SetValue    (PROGBAR_Handle hObj, int v);
Nint  PROGBAR_SetUserData (PROGBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid PROGBAR_GetSkinFlexProps     (PROGBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid PROGBAR_SetSkinClassic       (PROGBAR_Handle hObj);
Nvoid PROGBAR_SetSkin              (PROGBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  PROGBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid PROGBAR_SetSkinFlexProps     (const PROGBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid PROGBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * PROGBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define PROGBAR_SKIN_FLEX    PROGBAR_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // PROGBAR_H
N
N/*************************** End of file ****************************/
L 77 "..\STemWin\inc\DIALOG.h" 2
N#include "RADIO.h"
L 1 "..\STemWin\inc\RADIO.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : RADIO.h
NPurpose     : RADIO include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef RADIO_H
N#define RADIO_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define RADIO_BI_INACTIV 0
N#define RADIO_BI_ACTIV   1
N#define RADIO_BI_CHECK   2
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define RADIO_SKINFLEX_PI_PRESSED     0
N#define RADIO_SKINFLEX_PI_UNPRESSED   1
N
N/*********************************************************************
N*
N*       Defaults for public configuration switches
N*
N**********************************************************************
N
NThe following are defaults for config switches which affect the
Ninterface specified in this module
N*/
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define RADIO_TEXTPOS_RIGHT       0
N#define RADIO_TEXTPOS_LEFT        WIDGET_STATE_USER0  /* Not implemented, TBD */
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM RADIO_Handle;
Xtypedef signed long RADIO_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorButton[4];
N  int       ButtonSize;
N} RADIO_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NRADIO_Handle RADIO_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, unsigned Para);
XRADIO_Handle RADIO_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, unsigned Para);
NRADIO_Handle RADIO_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing);
XRADIO_Handle RADIO_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing);
NRADIO_Handle RADIO_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing, int NumExtraBytes);
XRADIO_Handle RADIO_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing, int NumExtraBytes);
NRADIO_Handle RADIO_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XRADIO_Handle RADIO_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid RADIO_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nvoid             RADIO_SetDefaultFont      (const GUI_FONT * pFont);
NGUI_COLOR        RADIO_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             RADIO_SetDefaultImage     (const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid             RADIO_SetDefaultTextColor (GUI_COLOR TextColor);
Nconst GUI_FONT * RADIO_GetDefaultFont      (void);
NGUI_COLOR        RADIO_GetDefaultTextColor (void);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nvoid      RADIO_AddValue     (RADIO_Handle hObj, int Add);
Nvoid      RADIO_Dec          (RADIO_Handle hObj);
Nint       RADIO_GetText      (RADIO_Handle hObj, unsigned Index, char * pBuffer, int MaxLen);
Nint       RADIO_GetUserData  (RADIO_Handle hObj, void * pDest, int NumBytes);
Nvoid      RADIO_Inc          (RADIO_Handle hObj);
Nvoid      RADIO_SetBkColor   (RADIO_Handle hObj, GUI_COLOR Color);
NGUI_COLOR RADIO_SetFocusColor(RADIO_Handle hObj, GUI_COLOR Color);
Nvoid      RADIO_SetFont      (RADIO_Handle hObj, const GUI_FONT * pFont);
Nvoid      RADIO_SetGroupId   (RADIO_Handle hObj, U8 GroupId);
Xvoid      RADIO_SetGroupId   (RADIO_Handle hObj, unsigned char GroupId);
Nvoid      RADIO_SetImage     (RADIO_Handle hObj, const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid      RADIO_SetText      (RADIO_Handle hObj, const char* pText, unsigned Index);
Nvoid      RADIO_SetTextColor (RADIO_Handle hObj, GUI_COLOR Color);
Nvoid      RADIO_SetValue     (RADIO_Handle hObj, int v);
Nint       RADIO_SetUserData  (RADIO_Handle hObj, const void * pSrc, int NumBytes);
N
Nconst GUI_BITMAP * RADIO_GetImage(RADIO_Handle hObj, unsigned int Index);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid RADIO_GetSkinFlexProps     (RADIO_SKINFLEX_PROPS * pProps, int Index);
Nvoid RADIO_SetSkinClassic       (RADIO_Handle hObj);
Nvoid RADIO_SetSkin              (RADIO_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  RADIO_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid RADIO_SetSkinFlexProps     (const RADIO_SKINFLEX_PROPS * pProps, int Index);
Nvoid RADIO_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * RADIO_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define RADIO_SKIN_FLEX    RADIO_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
Nint RADIO_GetValue(RADIO_Handle hObj);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // RADIO_H
N
N/*************************** End of file ****************************/
L 78 "..\STemWin\inc\DIALOG.h" 2
N#include "SCROLLBAR.h"
N#include "SLIDER.h"
L 1 "..\STemWin\inc\SLIDER.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : SLIDER.h
NPurpose     : SLIDER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef SLIDER_H
N#define SLIDER_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Defines
N*
N*************************************************************
N*/
N/************************************************************
N*
N*       States
N*/
N#define SLIDER_STATE_PRESSED    WIDGET_STATE_USER0
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define SLIDER_CF_HORIZONTAL 0
N#define SLIDER_CF_VERTICAL   WIDGET_CF_VERTICAL
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SLIDER_SKINFLEX_PI_PRESSED   0
N#define SLIDER_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SLIDER_Handle;
Xtypedef signed long SLIDER_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];
N  GUI_COLOR aColorInner[2];
N  GUI_COLOR aColorShaft[3];
N  GUI_COLOR ColorTick;
N  GUI_COLOR ColorFocus;
N  int TickSize;
N  int ShaftSize;
N} SLIDER_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int Width;
N  int NumTicks;
N  int Size;
N  int IsPressed;
N  int IsVertical;
N} SLIDER_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSLIDER_Handle SLIDER_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSLIDER_Handle SLIDER_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSLIDER_Handle SLIDER_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSLIDER_Handle SLIDER_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSLIDER_Handle SLIDER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSLIDER_Handle SLIDER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSLIDER_Handle SLIDER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSLIDER_Handle SLIDER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SLIDER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      SLIDER_Dec            (SLIDER_Handle hObj);
Nvoid      SLIDER_EnableFocusRect(SLIDER_Handle hObj, int OnOff);
NGUI_COLOR SLIDER_GetBarColor    (SLIDER_Handle hObj);
NGUI_COLOR SLIDER_GetBkColor     (SLIDER_Handle hObj);
NU8        SLIDER_GetFlag        (SLIDER_Handle hObj, U8 Flag);
Xunsigned char        SLIDER_GetFlag        (SLIDER_Handle hObj, unsigned char Flag);
NGUI_COLOR SLIDER_GetFocusColor  (SLIDER_Handle hObj);
Nvoid      SLIDER_GetRange       (SLIDER_Handle hObj, int * pMin, int * pMax);
NGUI_COLOR SLIDER_GetTickColor   (SLIDER_Handle hObj);
Nint       SLIDER_GetUserData    (SLIDER_Handle hObj, void * pDest, int NumBytes);
Nint       SLIDER_GetValue       (SLIDER_Handle hObj);
Nvoid      SLIDER_Inc            (SLIDER_Handle hObj);
Nvoid      SLIDER_SetBarColor    (SLIDER_Handle hObj, GUI_COLOR Color);
Nvoid      SLIDER_SetBkColor     (SLIDER_Handle hObj, GUI_COLOR Color);
NGUI_COLOR SLIDER_SetFocusColor  (SLIDER_Handle hObj, GUI_COLOR Color);
Nvoid      SLIDER_SetNumTicks    (SLIDER_Handle hObj, int NumTicks);
Nvoid      SLIDER_SetRange       (SLIDER_Handle hObj, int Min, int Max);
Nvoid      SLIDER_SetTickColor   (SLIDER_Handle hObj, GUI_COLOR Color);
Nint       SLIDER_SetUserData    (SLIDER_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      SLIDER_SetValue       (SLIDER_Handle hObj, int v);
Nvoid      SLIDER_SetWidth       (SLIDER_Handle hObj, int Width);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SLIDER_GetSkinFlexProps     (SLIDER_SKINFLEX_PROPS * pProps, int Index);
Nvoid SLIDER_SetSkinClassic       (SLIDER_Handle hObj);
Nvoid SLIDER_SetSkin              (SLIDER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SLIDER_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SLIDER_SetSkinFlexProps     (const SLIDER_SKINFLEX_PROPS * pProps, int Index);
Nvoid SLIDER_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SLIDER_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SLIDER_SKIN_FLEX    SLIDER_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR SLIDER_GetDefaultBkColor   (void);
NGUI_COLOR SLIDER_GetDefaultBarColor  (void);
NGUI_COLOR SLIDER_GetDefaultFocusColor(void);
NGUI_COLOR SLIDER_GetDefaultTickColor (void);
Nvoid      SLIDER_SetDefaultBkColor   (GUI_COLOR Color);
Nvoid      SLIDER_SetDefaultBarColor  (GUI_COLOR Color);
NGUI_COLOR SLIDER_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid      SLIDER_SetDefaultTickColor (GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SLIDER_H
N
N/*************************** End of file ****************************/
L 80 "..\STemWin\inc\DIALOG.h" 2
N#include "SPINBOX.h"
L 1 "..\STemWin\inc\SPINBOX.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : SPINBOX.h
NPurpose     : SPINBOX header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef SPINBOX_H
N#define SPINBOX_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h" // Required for Create indirect data structure
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N#include "EDIT.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       States
N*/
N#define SPINBOX_STATE_PRESSED(x)     (U8)(1 << (U8)x)    // These flags are stored in (SPINBOX_OBJ->State)        | x must be 0 or 1
N#define SPINBOX_STATE_FOCUS          WIDGET_STATE_FOCUS  // This is read from         (SPINBOX_OBJ->Widget.State)
N
N#define SPINBOX_EDGE_RIGHT           0
N#define SPINBOX_EDGE_LEFT            1
N#define SPINBOX_EDGE_CENTER          2
N
N#define SPINBOX_EM_STEP              0
N#define SPINBOX_EM_EDIT              1
N
N#ifndef SPINBOX_EM_DEFAULT
N  #define SPINBOX_EM_DEFAULT         SPINBOX_EM_STEP
N#endif
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define SPINBOX_CI_DISABLED          EDIT_CI_DISABLED
N#define SPINBOX_CI_ENABLED           EDIT_CI_ENABLED
N#define SPINBOX_CI_PRESSED           2
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define SPINBOX_SKIN_FLEX            SPINBOX_DrawSkinFlex
N
N#define SPINBOX_SKINFLEX_PI_PRESSED  0
N#define SPINBOX_SKINFLEX_PI_FOCUSSED 1
N#define SPINBOX_SKINFLEX_PI_ENABLED  2
N#define SPINBOX_SKINFLEX_PI_DISABLED 3
N#define SPINBOX_SKIN_FLEX_RADIUS     2
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SPINBOX_Handle;
Xtypedef signed long SPINBOX_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];   // [0] Outer color of surrounding frame.         [1] Inner color of surrounding frame.
N  GUI_COLOR aColorUpper[2];   // [0] Upper color of gradient for upper button. [1] Lower color of gradient for upper button.
N  GUI_COLOR aColorLower[2];   // [0] Upper color of gradient for lower button. [1] Lower color of gradient for lower button.
N  GUI_COLOR ColorArrow;       // Color of the button arrow.
N  GUI_COLOR ColorBk;          // Color of the background.                      // See WIDGET_ITEM_CREATE in SPINBOX_DrawSkinFlex()
N  GUI_COLOR ColorText;        // Color of the text.                            // See WIDGET_ITEM_CREATE in SPINBOX_DrawSkinFlex()
N  GUI_COLOR ColorButtonFrame; // Color of the button frame.
N} SPINBOX_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Creation
N*/
NSPINBOX_Handle SPINBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int Min, int Max);
XSPINBOX_Handle SPINBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int Min, int Max);
NSPINBOX_Handle SPINBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int Min, int Max, int NumExtraBytes);
XSPINBOX_Handle SPINBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int Min, int Max, int NumExtraBytes);
NSPINBOX_Handle SPINBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSPINBOX_Handle SPINBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Callback, should be called only from within a custom callback.
N*/
Nvoid           SPINBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Get / Set properties
N*/
Nvoid        SPINBOX_EnableBlink     (SPINBOX_Handle hObj, int Period, int OnOff);
NGUI_COLOR   SPINBOX_GetBkColor      (SPINBOX_Handle hObj, unsigned int Index);
NGUI_COLOR   SPINBOX_GetButtonBkColor(SPINBOX_Handle hObj, unsigned int Index);
NEDIT_Handle SPINBOX_GetEditHandle   (SPINBOX_Handle hObj);
Nint         SPINBOX_GetUserData     (SPINBOX_Handle hObj, void * pDest, int NumBytes);
NI32         SPINBOX_GetValue        (SPINBOX_Handle hObj);
Xsigned long         SPINBOX_GetValue        (SPINBOX_Handle hObj);
Nvoid        SPINBOX_SetBkColor      (SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid        SPINBOX_SetButtonBkColor(SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid        SPINBOX_SetButtonSize   (SPINBOX_Handle hObj, unsigned ButtonSize);
Nvoid        SPINBOX_SetEdge         (SPINBOX_Handle hObj, U8 Edge);
Xvoid        SPINBOX_SetEdge         (SPINBOX_Handle hObj, unsigned char Edge);
Nvoid        SPINBOX_SetEditMode     (SPINBOX_Handle hObj, U8 EditMode);
Xvoid        SPINBOX_SetEditMode     (SPINBOX_Handle hObj, unsigned char EditMode);
Nvoid        SPINBOX_SetFont         (SPINBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid        SPINBOX_SetRange        (SPINBOX_Handle hObj, I32 Min, I32 Max);
Xvoid        SPINBOX_SetRange        (SPINBOX_Handle hObj, signed long Min, signed long Max);
NU16         SPINBOX_SetStep         (SPINBOX_Handle hObj, U16 Step);
Xunsigned short         SPINBOX_SetStep         (SPINBOX_Handle hObj, unsigned short Step);
Nvoid        SPINBOX_SetTextColor    (SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nint         SPINBOX_SetUserData     (SPINBOX_Handle hObj, const void * pSrc, int NumBytes);
Nvoid        SPINBOX_SetValue        (SPINBOX_Handle hObj, I32 Value);
Xvoid        SPINBOX_SetValue        (SPINBOX_Handle hObj, signed long Value);
N
N/*********************************************************************
N*
N*       Managing default values
N*/
NU16  SPINBOX_GetDefaultButtonSize(void);
Xunsigned short  SPINBOX_GetDefaultButtonSize(void);
Nvoid SPINBOX_SetDefaultButtonSize(U16 ButtonSize);
Xvoid SPINBOX_SetDefaultButtonSize(unsigned short ButtonSize);
N
N/*********************************************************************
N*
N*       Skinning
N*/
Nvoid                    SPINBOX_GetSkinFlexProps     (SPINBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    SPINBOX_SetSkinClassic       (SPINBOX_Handle hObj);
Nvoid                    SPINBOX_SetSkin              (SPINBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint                     SPINBOX_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    SPINBOX_SetSkinFlexProps     (const SPINBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    SPINBOX_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SPINBOX_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SPINBOX_H
N
N/*************************** End of file ****************************/
L 81 "..\STemWin\inc\DIALOG.h" 2
N#include "TEXT.h"
L 1 "..\STemWin\inc\TEXT.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : TEXT.h
NPurpose     : TEXT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef TEXT_H
N#define TEXT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       #defines
N*
N*************************************************************
N*/
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define TEXT_CF_LEFT    GUI_TA_LEFT
N#define TEXT_CF_RIGHT   GUI_TA_RIGHT
N#define TEXT_CF_HCENTER GUI_TA_HCENTER
N
N#define TEXT_CF_VCENTER GUI_TA_VCENTER
N#define TEXT_CF_TOP     GUI_TA_TOP
N#define TEXT_CF_BOTTOM  GUI_TA_BOTTOM
N
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N
N*/
Ntypedef WM_HMEM TEXT_Handle;
Xtypedef signed long TEXT_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTEXT_Handle TEXT_Create        (int x0, int y0, int xSize, int ySize, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, const char * s, int Align);
XTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
XTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
NTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
XTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
NTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TEXT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
NGUI_COLOR        TEXT_GetBkColor  (TEXT_Handle hObj); 
Nconst GUI_FONT * TEXT_GetFont     (TEXT_Handle hObj);
Nint              TEXT_GetNumLines (TEXT_Handle hObj);
Nint              TEXT_GetText     (TEXT_Handle hObj, char * pDest, U32 BufferSize);
Xint              TEXT_GetText     (TEXT_Handle hObj, char * pDest, unsigned long BufferSize);
Nint              TEXT_GetTextAlign(TEXT_Handle hObj);
NGUI_COLOR        TEXT_GetTextColor(TEXT_Handle hObj);
Nint              TEXT_GetUserData (TEXT_Handle hObj, void * pDest, int NumBytes);
NGUI_WRAPMODE     TEXT_GetWrapMode (TEXT_Handle hObj);
Nvoid             TEXT_SetBkColor  (TEXT_Handle hObj, GUI_COLOR Color);
Nvoid             TEXT_SetFont     (TEXT_Handle hObj, const GUI_FONT * pFont);
Nint              TEXT_SetText     (TEXT_Handle hObj, const char * s);
Nvoid             TEXT_SetTextAlign(TEXT_Handle hObj, int Align);
Nvoid             TEXT_SetTextColor(TEXT_Handle hObj, GUI_COLOR Color);
Nint              TEXT_SetUserData (TEXT_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             TEXT_SetWrapMode (TEXT_Handle hObj, GUI_WRAPMODE WrapMode);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT * TEXT_GetDefaultFont     (void);
NGUI_COLOR        TEXT_GetDefaultTextColor(void);
NGUI_WRAPMODE     TEXT_GetDefaultWrapMode (void);
Nvoid             TEXT_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             TEXT_SetDefaultTextColor(GUI_COLOR Color);
NGUI_WRAPMODE     TEXT_SetDefaultWrapMode (GUI_WRAPMODE WrapMode);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TEXT_H
N
N/*************************** End of file ****************************/
L 82 "..\STemWin\inc\DIALOG.h" 2
N#include "TREEVIEW.h"
L 1 "..\STemWin\inc\TREEVIEW.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : TREEVIEW.h
NPurpose     : TREEVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef TREEVIEW_H
N#define TREEVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/* Status- and create flags */
N#define TREEVIEW_CF_HIDELINES       (1 << 0)
N#define TREEVIEW_CF_ROWSELECT       (1 << 1)
N#define TREEVIEW_CF_AUTOSCROLLBAR_H (1 << 2)
N#define TREEVIEW_CF_AUTOSCROLLBAR_V (1 << 3)
N#define TREEVIEW_SF_HIDELINES       TREEVIEW_CF_HIDELINES
N#define TREEVIEW_SF_ROWSELECT       TREEVIEW_CF_ROWSELECT
N#define TREEVIEW_SF_AUTOSCROLLBAR_H TREEVIEW_CF_AUTOSCROLLBAR_H
N#define TREEVIEW_SF_AUTOSCROLLBAR_V TREEVIEW_CF_AUTOSCROLLBAR_V
N
N/* Bitmap indices */
N#define TREEVIEW_BI_CLOSED 0
N#define TREEVIEW_BI_OPEN   1
N#define TREEVIEW_BI_LEAF   2
N#define TREEVIEW_BI_PLUS   3
N#define TREEVIEW_BI_MINUS  4
N#define TREEVIEW_BI_PM     5
N
N/* Color indices */
N#define TREEVIEW_CI_UNSEL    0
N#define TREEVIEW_CI_SEL      1
N#define TREEVIEW_CI_DISABLED 2
N
N/* Relative positions (create) */
N#define TREEVIEW_INSERT_ABOVE       0
N#define TREEVIEW_INSERT_BELOW       1
N#define TREEVIEW_INSERT_FIRST_CHILD 2
N
N/* Relative positions (retrieve) */
N#define TREEVIEW_GET_FIRST        0
N#define TREEVIEW_GET_LAST         1
N#define TREEVIEW_GET_NEXT_SIBLING 2
N#define TREEVIEW_GET_PREV_SIBLING 3
N#define TREEVIEW_GET_FIRST_CHILD  4
N#define TREEVIEW_GET_PARENT       5
N
N/* Item flags */
N#define TREEVIEW_ITEM_TYPE_LEAF (0 << 0)
N#define TREEVIEW_ITEM_TYPE_NODE (1 << 0)
N
N/* Selection mode */
N#define TREEVIEW_SELMODE_ROW  1
N#define TREEVIEW_SELMODE_TEXT 0
N
N/************************************************************
N*
N*       Types
N*
N*************************************************************
N*/
Ntypedef WM_HMEM TREEVIEW_Handle;
Xtypedef signed long TREEVIEW_Handle;
Ntypedef WM_HMEM TREEVIEW_ITEM_Handle;
Xtypedef signed long TREEVIEW_ITEM_Handle;
N
Ntypedef struct {
N  int IsNode;
N  int IsExpanded;
N  int HasLines;
N  int HasRowSelect;
N  int Level;
N} TREEVIEW_ITEM_INFO;
N
Ntypedef struct {
N  GUI_COLOR ColorBk;
N  GUI_COLOR ColorText;
N  GUI_COLOR ColorTextBk;
N  GUI_COLOR ColorLines;
N  GUI_RECT rText;
N  TREEVIEW_ITEM_Handle hItem;
N  const GUI_FONT * pFont;
N  char * pText;
N  U8 NumLines;
X  unsigned char NumLines;
N  I16 ax0[3];
X  signed short ax0[3];
N  I16 ay0[3];
X  signed short ay0[3];
N  I16 ax1[3];
X  signed short ax1[3];
N  I16 ay1[3];
X  signed short ay1[3];
N  U8 NumConnectors;
X  unsigned char NumConnectors;
N  I16 axc[16];
X  signed short axc[16];
N  const GUI_BITMAP * pBmPM;
N  const GUI_BITMAP * pBmOCL;
N  I16 xPosPM, xPosOCL;
X  signed short xPosPM, xPosOCL;
N  U8 IndexPM;
X  unsigned char IndexPM;
N  U8 IndexOCL;
X  unsigned char IndexOCL;
N} TREEVIEW_ITEM_DRAW_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTREEVIEW_Handle      TREEVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XTREEVIEW_Handle      TREEVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NTREEVIEW_Handle      TREEVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XTREEVIEW_Handle      TREEVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NTREEVIEW_Handle      TREEVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTREEVIEW_Handle      TREEVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TREEVIEW_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Common functions
N*
N**********************************************************************
N*/
Nint                  TREEVIEW_AttachItem     (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem, TREEVIEW_ITEM_Handle hItemAt, int Position);
Nvoid                 TREEVIEW_DecSel         (TREEVIEW_Handle hObj);
NTREEVIEW_ITEM_Handle TREEVIEW_GetItem        (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem, int Flags);
NTREEVIEW_ITEM_Handle TREEVIEW_GetSel         (TREEVIEW_Handle hObj);
Nint                  TREEVIEW_GetUserData    (TREEVIEW_Handle hObj, void * pDest, int NumBytes);
Nvoid                 TREEVIEW_IncSel         (TREEVIEW_Handle hObj);
NTREEVIEW_ITEM_Handle TREEVIEW_InsertItem     (TREEVIEW_Handle hObj, int IsNode, TREEVIEW_ITEM_Handle hItemPrev, int Position, const char * s);
Nint                  TREEVIEW_OwnerDraw      (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                 TREEVIEW_ScrollToSel    (TREEVIEW_Handle hObj);
Nvoid                 TREEVIEW_SetAutoScrollH (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetAutoScrollV (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetBitmapOffset(TREEVIEW_Handle hObj, int Index, int xOff, int yOff);
Nvoid                 TREEVIEW_SetBkColor     (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nvoid                 TREEVIEW_SetFont        (TREEVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid                 TREEVIEW_SetHasLines    (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetImage       (TREEVIEW_Handle hObj, int Index, const GUI_BITMAP * pBitmap);
Nint                  TREEVIEW_SetIndent      (TREEVIEW_Handle hObj, int Indent);
Nvoid                 TREEVIEW_SetLineColor   (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nvoid                 TREEVIEW_SetOwnerDraw   (TREEVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid                 TREEVIEW_SetSel         (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_SetSelMode     (TREEVIEW_Handle hObj, int Mode);
Nvoid                 TREEVIEW_SetTextColor   (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint                  TREEVIEW_SetTextIndent  (TREEVIEW_Handle hObj, int TextIndent);
Nint                  TREEVIEW_SetUserData    (TREEVIEW_Handle hObj, const void * pSrc, int NumBytes);
N
N
N/*********************************************************************
N*
N*       Treeview item related functions
N*
N**********************************************************************
N*/
Nvoid                 TREEVIEW_ITEM_Collapse   (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_CollapseAll(TREEVIEW_ITEM_Handle hItem);
NTREEVIEW_ITEM_Handle TREEVIEW_ITEM_Create     (int IsNode, const char * s, U32 UserData);
XTREEVIEW_ITEM_Handle TREEVIEW_ITEM_Create     (int IsNode, const char * s, unsigned long UserData);
Nvoid                 TREEVIEW_ITEM_Delete     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_Detach     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_Expand     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_ExpandAll  (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_GetInfo    (TREEVIEW_ITEM_Handle hItem, TREEVIEW_ITEM_INFO * pInfo);
Nvoid                 TREEVIEW_ITEM_GetText    (TREEVIEW_ITEM_Handle hItem, U8 * pBuffer, int MaxNumBytes);
Xvoid                 TREEVIEW_ITEM_GetText    (TREEVIEW_ITEM_Handle hItem, unsigned char * pBuffer, int MaxNumBytes);
NU32                  TREEVIEW_ITEM_GetUserData(TREEVIEW_ITEM_Handle hItem);
Xunsigned long                  TREEVIEW_ITEM_GetUserData(TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_SetImage   (TREEVIEW_ITEM_Handle hItem, int Index, const GUI_BITMAP * pBitmap);
NTREEVIEW_ITEM_Handle TREEVIEW_ITEM_SetText    (TREEVIEW_ITEM_Handle hItem, const char * s);
Nvoid                 TREEVIEW_ITEM_SetUserData(TREEVIEW_ITEM_Handle hItem, U32 UserData);
Xvoid                 TREEVIEW_ITEM_SetUserData(TREEVIEW_ITEM_Handle hItem, unsigned long UserData);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        TREEVIEW_GetDefaultBkColor  (int Index);
Nconst GUI_FONT * TREEVIEW_GetDefaultFont     (void);
NGUI_COLOR        TREEVIEW_GetDefaultLineColor(int Index);
NGUI_COLOR        TREEVIEW_GetDefaultTextColor(int Index);
Nvoid             TREEVIEW_SetDefaultBkColor  (int Index, GUI_COLOR Color);
Nvoid             TREEVIEW_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             TREEVIEW_SetDefaultLineColor(int Index, GUI_COLOR Color);
Nvoid             TREEVIEW_SetDefaultTextColor(int Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TREEVIEW_H
N
N/*************************** End of file ****************************/
L 83 "..\STemWin\inc\DIALOG.h" 2
N#include "KNOB.h"
L 1 "..\STemWin\inc\KNOB.h" 1
N/*********************************************************************
N*          Portions COPYRIGHT 2016 STMicroelectronics                *
N*          Portions SEGGER Microcontroller GmbH & Co. KG             *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2015  SEGGER Microcontroller GmbH & Co. KG       *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.32 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights  in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product.  This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed  to STMicroelectronics International
NN.V. a Dutch company with a Swiss branch and its headquarters in Plan-
Nles-Ouates, Geneva, 39 Chemin du Champ des Filles, Switzerland for the
Npurposes of creating libraries for ARM Cortex-M-based 32-bit microcon_
Ntroller products commercialized by Licensee only, sublicensed and dis_
Ntributed under the terms and conditions of the End User License Agree_
Nment supplied by STMicroelectronics International N.V.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NFile        : KNOB.h
NPurpose     : KNOB include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N/**
N  ******************************************************************************
N  * @attention
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N#ifndef KNOB_H
N#define KNOB_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if ((1) && (1))
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM KNOB_Handle;
Xtypedef signed long KNOB_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NKNOB_Handle KNOB_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id);
XKNOB_Handle KNOB_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id);
NKNOB_Handle KNOB_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
XKNOB_Handle KNOB_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
NKNOB_Handle KNOB_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XKNOB_Handle KNOB_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid KNOB_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid KNOB_AddValue   (KNOB_Handle hObj, I32 Value);
Xvoid KNOB_AddValue   (KNOB_Handle hObj, signed long Value);
Nint  KNOB_GetUserData(KNOB_Handle hObj, void * pDest, int NumBytes);               // Gets user defined data
NI32  KNOB_GetValue   (KNOB_Handle hObj);                                           // Returns the position of the knob in tenth of degree
Xsigned long  KNOB_GetValue   (KNOB_Handle hObj);                                           
Nvoid KNOB_SetBkColor (KNOB_Handle hObj, GUI_COLOR Color);                          // Sets the BK color of the widget
Nvoid KNOB_SetBkDevice(KNOB_Handle hObj, GUI_MEMDEV_Handle hMemBk);                 // Sets the background device
Nvoid KNOB_SetDevice  (KNOB_Handle hObj, GUI_MEMDEV_Handle hMemSrc);                // Sets the memory device with the drawn knob
Nvoid KNOB_SetKeyValue(KNOB_Handle hObj, I32 KeyValue);                             // Sets the value the knob will rotate on one key press
Xvoid KNOB_SetKeyValue(KNOB_Handle hObj, signed long KeyValue);                             
Nvoid KNOB_SetOffset  (KNOB_Handle hObj, I32 Offset);                               // Sets the offset angle of the knob
Xvoid KNOB_SetOffset  (KNOB_Handle hObj, signed long Offset);                               
Nvoid KNOB_SetPeriod  (KNOB_Handle hObj, I32 Period);                               // Sets the period in which the knob stops
Xvoid KNOB_SetPeriod  (KNOB_Handle hObj, signed long Period);                               
Nvoid KNOB_SetPos     (KNOB_Handle hObj, I32 Pos);                                  // Sets position of the knob in tenth of degree
Xvoid KNOB_SetPos     (KNOB_Handle hObj, signed long Pos);                                  
Nvoid KNOB_SetRange   (KNOB_Handle hObj, I32 MinRange, I32 MaxRange);               // Sets the usable range of the knob widget
Xvoid KNOB_SetRange   (KNOB_Handle hObj, signed long MinRange, signed long MaxRange);               
Nvoid KNOB_SetSnap    (KNOB_Handle hObj, I32 Snap);                                 // Sets Snap positions where the knob stops
Xvoid KNOB_SetSnap    (KNOB_Handle hObj, signed long Snap);                                 
Nvoid KNOB_SetTickSize(KNOB_Handle hObj, I32 TickSize);                             // Sets the ticksize, in 1/10 of degree
Xvoid KNOB_SetTickSize(KNOB_Handle hObj, signed long TickSize);                             
Nint  KNOB_SetUserData(KNOB_Handle hObj, const void * pSrc, int NumBytes);          // Sets user defined data
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // KNOB_H
N
N/*************************** End of file ****************************/
L 84 "..\STemWin\inc\DIALOG.h" 2
N
N#if GUI_WINSUPPORT
X#if (1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       WINDOW API
N*/
NWM_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
XGUI_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
NWM_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGUI_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NGUI_COLOR WINDOW_GetDefaultBkColor(void);
Nint       WINDOW_GetUserData      (WM_HWIN hObj, void * pDest, int NumBytes);
Xint       WINDOW_GetUserData      (GUI_HWIN hObj, void * pDest, int NumBytes);
Nvoid      WINDOW_SetBkColor       (WM_HWIN hObj, GUI_COLOR Color);
Xvoid      WINDOW_SetBkColor       (GUI_HWIN hObj, GUI_COLOR Color);
Nvoid      WINDOW_SetDefaultBkColor(GUI_COLOR Color);
Nint       WINDOW_SetUserData      (WM_HWIN hObj, const void * pSrc, int NumBytes);
Xint       WINDOW_SetUserData      (GUI_HWIN hObj, const void * pSrc, int NumBytes);
N
Nvoid WINDOW_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_H
N
N/*************************** End of file ****************************/
L 21 "..\User\emWinTask\MainTask.h" 2
N#include "WM.h"
N#include "BUTTON.h"
N#include "CHECKBOX.h"
N#include "DROPDOWN.h"
N#include "EDIT.h"
N#include "FRAMEWIN.h"
N#include "LISTBOX.h"
N#include "MULTIEDIT.h"
N#include "RADIO.h"
N#include "SLIDER.h"
N#include "TEXT.h"
N#include "PROGBAR.h"
N#include "SCROLLBAR.h"
N#include "LISTVIEW.h"
N#include "GRAPH.h"
N#include "MENU.h"
N#include "MULTIPAGE.h"
N#include "ICONVIEW.h"
N#include "TREEVIEW.h"
N
N#include "ff.h"
L 1 "..\FatFS\src\ff.h" 1
N/*----------------------------------------------------------------------------/
N/  FatFs - Generic FAT file system module  R0.12b                             /
N/-----------------------------------------------------------------------------/
N/
N/ Copyright (C) 2016, ChaN, all right reserved.
N/
N/ FatFs module is an open source software. Redistribution and use of FatFs in
N/ source and binary forms, with or without modification, are permitted provided
N/ that the following condition is met:
N
N/ 1. Redistributions of source code must retain the above copyright notice,
N/    this condition and the following disclaimer.
N/
N/ This software is provided by the copyright holder and contributors "AS IS"
N/ and any warranties related to this software are DISCLAIMED.
N/ The copyright owner or contributors be NOT LIABLE for any damages caused
N/ by use of this software.
N/----------------------------------------------------------------------------*/
N
N
N#ifndef _FATFS
N#define _FATFS	68020	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\FatFS\src\integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _FF_INTEGER
N#define _FF_INTEGER
N
N#ifdef _WIN32	/* FatFs development platform */
S
S#include <windows.h>
S#include <tchar.h>
Stypedef unsigned __int64 QWORD;
S
S
N#else			/* Embedded platform */
N
N/* These types MUST be 16-bit or 32-bit */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* This type MUST be 8-bit */
Ntypedef unsigned char	BYTE;
N
N/* These types MUST be 16-bit */
Ntypedef short			SHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types MUST be 32-bit */
Ntypedef long			LONG;
Ntypedef unsigned long	DWORD;
N
N/* This type MUST be 64-bit (Remove this for C89 compatibility) */
Ntypedef unsigned long long QWORD;
N
N#endif
N
N#endif
L 29 "..\FatFS\src\ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\FatFS\src\ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file
N/---------------------------------------------------------------------------*/
N
N#define _FFCONF 68020	/* Revision ID */
N
N/*---------------------------------------------------------------------------/
N/ Function Configurations
N/---------------------------------------------------------------------------*/
N
N#define _FS_READONLY	0
N/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
N/  Read-only configuration removes writing API functions, f_write(), f_sync(),
N/  f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(), f_getfree()
N/  and optional writing functions as well. */
N
N
N#define _FS_MINIMIZE	0
N/* This option defines minimization level to remove some basic API functions.
N/
N/   0: All basic functions are enabled.
N/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename()
N/      are removed.
N/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
N/   3: f_lseek() function is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	0
N/* This option switches string functions, f_gets(), f_putc(), f_puts() and
N/  f_printf().
N/
N/  0: Disable string functions.
N/  1: Enable without LF-CRLF conversion.
N/  2: Enable with LF-CRLF conversion. */
N
N
N#define _USE_FIND		0
N/* This option switches filtered directory read functions, f_findfirst() and
N/  f_findnext(). (0:Disable, 1:Enable 2:Enable with matching altname[] too) */
N
N
N#define	_USE_MKFS		0
N/* This option switches f_mkfs() function. (0:Disable or 1:Enable) */
N
N
N#define	_USE_FASTSEEK	0
N/* This option switches fast seek function. (0:Disable or 1:Enable) */
N
N
N#define	_USE_EXPAND		0
N/* This option switches f_expand function. (0:Disable or 1:Enable) */
N
N
N#define _USE_CHMOD		0
N/* This option switches attribute manipulation functions, f_chmod() and f_utime().
N/  (0:Disable or 1:Enable) Also _FS_READONLY needs to be 0 to enable this option. */
N
N
N#define _USE_LABEL		0
N/* This option switches volume label functions, f_getlabel() and f_setlabel().
N/  (0:Disable or 1:Enable) */
N
N
N#define	_USE_FORWARD	0
N/* This option switches f_forward() function. (0:Disable or 1:Enable) */
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/---------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	936
N/* This option specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   1   - ASCII (No extended character. Non-LFN cfg. only)
N/   437 - U.S.
N/   720 - Arabic
N/   737 - Greek
N/   771 - KBL
N/   775 - Baltic
N/   850 - Latin 1
N/   852 - Latin 2
N/   855 - Cyrillic
N/   857 - Turkish
N/   860 - Portuguese
N/   861 - Icelandic
N/   862 - Hebrew
N/   863 - Canadian French
N/   864 - Arabic
N/   865 - Nordic
N/   866 - Russian
N/   869 - Greek 2
N/   932 - Japanese (DBCS)
N/   936 - Simplified Chinese (DBCS)
N/   949 - Korean (DBCS)
N/   950 - Traditional Chinese (DBCS)
N*/
N
N
N#define	_USE_LFN	1 //使用长文件名
N#define	_MAX_LFN	255
N/* The _USE_LFN switches the support of long file name (LFN).
N/
N/   0: Disable support of LFN. _MAX_LFN has no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  To enable the LFN, Unicode handling functions (option/unicode.c) must be added
N/  to the project. The working buffer occupies (_MAX_LFN + 1) * 2 bytes and
N/  additional 608 bytes at exFAT enabled. _MAX_LFN can be in range from 12 to 255.
N/  It should be set 255 to support full featured LFN operations.
N/  When use stack for the working buffer, take care on stack overflow. When use heap
N/  memory for the working buffer, memory management functions, ff_memalloc() and
N/  ff_memfree(), must be added to the project. */
N
N
N#define	_LFN_UNICODE	0
N/* This option switches character encoding on the API. (0:ANSI/OEM or 1:UTF-16)
N/  To use Unicode string for the path name, enable LFN and set _LFN_UNICODE = 1.
N/  This option also affects behavior of string I/O functions. */
N
N
N#define _STRF_ENCODE	3
N/* When _LFN_UNICODE == 1, this option selects the character encoding ON THE FILE to
N/  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
N/
N/  0: ANSI/OEM
N/  1: UTF-16LE
N/  2: UTF-16BE
N/  3: UTF-8
N/
N/  This option has no effect when _LFN_UNICODE == 0. */
N
N
N#define _FS_RPATH	0
N/* This option configures support of relative path.
N/
N/   0: Disable relative path and remove related functions.
N/   1: Enable relative path. f_chdir() and f_chdrive() are available.
N/   2: f_getcwd() function is available in addition to 1.
N*/
N
N
N/*---------------------------------------------------------------------------/
N/ Drive/Volume Configurations
N/---------------------------------------------------------------------------*/
N
N#define _VOLUMES	1
N/* Number of volumes (logical drives) to be used. */
N
N
N#define _STR_VOLUME_ID	0
N#define _VOLUME_STRS	"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"
N/* _STR_VOLUME_ID switches string support of volume ID.
N/  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
N/  number in the path name. _VOLUME_STRS defines the drive ID strings for each
N/  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
N/  the drive ID strings are: A-Z and 0-9. */
N
N
N#define	_MULTI_PARTITION	0
N/* This option switches support of multi-partition on a physical drive.
N/  By default (0), each logical drive number is bound to the same physical drive
N/  number and only an FAT volume found on the physical drive will be mounted.
N/  When multi-partition is enabled (1), each logical drive number can be bound to
N/  arbitrary physical drive and partition listed in the VolToPart[]. Also f_fdisk()
N/  funciton will be available. */
N
N
N#define	_MIN_SS		512
N#define	_MAX_SS		512
N/* These options configure the range of sector size to be supported. (512, 1024,
N/  2048 or 4096) Always set both 512 for most systems, all type of memory cards and
N/  harddisk. But a larger value may be required for on-board flash memory and some
N/  type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured
N/  to variable sector size and GET_SECTOR_SIZE command must be implemented to the
N/  disk_ioctl() function. */
N
N
N#define	_USE_TRIM	0
N/* This option switches support of ATA-TRIM. (0:Disable or 1:Enable)
N/  To enable Trim function, also CTRL_TRIM command should be implemented to the
N/  disk_ioctl() function. */
N
N
N#define _FS_NOFSINFO	0
N/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
N/  option, and f_getfree() function at first time after volume mount will force
N/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
N/
N/  bit0=0: Use free cluster count in the FSINFO if available.
N/  bit0=1: Do not trust free cluster count in the FSINFO.
N/  bit1=0: Use last allocated cluster number in the FSINFO if available.
N/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
N*/
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/---------------------------------------------------------------------------*/
N
N#define	_FS_TINY	0
N/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
N/  At the tiny configuration, size of file object (FIL) is reduced _MAX_SS bytes.
N/  Instead of private sector buffer eliminated from the file object, common sector
N/  buffer in the file system object (FATFS) is used for the file data transfer. */
N
N
N#define _FS_EXFAT	0
N/* This option switches support of exFAT file system. (0:Disable or 1:Enable)
N/  When enable exFAT, also LFN needs to be enabled. (_USE_LFN >= 1)
N/  Note that enabling exFAT discards C89 compatibility. */
N
N
N#define _FS_NORTC	0
N#define _NORTC_MON	1
N#define _NORTC_MDAY	1
N#define _NORTC_YEAR	2016
N/* The option _FS_NORTC switches timestamp functiton. If the system does not have
N/  any RTC function or valid timestamp is not needed, set _FS_NORTC = 1 to disable
N/  the timestamp function. All objects modified by FatFs will have a fixed timestamp
N/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR in local time.
N/  To enable timestamp function (_FS_NORTC = 0), get_fattime() function need to be
N/  added to the project to get current time form real-time clock. _NORTC_MON,
N/  _NORTC_MDAY and _NORTC_YEAR have no effect. 
N/  These options have no effect at read-only configuration (_FS_READONLY = 1). */
N
N
N#define	_FS_LOCK	0
N/* The option _FS_LOCK switches file lock function to control duplicated file open
N/  and illegal operation to open objects. This option must be 0 when _FS_READONLY
N/  is 1.
N/
N/  0:  Disable file lock function. To avoid volume corruption, application program
N/      should avoid illegal open, remove and rename to the open objects.
N/  >0: Enable file lock function. The value defines how many files/sub-directories
N/      can be opened simultaneously under file lock control. Note that the file
N/      lock control is independent of re-entrancy. */
N
N
N#define _FS_REENTRANT	0
N#define _FS_TIMEOUT		1000
N#define	_SYNC_t			HANDLE
N/* The option _FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs
N/  module itself. Note that regardless of this option, file access to different
N/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
N/  and f_fdisk() function, are always not re-entrant. Only file/directory access
N/  to the same volume is under control of this function.
N/
N/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
N/   1: Enable re-entrancy. Also user provided synchronization handlers,
N/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
N/      function, must be added to the project. Samples are available in
N/      option/syscall.c.
N/
N/  The _FS_TIMEOUT defines timeout period in unit of time tick.
N/  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
N/  SemaphoreHandle_t and etc.. A header file for O/S definitions needs to be
N/  included somewhere in the scope of ff.h. */
N
N/* #include <windows.h>	// O/S definitions  */
N
N
N/*--- End of configuration options ---*/
L 30 "..\FatFS\src\ff.h" 2
N
N#if _FATFS != _FFCONF
X#if 68020 != 68020
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode (UTF-16) string */
X#if 0			 
S#if _USE_LFN == 0
S#error _LFN_UNICODE must be 0 at non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N#endif
N
N
N
N/* Type of file size variables */
N
N#if _FS_EXFAT
X#if 0
S#if _USE_LFN == 0
S#error LFN must be enabled when enable exFAT
S#endif
Stypedef QWORD FSIZE_t;
N#else
Ntypedef DWORD FSIZE_t;
N#endif
N
N
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* File system type (0:N/A) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	n_fats;			/* Number of FATs (1 or 2) */
N	BYTE	wflag;			/* win[] flag (b0:dirty) */
N	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N	WORD	csize;			/* Cluster size [sectors] */
N#if _MAX_SS != _MIN_SS
X#if 512 != 512
S	WORD	ssize;			/* Sector size (512, 1024, 2048 or 4096) */
N#endif
N#if _USE_LFN != 0
X#if 1 != 0
N	WCHAR*	lfnbuf;			/* LFN working buffer */
N#endif
N#if _FS_EXFAT
X#if 0
S	BYTE*	dirbuf;			/* Directory entry block scratchpad buffer */
N#endif
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;			/* Identifier of sync object */
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clst;		/* Last allocated cluster */
N	DWORD	free_clst;		/* Number of free clusters */
N#endif
N#if _FS_RPATH != 0
X#if 0 != 0
S	DWORD	cdir;			/* Current directory start cluster (0:root) */
S#if _FS_EXFAT
S	DWORD	cdc_scl;		/* Containing directory start cluster (invalid when cdir is 0) */
S	DWORD	cdc_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status */
S	DWORD	cdc_ofs;		/* Offset in the containing directory (invalid when cdir is 0) */
S#endif
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries (number of clusters + 2) */
N	DWORD	fsize;			/* Size of an FAT [sectors] */
N	DWORD	volbase;		/* Volume base sector */
N	DWORD	fatbase;		/* FAT base sector */
N	DWORD	dirbase;		/* Root directory base sector/cluster */
N	DWORD	database;		/* Data base sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
X	BYTE	win[512];	 
N} FATFS;
N
N
N
N/* Object ID and allocation information (_FDID) */
N
Ntypedef struct {
N	FATFS*	fs;			/* Pointer to the owner file system object */
N	WORD	id;			/* Owner file system mount ID */
N	BYTE	attr;		/* Object attribute */
N	BYTE	stat;		/* Object chain status (b1-0: =0:not contiguous, =2:contiguous (no data on FAT), =3:got flagmented, b2:sub-directory stretched) */
N	DWORD	sclust;		/* Object start cluster (0:no cluster or root directory) */
N	FSIZE_t	objsize;	/* Object size (valid when sclust != 0) */
N#if _FS_EXFAT
X#if 0
S	DWORD	n_cont;		/* Size of coutiguous part, clusters - 1 (valid when stat == 3) */
S	DWORD	c_scl;		/* Containing directory start cluster (valid when sclust != 0) */
S	DWORD	c_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status (valid when c_scl != 0) */
S	DWORD	c_ofs;		/* Offset in the containing directory (valid when sclust != 0) */
N#endif
N#if _FS_LOCK != 0
X#if 0 != 0
S	UINT	lockid;		/* File lock ID origin from 1 (index of file semaphore table Files[]) */
N#endif
N} _FDID;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	_FDID	obj;			/* Object identifier (must be the 1st member to detect invalid object pointer) */
N	BYTE	flag;			/* File status flags */
N	BYTE	err;			/* Abort flag (error code) */
N	FSIZE_t	fptr;			/* File read/write pointer (Zeroed on file open) */
N	DWORD	clust;			/* Current cluster of fpter (invalid when fprt is 0) */
N	DWORD	sect;			/* Sector number appearing in buf[] (0:invalid) */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;		/* Sector number containing the directory entry */
N	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
N#endif
N#if _USE_FASTSEEK
X#if 0
S	DWORD*	cltbl;			/* Pointer to the cluster link map table (nulled on open, set by application) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File private data read/write window */
X	BYTE	buf[512];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	_FDID	obj;			/* Object identifier */
N	DWORD	dptr;			/* Current read/write offset */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the directory item in the win[] */
N	BYTE	fn[12];			/* SFN (in/out) {body[8],ext[3],status[1]} */
N#if _USE_LFN != 0
X#if 1 != 0
N	DWORD	blk_ofs;		/* Offset of current entry block being processed (0xFFFFFFFF:Invalid) */
N#endif
N#if _USE_FIND
X#if 0
S	const TCHAR* pat;		/* Pointer to the name matching pattern */
N#endif
N} DIR;
N
N
N
N/* File information structure (FILINFO) */
N
Ntypedef struct {
N	FSIZE_t	fsize;			/* File size */
N	WORD	fdate;			/* Modified date */
N	WORD	ftime;			/* Modified time */
N	BYTE	fattrib;		/* File attribute */
N#if _USE_LFN != 0
X#if 1 != 0
N	TCHAR	altname[13];			/* Altenative file name */
N	TCHAR	fname[_MAX_LFN + 1];	/* Primary file name */
X	TCHAR	fname[255 + 1];	 
N#else
S	TCHAR	fname[13];		/* File name */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any problem */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
NFRESULT f_close (FIL* fp);											/* Close an open file object */
NFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from the file */
NFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to the file */
NFRESULT f_lseek (FIL* fp, FSIZE_t ofs);								/* Move file pointer of the file object */
NFRESULT f_truncate (FIL* fp);										/* Truncate the file */
NFRESULT f_sync (FIL* fp);											/* Flush cached data of the writing file */
NFRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
NFRESULT f_closedir (DIR* dp);										/* Close an open directory */
NFRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
NFRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);	/* Find first file */
NFRESULT f_findnext (DIR* dp, FILINFO* fno);							/* Find next file */
NFRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
NFRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
NFRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
NFRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
NFRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);			/* Change attribute of a file/dir */
NFRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change timestamp of a file/dir */
NFRESULT f_chdir (const TCHAR* path);								/* Change current directory */
NFRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
NFRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
NFRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
NFRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
NFRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
NFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
NFRESULT f_expand (FIL* fp, FSIZE_t szf, BYTE opt);					/* Allocate a contiguous block to the file */
NFRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
NFRESULT f_mkfs (const TCHAR* path, BYTE opt, DWORD au, void* work, UINT len);	/* Create a FAT volume */
NFRESULT f_fdisk (BYTE pdrv, const DWORD* szt, void* work);			/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
Nint f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
Nint f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
N
N#define f_eof(fp) ((int)((fp)->fptr == (fp)->obj.objsize))
N#define f_error(fp) ((fp)->err)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->obj.objsize)
N#define f_rewind(fp) f_lseek((fp), 0)
N#define f_rewinddir(dp) f_readdir((dp), 0)
N
N#ifndef EOF
N#define EOF (-1)
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY && !_FS_NORTC
X#if !0 && !0
NDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN != 0						/* Unicode - OEM code conversion */
X#if 1 != 0						 
NWCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3						/* Memory functions */
X#if 1 == 3						 
Svoid* ff_memalloc (UINT msize);			/* Allocate memory block */
Svoid ff_memfree (void* mblock);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
Sint ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
Sint ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
Svoid ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
Sint ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access mode and open method flags (3rd argument of f_open) */
N#define	FA_READ				0x01
N#define	FA_WRITE			0x02
N#define	FA_OPEN_EXISTING	0x00
N#define	FA_CREATE_NEW		0x04
N#define	FA_CREATE_ALWAYS	0x08
N#define	FA_OPEN_ALWAYS		0x10
N#define	FA_OPEN_APPEND		0x30
N
N/* Fast seek controls (2nd argument of f_lseek) */
N#define CREATE_LINKMAP	((FSIZE_t)0 - 1)
N
N/* Format options (2nd argument of f_mkfs) */
N#define FM_FAT		0x01
N#define FM_FAT32	0x02
N#define FM_EXFAT	0x04
N#define FM_ANY		0x07
N#define FM_SFD		0x08
N
N/* Filesystem type (FATFS.fs_type) */
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N#define FS_EXFAT	4
N
N/* File attribute bits for directory entry (FILINFO.fattrib) */
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 42 "..\User\emWinTask\MainTask.h" 2
N#include "diskio.h"
L 1 "..\FatFS\src\diskio.h" 1
N/*-----------------------------------------------------------------------/
N/  Low level disk interface modlue include file   (C)ChaN, 2014          /
N/-----------------------------------------------------------------------*/
N
N#ifndef _DISKIO_DEFINED
N#define _DISKIO_DEFINED
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"
N
N
N/* Status of Disk Functions */
Ntypedef BYTE	DSTATUS;
N
N/* Results of Disk Functions */
Ntypedef enum {
N	RES_OK = 0,		/* 0: Successful */
N	RES_ERROR,		/* 1: R/W Error */
N	RES_WRPRT,		/* 2: Write Protected */
N	RES_NOTRDY,		/* 3: Not Ready */
N	RES_PARERR		/* 4: Invalid Parameter */
N} DRESULT;
N
N
N/*---------------------------------------*/
N/* Prototypes for disk control functions */
N
N
NDSTATUS disk_initialize (BYTE pdrv);
NDSTATUS disk_status (BYTE pdrv);
NDRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
NDRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
NDRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
N
N
N/* Disk Status Bits (DSTATUS) */
N
N#define STA_NOINIT		0x01	/* Drive not initialized */
N#define STA_NODISK		0x02	/* No medium in the drive */
N#define STA_PROTECT		0x04	/* Write protected */
N
N
N/* Command code for disk_ioctrl fucntion */
N
N/* Generic command (Used by FatFs) */
N#define CTRL_SYNC			0	/* Complete pending write process (needed at _FS_READONLY == 0) */
N#define GET_SECTOR_COUNT	1	/* Get media size (needed at _USE_MKFS == 1) */
N#define GET_SECTOR_SIZE		2	/* Get sector size (needed at _MAX_SS != _MIN_SS) */
N#define GET_BLOCK_SIZE		3	/* Get erase block size (needed at _USE_MKFS == 1) */
N#define CTRL_TRIM			4	/* Inform device that the data on the block of sectors is no longer used (needed at _USE_TRIM == 1) */
N
N/* Generic command (Not used by FatFs) */
N#define CTRL_POWER			5	/* Get/Set power status */
N#define CTRL_LOCK			6	/* Lock/Unlock media removal */
N#define CTRL_EJECT			7	/* Eject media */
N#define CTRL_FORMAT			8	/* Create physical format on the media */
N
N/* MMC/SDC specific ioctl command */
N#define MMC_GET_TYPE		10	/* Get card type */
N#define MMC_GET_CSD			11	/* Get CSD */
N#define MMC_GET_CID			12	/* Get CID */
N#define MMC_GET_OCR			13	/* Get OCR */
N#define MMC_GET_SDSTAT		14	/* Get SD status */
N#define ISDIO_READ			55	/* Read data form SD iSDIO register */
N#define ISDIO_WRITE			56	/* Write data to SD iSDIO register */
N#define ISDIO_MRITE			57	/* Masked write data to SD iSDIO register */
N
N/* ATA/CF specific ioctl command */
N#define ATA_GET_REV			20	/* Get F/W revision */
N#define ATA_GET_MODEL		21	/* Get model name */
N#define ATA_GET_SN			22	/* Get serial number */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 43 "..\User\emWinTask\MainTask.h" 2
N
N/*
N************************************************************************
N*						  FatFs
N************************************************************************
N*/
Nextern FRESULT result;
Nextern FIL file;
Nextern FILINFO finfo;
Nextern DIR DirInf;
Nextern UINT bw;
Nextern FATFS fs;
N
Nextern void _WriteByte2File(U8 Data, void * p); 
Xextern void _WriteByte2File(unsigned char Data, void * p); 
N/*
N************************************************************************
N*						emWin字体
N************************************************************************
N*/
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_Song_12;
Xextern const  GUI_FONT GUI_FontHZ_Song_12;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_FangSong_16;
Xextern const  GUI_FONT GUI_FontHZ_FangSong_16;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_Song_16;
Xextern const  GUI_FONT GUI_FontHZ_Song_16;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_Hei_24;
Xextern const  GUI_FONT GUI_FontHZ_Hei_24;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_Kai_24;
Xextern const  GUI_FONT GUI_FontHZ_Kai_24;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_Song_24;
Xextern const  GUI_FONT GUI_FontHZ_Song_24;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_SimSun_1616;
Xextern const  GUI_FONT GUI_FontHZ_SimSun_1616;
Nextern GUI_CONST_STORAGE  GUI_FONT GUI_FontHZ_SimSun_2424;
Xextern const  GUI_FONT GUI_FontHZ_SimSun_2424;
N
N#endif
N
N/*****************************(END OF FILE) *********************************/
L 17 "..\User\emWinTask\MainTask.c" 2
N
N
N/*
N*********************************************************************************************************
N*	                       GUI_WIDGET_CREATE_INFO类型数组
N*********************************************************************************************************
N*/
Nstatic const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
N  { FRAMEWIN_CreateIndirect, "Counting...",        0,      30,  80, 400, 190, FRAMEWIN_CF_MOVEABLE },
X  { FRAMEWIN_CreateIndirect, "Counting...",        0,      30,  80, 400, 190, (1<<4) },
N  { TEXT_CreateIndirect,     "00",        GUI_ID_TEXT0,    10,  10, 120,  80 },
X  { TEXT_CreateIndirect,     "00",        0x160,    10,  10, 120,  80 },
N  { RADIO_CreateIndirect,    "",          GUI_ID_RADIO0,  150,  10, 180,  120, 0, 0x1904, 0},
X  { RADIO_CreateIndirect,    "",          0x150,  150,  10, 180,  120, 0, 0x1904, 0},
N  { BUTTON_CreateIndirect,   "OK",        GUI_ID_OK,       19, 121, 114, 32, 0, 0x0, 0 },
X  { BUTTON_CreateIndirect,   "OK",        1,       19, 121, 114, 32, 0, 0x0, 0 },
N  { BUTTON_CreateIndirect,   "Cancel",    GUI_ID_CANCEL,  252, 120, 116, 35, 0, 0x0, 0 },
X  { BUTTON_CreateIndirect,   "Cancel",    2,  252, 120, 116, 35, 0, 0x0, 0 },
N};
N
N/*
N*********************************************************************************************************
N*	                                      数组
N*********************************************************************************************************
N*/
Nstatic const char * _apLabel[] = {
N  "GUI_FontFD32",
N  "GUI_FontFD48",
N  "GUI_FontFD64",
N  "GUI_FontFD80",
N};
N
Nstatic const GUI_FONT * _apFont[] = {
N  &GUI_FontD32,
N  &GUI_FontD48,
N  &GUI_FontD64,
N  &GUI_FontD80
N};
N
Nstatic const char * _asExplain[] = {
N  "Please use the RADIO buttons to select",
N  "the big digit font used for counting."
N};
N
N/*
N*********************************************************************************************************
N*	函 数 名: _SetFont
N*	功能说明: 设置显示字体		
N*	形    参: hDlg  对话框句柄
N*	返 回 值: 无
N*********************************************************************************************************
N*/
Nstatic void _SetFont(WM_HWIN hDlg) 
Xstatic void _SetFont(GUI_HWIN hDlg) 
N{
N	WM_HWIN hItem;
X	GUI_HWIN hItem;
N	int Index;
N	hItem = WM_GetDialogItem(hDlg, GUI_ID_RADIO0);
X	hItem = WM_GetDialogItem(hDlg, 0x150);
N	Index = RADIO_GetValue(hItem);
N	hItem = WM_GetDialogItem(hDlg, GUI_ID_TEXT0);
X	hItem = WM_GetDialogItem(hDlg, 0x160);
N	TEXT_SetFont(hItem, _apFont[Index]);
N}
N
N/*
N*********************************************************************************************************
N*	函 数 名: _cbBkWindow
N*	功能说明: 桌面窗口回调函数		
N*	形    参: pMsg  回调参数 
N*	返 回 值: 无
N*********************************************************************************************************
N*/
Nstatic void _cbBkWindow(WM_MESSAGE * pMsg) 
N{
N	int i;
N	
N	switch (pMsg->MsgId) 
N	{
N		/* 重绘消息 */
N		case WM_PAINT:
X		case 0x000F:
N			GUI_SetBkColor(GUI_BLUE);
X			GUI_SetBkColor(0x00FF0000);
N			GUI_Clear();
N			GUI_SetColor(GUI_WHITE);
X			GUI_SetColor(0x00FFFFFF);
N			GUI_SetFont(&GUI_Font24_ASCII);
N			GUI_DispStringHCenterAt("Counting Sample", 160, 5);
N			GUI_SetFont(&GUI_Font8x16);
N			for (i = 0; i < GUI_COUNTOF(_asExplain); i++) 
X			for (i = 0; i < (sizeof(_asExplain) / sizeof(_asExplain[0])); i++) 
N			{
N				GUI_DispStringAt(_asExplain[i], 5, 40 + i * 16);
N			}
N			
N		default:
N			WM_DefaultProc(pMsg);
N	}
N}
N
N/*
N*********************************************************************************************************
N*	函 数 名: _cbCallback
N*	功能说明: 对话框回调函数	
N*	形    参: pMsg  回调参数 
N*	返 回 值: 无
N*********************************************************************************************************
N*/
Nstatic void _cbCallback(WM_MESSAGE * pMsg) 
N{
N	int i;
N	int NCode, Id;
N	WM_HWIN hDlg, hItem;
X	GUI_HWIN hDlg, hItem;
N	hDlg = pMsg->hWin;
N	switch (pMsg->MsgId) 
N	{
N		case WM_INIT_DIALOG:
X		case 29:
N			hItem = WM_GetDialogItem(hDlg, GUI_ID_RADIO0);
X			hItem = WM_GetDialogItem(hDlg, 0x150);
N			for (i = 0; i < GUI_COUNTOF(_apLabel); i++) 
X			for (i = 0; i < (sizeof(_apLabel) / sizeof(_apLabel[0])); i++) 
N			{
N				RADIO_SetText(hItem, _apLabel[i], i);
N			}
N			_SetFont(hDlg);
N			break;
N			
N		case WM_NOTIFY_PARENT:
X		case 38:
N			Id    = WM_GetId(pMsg->hWinSrc);    
N			NCode = pMsg->Data.v;             
N			switch (NCode) 
N			{
N				case WM_NOTIFICATION_VALUE_CHANGED: 
X				case 5: 
N					_SetFont(hDlg);
N					break;
N				
N				/* 两个按钮的消息处理 */
N				case WM_NOTIFICATION_RELEASED:     
X				case 2:     
N					if (Id == GUI_ID_OK) 
X					if (Id == 1) 
N					{            
N						GUI_EndDialog(hDlg, 0);
N					}
N					if (Id == GUI_ID_CANCEL) 
X					if (Id == 2) 
N					{       
N						GUI_EndDialog(hDlg, 1);
N					}
N					break;
N			}
N			break;
N			
N		default:
N		WM_DefaultProc(pMsg);
N	}
N}
N
N/*
N*********************************************************************************************************
N*	函 数 名: MainTask
N*	功能说明: GUI主函数
N*	形    参: 无
N*	返 回 值: 无
N*********************************************************************************************************
N*/
Nvoid MainTask(void) 
N{
N	int Value = 0;
N	WM_HWIN hDlgFrame;
X	GUI_HWIN hDlgFrame;
N	
N	/* 初始化 */
N	GUI_Init();
N    //TOUCH_Calibration();
N	//GUI_CURSOR_Show();
N	WM_SetCallback(WM_HBKWIN, _cbBkWindow);  
X	WM_SetCallback(WM_GetDesktopWindow(), _cbBkWindow);  
N	WM_SetCreateFlags(WM_CF_MEMDEV);   
X	WM_SetCreateFlags((1UL << 2));   
N	hDlgFrame = 0;
N	
N	while(1) 
N	{
N		WM_HWIN hDlg, hText;
X		GUI_HWIN hDlg, hText;
N		char acText[3] = {0};
N		
N		GUI_Delay(100);
N		/* 如果对话框被关闭就重新的将其再打开 */
N		if (!WM_IsWindow(hDlgFrame)) 
N		{
N			Value = 0;
N			hDlgFrame = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), &_cbCallback, 0, 0, 0);
X			hDlgFrame = GUI_CreateDialogBox(_aDialogCreate, (sizeof(_aDialogCreate) / sizeof(_aDialogCreate[0])), &_cbCallback, 0, 0, 0);
N		}
N		
N		Value = (Value + 1) % 100;
N		acText[0] = '0' + Value / 10;
N		acText[1] = '0' + Value % 10;
N		hDlg = WM_GetClientWindow(hDlgFrame);
N		hText = WM_GetDialogItem(hDlg, GUI_ID_TEXT0);
X		hText = WM_GetDialogItem(hDlg, 0x160);
N		TEXT_SetText(hText, acText);
N	}
N}
N
N/***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/
