L 1 "..\FatFS\src\ff.c"
N/*----------------------------------------------------------------------------/
N/  FatFs - Generic FAT file system module  R0.12b                             /
N/-----------------------------------------------------------------------------/
N/
N/ Copyright (C) 2016, ChaN, all right reserved.
N/
N/ FatFs module is an open source software. Redistribution and use of FatFs in
N/ source and binary forms, with or without modification, are permitted provided
N/ that the following condition is met:
N
N/ 1. Redistributions of source code must retain the above copyright notice,
N/    this condition and the following disclaimer.
N/
N/ This software is provided by the copyright holder and contributors "AS IS"
N/ and any warranties related to this software are DISCLAIMED.
N/ The copyright owner or contributors be NOT LIABLE for any damages caused
N/ by use of this software.
N/----------------------------------------------------------------------------*/
N
N
N#include "ff.h"			/* Declarations of FatFs API */
L 1 "..\FatFS\src\ff.h" 1
N/*----------------------------------------------------------------------------/
N/  FatFs - Generic FAT file system module  R0.12b                             /
N/-----------------------------------------------------------------------------/
N/
N/ Copyright (C) 2016, ChaN, all right reserved.
N/
N/ FatFs module is an open source software. Redistribution and use of FatFs in
N/ source and binary forms, with or without modification, are permitted provided
N/ that the following condition is met:
N
N/ 1. Redistributions of source code must retain the above copyright notice,
N/    this condition and the following disclaimer.
N/
N/ This software is provided by the copyright holder and contributors "AS IS"
N/ and any warranties related to this software are DISCLAIMED.
N/ The copyright owner or contributors be NOT LIABLE for any damages caused
N/ by use of this software.
N/----------------------------------------------------------------------------*/
N
N
N#ifndef _FATFS
N#define _FATFS	68020	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\FatFS\src\integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _FF_INTEGER
N#define _FF_INTEGER
N
N#ifdef _WIN32	/* FatFs development platform */
S
S#include <windows.h>
S#include <tchar.h>
Stypedef unsigned __int64 QWORD;
S
S
N#else			/* Embedded platform */
N
N/* These types MUST be 16-bit or 32-bit */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* This type MUST be 8-bit */
Ntypedef unsigned char	BYTE;
N
N/* These types MUST be 16-bit */
Ntypedef short			SHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types MUST be 32-bit */
Ntypedef long			LONG;
Ntypedef unsigned long	DWORD;
N
N/* This type MUST be 64-bit (Remove this for C89 compatibility) */
Ntypedef unsigned long long QWORD;
N
N#endif
N
N#endif
L 29 "..\FatFS\src\ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\FatFS\src\ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file
N/---------------------------------------------------------------------------*/
N
N#define _FFCONF 68020	/* Revision ID */
N
N/*---------------------------------------------------------------------------/
N/ Function Configurations
N/---------------------------------------------------------------------------*/
N
N#define _FS_READONLY	0
N/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
N/  Read-only configuration removes writing API functions, f_write(), f_sync(),
N/  f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(), f_getfree()
N/  and optional writing functions as well. */
N
N
N#define _FS_MINIMIZE	0
N/* This option defines minimization level to remove some basic API functions.
N/
N/   0: All basic functions are enabled.
N/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename()
N/      are removed.
N/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
N/   3: f_lseek() function is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	0
N/* This option switches string functions, f_gets(), f_putc(), f_puts() and
N/  f_printf().
N/
N/  0: Disable string functions.
N/  1: Enable without LF-CRLF conversion.
N/  2: Enable with LF-CRLF conversion. */
N
N
N#define _USE_FIND		0
N/* This option switches filtered directory read functions, f_findfirst() and
N/  f_findnext(). (0:Disable, 1:Enable 2:Enable with matching altname[] too) */
N
N
N#define	_USE_MKFS		0
N/* This option switches f_mkfs() function. (0:Disable or 1:Enable) */
N
N
N#define	_USE_FASTSEEK	0
N/* This option switches fast seek function. (0:Disable or 1:Enable) */
N
N
N#define	_USE_EXPAND		0
N/* This option switches f_expand function. (0:Disable or 1:Enable) */
N
N
N#define _USE_CHMOD		0
N/* This option switches attribute manipulation functions, f_chmod() and f_utime().
N/  (0:Disable or 1:Enable) Also _FS_READONLY needs to be 0 to enable this option. */
N
N
N#define _USE_LABEL		0
N/* This option switches volume label functions, f_getlabel() and f_setlabel().
N/  (0:Disable or 1:Enable) */
N
N
N#define	_USE_FORWARD	0
N/* This option switches f_forward() function. (0:Disable or 1:Enable) */
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/---------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	936
N/* This option specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   1   - ASCII (No extended character. Non-LFN cfg. only)
N/   437 - U.S.
N/   720 - Arabic
N/   737 - Greek
N/   771 - KBL
N/   775 - Baltic
N/   850 - Latin 1
N/   852 - Latin 2
N/   855 - Cyrillic
N/   857 - Turkish
N/   860 - Portuguese
N/   861 - Icelandic
N/   862 - Hebrew
N/   863 - Canadian French
N/   864 - Arabic
N/   865 - Nordic
N/   866 - Russian
N/   869 - Greek 2
N/   932 - Japanese (DBCS)
N/   936 - Simplified Chinese (DBCS)
N/   949 - Korean (DBCS)
N/   950 - Traditional Chinese (DBCS)
N*/
N
N
N#define	_USE_LFN	1 //使用长文件名
N#define	_MAX_LFN	255
N/* The _USE_LFN switches the support of long file name (LFN).
N/
N/   0: Disable support of LFN. _MAX_LFN has no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  To enable the LFN, Unicode handling functions (option/unicode.c) must be added
N/  to the project. The working buffer occupies (_MAX_LFN + 1) * 2 bytes and
N/  additional 608 bytes at exFAT enabled. _MAX_LFN can be in range from 12 to 255.
N/  It should be set 255 to support full featured LFN operations.
N/  When use stack for the working buffer, take care on stack overflow. When use heap
N/  memory for the working buffer, memory management functions, ff_memalloc() and
N/  ff_memfree(), must be added to the project. */
N
N
N#define	_LFN_UNICODE	0
N/* This option switches character encoding on the API. (0:ANSI/OEM or 1:UTF-16)
N/  To use Unicode string for the path name, enable LFN and set _LFN_UNICODE = 1.
N/  This option also affects behavior of string I/O functions. */
N
N
N#define _STRF_ENCODE	3
N/* When _LFN_UNICODE == 1, this option selects the character encoding ON THE FILE to
N/  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
N/
N/  0: ANSI/OEM
N/  1: UTF-16LE
N/  2: UTF-16BE
N/  3: UTF-8
N/
N/  This option has no effect when _LFN_UNICODE == 0. */
N
N
N#define _FS_RPATH	0
N/* This option configures support of relative path.
N/
N/   0: Disable relative path and remove related functions.
N/   1: Enable relative path. f_chdir() and f_chdrive() are available.
N/   2: f_getcwd() function is available in addition to 1.
N*/
N
N
N/*---------------------------------------------------------------------------/
N/ Drive/Volume Configurations
N/---------------------------------------------------------------------------*/
N
N#define _VOLUMES	1
N/* Number of volumes (logical drives) to be used. */
N
N
N#define _STR_VOLUME_ID	0
N#define _VOLUME_STRS	"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"
N/* _STR_VOLUME_ID switches string support of volume ID.
N/  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
N/  number in the path name. _VOLUME_STRS defines the drive ID strings for each
N/  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
N/  the drive ID strings are: A-Z and 0-9. */
N
N
N#define	_MULTI_PARTITION	0
N/* This option switches support of multi-partition on a physical drive.
N/  By default (0), each logical drive number is bound to the same physical drive
N/  number and only an FAT volume found on the physical drive will be mounted.
N/  When multi-partition is enabled (1), each logical drive number can be bound to
N/  arbitrary physical drive and partition listed in the VolToPart[]. Also f_fdisk()
N/  funciton will be available. */
N
N
N#define	_MIN_SS		512
N#define	_MAX_SS		512
N/* These options configure the range of sector size to be supported. (512, 1024,
N/  2048 or 4096) Always set both 512 for most systems, all type of memory cards and
N/  harddisk. But a larger value may be required for on-board flash memory and some
N/  type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured
N/  to variable sector size and GET_SECTOR_SIZE command must be implemented to the
N/  disk_ioctl() function. */
N
N
N#define	_USE_TRIM	0
N/* This option switches support of ATA-TRIM. (0:Disable or 1:Enable)
N/  To enable Trim function, also CTRL_TRIM command should be implemented to the
N/  disk_ioctl() function. */
N
N
N#define _FS_NOFSINFO	0
N/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
N/  option, and f_getfree() function at first time after volume mount will force
N/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
N/
N/  bit0=0: Use free cluster count in the FSINFO if available.
N/  bit0=1: Do not trust free cluster count in the FSINFO.
N/  bit1=0: Use last allocated cluster number in the FSINFO if available.
N/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
N*/
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/---------------------------------------------------------------------------*/
N
N#define	_FS_TINY	0
N/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
N/  At the tiny configuration, size of file object (FIL) is reduced _MAX_SS bytes.
N/  Instead of private sector buffer eliminated from the file object, common sector
N/  buffer in the file system object (FATFS) is used for the file data transfer. */
N
N
N#define _FS_EXFAT	0
N/* This option switches support of exFAT file system. (0:Disable or 1:Enable)
N/  When enable exFAT, also LFN needs to be enabled. (_USE_LFN >= 1)
N/  Note that enabling exFAT discards C89 compatibility. */
N
N
N#define _FS_NORTC	0
N#define _NORTC_MON	1
N#define _NORTC_MDAY	1
N#define _NORTC_YEAR	2016
N/* The option _FS_NORTC switches timestamp functiton. If the system does not have
N/  any RTC function or valid timestamp is not needed, set _FS_NORTC = 1 to disable
N/  the timestamp function. All objects modified by FatFs will have a fixed timestamp
N/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR in local time.
N/  To enable timestamp function (_FS_NORTC = 0), get_fattime() function need to be
N/  added to the project to get current time form real-time clock. _NORTC_MON,
N/  _NORTC_MDAY and _NORTC_YEAR have no effect. 
N/  These options have no effect at read-only configuration (_FS_READONLY = 1). */
N
N
N#define	_FS_LOCK	0
N/* The option _FS_LOCK switches file lock function to control duplicated file open
N/  and illegal operation to open objects. This option must be 0 when _FS_READONLY
N/  is 1.
N/
N/  0:  Disable file lock function. To avoid volume corruption, application program
N/      should avoid illegal open, remove and rename to the open objects.
N/  >0: Enable file lock function. The value defines how many files/sub-directories
N/      can be opened simultaneously under file lock control. Note that the file
N/      lock control is independent of re-entrancy. */
N
N
N#define _FS_REENTRANT	0
N#define _FS_TIMEOUT		1000
N#define	_SYNC_t			HANDLE
N/* The option _FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs
N/  module itself. Note that regardless of this option, file access to different
N/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
N/  and f_fdisk() function, are always not re-entrant. Only file/directory access
N/  to the same volume is under control of this function.
N/
N/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
N/   1: Enable re-entrancy. Also user provided synchronization handlers,
N/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
N/      function, must be added to the project. Samples are available in
N/      option/syscall.c.
N/
N/  The _FS_TIMEOUT defines timeout period in unit of time tick.
N/  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
N/  SemaphoreHandle_t and etc.. A header file for O/S definitions needs to be
N/  included somewhere in the scope of ff.h. */
N
N/* #include <windows.h>	// O/S definitions  */
N
N
N/*--- End of configuration options ---*/
L 30 "..\FatFS\src\ff.h" 2
N
N#if _FATFS != _FFCONF
X#if 68020 != 68020
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode (UTF-16) string */
X#if 0			 
S#if _USE_LFN == 0
S#error _LFN_UNICODE must be 0 at non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N#endif
N
N
N
N/* Type of file size variables */
N
N#if _FS_EXFAT
X#if 0
S#if _USE_LFN == 0
S#error LFN must be enabled when enable exFAT
S#endif
Stypedef QWORD FSIZE_t;
N#else
Ntypedef DWORD FSIZE_t;
N#endif
N
N
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* File system type (0:N/A) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	n_fats;			/* Number of FATs (1 or 2) */
N	BYTE	wflag;			/* win[] flag (b0:dirty) */
N	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N	WORD	csize;			/* Cluster size [sectors] */
N#if _MAX_SS != _MIN_SS
X#if 512 != 512
S	WORD	ssize;			/* Sector size (512, 1024, 2048 or 4096) */
N#endif
N#if _USE_LFN != 0
X#if 1 != 0
N	WCHAR*	lfnbuf;			/* LFN working buffer */
N#endif
N#if _FS_EXFAT
X#if 0
S	BYTE*	dirbuf;			/* Directory entry block scratchpad buffer */
N#endif
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;			/* Identifier of sync object */
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clst;		/* Last allocated cluster */
N	DWORD	free_clst;		/* Number of free clusters */
N#endif
N#if _FS_RPATH != 0
X#if 0 != 0
S	DWORD	cdir;			/* Current directory start cluster (0:root) */
S#if _FS_EXFAT
S	DWORD	cdc_scl;		/* Containing directory start cluster (invalid when cdir is 0) */
S	DWORD	cdc_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status */
S	DWORD	cdc_ofs;		/* Offset in the containing directory (invalid when cdir is 0) */
S#endif
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries (number of clusters + 2) */
N	DWORD	fsize;			/* Size of an FAT [sectors] */
N	DWORD	volbase;		/* Volume base sector */
N	DWORD	fatbase;		/* FAT base sector */
N	DWORD	dirbase;		/* Root directory base sector/cluster */
N	DWORD	database;		/* Data base sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
X	BYTE	win[512];	 
N} FATFS;
N
N
N
N/* Object ID and allocation information (_FDID) */
N
Ntypedef struct {
N	FATFS*	fs;			/* Pointer to the owner file system object */
N	WORD	id;			/* Owner file system mount ID */
N	BYTE	attr;		/* Object attribute */
N	BYTE	stat;		/* Object chain status (b1-0: =0:not contiguous, =2:contiguous (no data on FAT), =3:got flagmented, b2:sub-directory stretched) */
N	DWORD	sclust;		/* Object start cluster (0:no cluster or root directory) */
N	FSIZE_t	objsize;	/* Object size (valid when sclust != 0) */
N#if _FS_EXFAT
X#if 0
S	DWORD	n_cont;		/* Size of coutiguous part, clusters - 1 (valid when stat == 3) */
S	DWORD	c_scl;		/* Containing directory start cluster (valid when sclust != 0) */
S	DWORD	c_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status (valid when c_scl != 0) */
S	DWORD	c_ofs;		/* Offset in the containing directory (valid when sclust != 0) */
N#endif
N#if _FS_LOCK != 0
X#if 0 != 0
S	UINT	lockid;		/* File lock ID origin from 1 (index of file semaphore table Files[]) */
N#endif
N} _FDID;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	_FDID	obj;			/* Object identifier (must be the 1st member to detect invalid object pointer) */
N	BYTE	flag;			/* File status flags */
N	BYTE	err;			/* Abort flag (error code) */
N	FSIZE_t	fptr;			/* File read/write pointer (Zeroed on file open) */
N	DWORD	clust;			/* Current cluster of fpter (invalid when fprt is 0) */
N	DWORD	sect;			/* Sector number appearing in buf[] (0:invalid) */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;		/* Sector number containing the directory entry */
N	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
N#endif
N#if _USE_FASTSEEK
X#if 0
S	DWORD*	cltbl;			/* Pointer to the cluster link map table (nulled on open, set by application) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File private data read/write window */
X	BYTE	buf[512];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	_FDID	obj;			/* Object identifier */
N	DWORD	dptr;			/* Current read/write offset */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the directory item in the win[] */
N	BYTE	fn[12];			/* SFN (in/out) {body[8],ext[3],status[1]} */
N#if _USE_LFN != 0
X#if 1 != 0
N	DWORD	blk_ofs;		/* Offset of current entry block being processed (0xFFFFFFFF:Invalid) */
N#endif
N#if _USE_FIND
X#if 0
S	const TCHAR* pat;		/* Pointer to the name matching pattern */
N#endif
N} DIR;
N
N
N
N/* File information structure (FILINFO) */
N
Ntypedef struct {
N	FSIZE_t	fsize;			/* File size */
N	WORD	fdate;			/* Modified date */
N	WORD	ftime;			/* Modified time */
N	BYTE	fattrib;		/* File attribute */
N#if _USE_LFN != 0
X#if 1 != 0
N	TCHAR	altname[13];			/* Altenative file name */
N	TCHAR	fname[_MAX_LFN + 1];	/* Primary file name */
X	TCHAR	fname[255 + 1];	 
N#else
S	TCHAR	fname[13];		/* File name */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any problem */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
NFRESULT f_close (FIL* fp);											/* Close an open file object */
NFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from the file */
NFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to the file */
NFRESULT f_lseek (FIL* fp, FSIZE_t ofs);								/* Move file pointer of the file object */
NFRESULT f_truncate (FIL* fp);										/* Truncate the file */
NFRESULT f_sync (FIL* fp);											/* Flush cached data of the writing file */
NFRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
NFRESULT f_closedir (DIR* dp);										/* Close an open directory */
NFRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
NFRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);	/* Find first file */
NFRESULT f_findnext (DIR* dp, FILINFO* fno);							/* Find next file */
NFRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
NFRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
NFRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
NFRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
NFRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);			/* Change attribute of a file/dir */
NFRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change timestamp of a file/dir */
NFRESULT f_chdir (const TCHAR* path);								/* Change current directory */
NFRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
NFRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
NFRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
NFRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
NFRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
NFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
NFRESULT f_expand (FIL* fp, FSIZE_t szf, BYTE opt);					/* Allocate a contiguous block to the file */
NFRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
NFRESULT f_mkfs (const TCHAR* path, BYTE opt, DWORD au, void* work, UINT len);	/* Create a FAT volume */
NFRESULT f_fdisk (BYTE pdrv, const DWORD* szt, void* work);			/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
Nint f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
Nint f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
N
N#define f_eof(fp) ((int)((fp)->fptr == (fp)->obj.objsize))
N#define f_error(fp) ((fp)->err)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->obj.objsize)
N#define f_rewind(fp) f_lseek((fp), 0)
N#define f_rewinddir(dp) f_readdir((dp), 0)
N
N#ifndef EOF
N#define EOF (-1)
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY && !_FS_NORTC
X#if !0 && !0
NDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN != 0						/* Unicode - OEM code conversion */
X#if 1 != 0						 
NWCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3						/* Memory functions */
X#if 1 == 3						 
Svoid* ff_memalloc (UINT msize);			/* Allocate memory block */
Svoid ff_memfree (void* mblock);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
Sint ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
Sint ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
Svoid ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
Sint ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access mode and open method flags (3rd argument of f_open) */
N#define	FA_READ				0x01
N#define	FA_WRITE			0x02
N#define	FA_OPEN_EXISTING	0x00
N#define	FA_CREATE_NEW		0x04
N#define	FA_CREATE_ALWAYS	0x08
N#define	FA_OPEN_ALWAYS		0x10
N#define	FA_OPEN_APPEND		0x30
N
N/* Fast seek controls (2nd argument of f_lseek) */
N#define CREATE_LINKMAP	((FSIZE_t)0 - 1)
N
N/* Format options (2nd argument of f_mkfs) */
N#define FM_FAT		0x01
N#define FM_FAT32	0x02
N#define FM_EXFAT	0x04
N#define FM_ANY		0x07
N#define FM_SFD		0x08
N
N/* Filesystem type (FATFS.fs_type) */
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N#define FS_EXFAT	4
N
N/* File attribute bits for directory entry (FILINFO.fattrib) */
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 22 "..\FatFS\src\ff.c" 2
N#include "diskio.h"		/* Declarations of device I/O functions */
L 1 "..\FatFS\src\diskio.h" 1
N/*-----------------------------------------------------------------------/
N/  Low level disk interface modlue include file   (C)ChaN, 2014          /
N/-----------------------------------------------------------------------*/
N
N#ifndef _DISKIO_DEFINED
N#define _DISKIO_DEFINED
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"
N
N
N/* Status of Disk Functions */
Ntypedef BYTE	DSTATUS;
N
N/* Results of Disk Functions */
Ntypedef enum {
N	RES_OK = 0,		/* 0: Successful */
N	RES_ERROR,		/* 1: R/W Error */
N	RES_WRPRT,		/* 2: Write Protected */
N	RES_NOTRDY,		/* 3: Not Ready */
N	RES_PARERR		/* 4: Invalid Parameter */
N} DRESULT;
N
N
N/*---------------------------------------*/
N/* Prototypes for disk control functions */
N
N
NDSTATUS disk_initialize (BYTE pdrv);
NDSTATUS disk_status (BYTE pdrv);
NDRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
NDRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
NDRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
N
N
N/* Disk Status Bits (DSTATUS) */
N
N#define STA_NOINIT		0x01	/* Drive not initialized */
N#define STA_NODISK		0x02	/* No medium in the drive */
N#define STA_PROTECT		0x04	/* Write protected */
N
N
N/* Command code for disk_ioctrl fucntion */
N
N/* Generic command (Used by FatFs) */
N#define CTRL_SYNC			0	/* Complete pending write process (needed at _FS_READONLY == 0) */
N#define GET_SECTOR_COUNT	1	/* Get media size (needed at _USE_MKFS == 1) */
N#define GET_SECTOR_SIZE		2	/* Get sector size (needed at _MAX_SS != _MIN_SS) */
N#define GET_BLOCK_SIZE		3	/* Get erase block size (needed at _USE_MKFS == 1) */
N#define CTRL_TRIM			4	/* Inform device that the data on the block of sectors is no longer used (needed at _USE_TRIM == 1) */
N
N/* Generic command (Not used by FatFs) */
N#define CTRL_POWER			5	/* Get/Set power status */
N#define CTRL_LOCK			6	/* Lock/Unlock media removal */
N#define CTRL_EJECT			7	/* Eject media */
N#define CTRL_FORMAT			8	/* Create physical format on the media */
N
N/* MMC/SDC specific ioctl command */
N#define MMC_GET_TYPE		10	/* Get card type */
N#define MMC_GET_CSD			11	/* Get CSD */
N#define MMC_GET_CID			12	/* Get CID */
N#define MMC_GET_OCR			13	/* Get OCR */
N#define MMC_GET_SDSTAT		14	/* Get SD status */
N#define ISDIO_READ			55	/* Read data form SD iSDIO register */
N#define ISDIO_WRITE			56	/* Write data to SD iSDIO register */
N#define ISDIO_MRITE			57	/* Masked write data to SD iSDIO register */
N
N/* ATA/CF specific ioctl command */
N#define ATA_GET_REV			20	/* Get F/W revision */
N#define ATA_GET_MODEL		21	/* Get model name */
N#define ATA_GET_SN			22	/* Get serial number */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 23 "..\FatFS\src\ff.c" 2
N
N
N/*--------------------------------------------------------------------------
N
N   Module Private Definitions
N
N---------------------------------------------------------------------------*/
N
N#if _FATFS != 68020	/* Revision ID */
X#if 68020 != 68020	 
S#error Wrong include file (ff.h).
N#endif
N
N
N#define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
N
N
N/* Reentrancy related */
N#if _FS_REENTRANT
X#if 0
S#if _USE_LFN == 1
S#error Static LFN work area cannot be used at thread-safe configuration
S#endif
S#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
S#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
N#else
N#define	ENTER_FF(fs)
N#define LEAVE_FF(fs, res)	return res
N#endif
N
N
N
N/* Definitions of sector size */
N#if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
X#if (512 < 512) || (512 != 512 && 512 != 1024 && 512 != 2048 && 512 != 4096) || (512 != 512 && 512 != 1024 && 512 != 2048 && 512 != 4096)
S#error Wrong sector size configuration
N#endif
N#if _MAX_SS == _MIN_SS
X#if 512 == 512
N#define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
N#else
S#define	SS(fs)	((fs)->ssize)	/* Variable sector size */
N#endif
N
N
N/* Timestamp */
N#if _FS_NORTC == 1
X#if 0 == 1
S#if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
S#error Invalid _FS_NORTC settings
S#endif
S#define GET_FATTIME()	((DWORD)(_NORTC_YEAR - 1980) << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
N#else
N#define GET_FATTIME()	get_fattime()
N#endif
N
N
N/* File lock controls */
N#if _FS_LOCK != 0
X#if 0 != 0
S#if _FS_READONLY
S#error _FS_LOCK must be 0 at read-only configuration
S#endif
Stypedef struct {
S	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
S	DWORD clu;		/* Object ID 2, directory (0:root) */
S	DWORD ofs;		/* Object ID 3, directory offset */
S	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
S} FILESEM;
N#endif
N
N
N
N/* DBCS code ranges and SBCS upper conversion tables */
N
N#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
X#if 936 == 932	 
S#define _DF1S	0x81	/* DBC 1st byte range 1 start */
S#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
S#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
S#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
S#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
S#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
S#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
S#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
S
N#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
X#elif 936 == 936	 
N#define _DF1S	0x81
N#define _DF1E	0xFE
N#define _DS1S	0x40
N#define _DS1E	0x7E
N#define _DS2S	0x80
N#define _DS2E	0xFE
N
N#elif _CODE_PAGE == 949	/* Korean */
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x41
S#define _DS1E	0x5A
S#define _DS2S	0x61
S#define _DS2E	0x7A
S#define _DS3S	0x81
S#define _DS3E	0xFE
S
S#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0xA1
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 437	/* U.S. */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
S				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, 				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 720	/* Arabic */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 737	/* Greek */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
S				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 771	/* KBL */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
S
S#elif _CODE_PAGE == 775	/* Baltic */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
S				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, 				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 850	/* Latin 1 */
S#define _DF1S	0
S#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
S				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
S				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, 				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, 				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 852	/* Latin 2 */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
S				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
S				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, 				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
S
S#elif _CODE_PAGE == 855	/* Cyrillic */
S#define _DF1S	0
S#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
S				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
S				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
S				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
S				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, 				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, 				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 857	/* Turkish */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
S				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, 				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 860	/* Portuguese */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
S				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, 				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 861	/* Icelandic */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
S				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, 				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 862	/* Hebrew */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 863	/* Canadian-French */
S#define _DF1S	0
S#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
S				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
S				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, 				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, 				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 864	/* Arabic */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
S				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, 				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 865	/* Nordic */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
S				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
S				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, 				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, 				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 866	/* Russian */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 869	/* Greek 2 */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
S				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
S				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
S				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
S				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
S				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
S				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, 				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, 				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, 				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, 				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, 				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, 				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
S#if _USE_LFN != 0
S#error Cannot enable LFN without valid code page.
S#endif
S#define _DF1S	0
S
S#else
S#error Unknown code page
S
N#endif
N
N
N/* Character code support macros */
N#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
N#define IsLower(c)	(((c)>='a')&&((c)<='z'))
N#define IsDigit(c)	(((c)>='0')&&((c)<='9'))
N
N#if _DF1S != 0	/* Code page is DBCS */
X#if 0x81 != 0	 
N
N#ifdef _DF2S	/* Two 1st byte areas */
S#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
N#else			/* One 1st byte area */
N#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
N#endif
N
N#ifdef _DS3S	/* Three 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
N#else			/* Two 2nd byte areas */
N#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
N#endif
N
N#else			/* Code page is SBCS */
S
S#define IsDBCS1(c)	0
S#define IsDBCS2(c)	0
S
N#endif /* _DF1S */
N
N
N/* File attribute bits (internal use) */
N#define	AM_VOL		0x08	/* Volume label */
N#define AM_LFN		0x0F	/* LFN entry */
N#define AM_MASK		0x3F	/* Mask of defined bits */
N
N
N/* File access control and file status flags (internal use) */
N#define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
N#define FA_MODIFIED	0x40	/* File has been modified */
N#define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
N
N
N/* Name status flags */
N#define NSFLAG		11		/* Index of name status byte in fn[] */
N#define NS_LOSS		0x01	/* Out of 8.3 format */
N#define NS_LFN		0x02	/* Force to create LFN entry */
N#define NS_LAST		0x04	/* Last segment */
N#define NS_BODY		0x08	/* Lower case flag (body) */
N#define NS_EXT		0x10	/* Lower case flag (ext) */
N#define NS_DOT		0x20	/* Dot entry */
N#define NS_NOLFN	0x40	/* Do not find LFN */
N#define NS_NONAME	0x80	/* Not followed */
N
N
N/* Limits and boundaries (differ from specs but correct for real DOS/Windows) */
N#define MAX_FAT12	0xFF5			/* Maximum number of FAT12 clusters */
N#define	MAX_FAT16	0xFFF5			/* Maximum number of FAT16 clusters */
N#define	MAX_FAT32	0xFFFFFF5		/* Maximum number of FAT32 clusters */
N#define	MAX_EXFAT	0x7FFFFFFD		/* Maximum number of exFAT clusters (limited by implementation) */
N#define MAX_DIR		0x200000		/* Maximum size of FAT directory */
N#define MAX_DIR_EX	0x10000000		/* Maximum size of exFAT directory */
N
N
N/* FatFs refers the members in the FAT structures as byte array instead of
N/ structure members because the structure is not binary compatible between
N/ different platforms */
N
N#define BS_JmpBoot			0		/* x86 jump instruction (3-byte) */
N#define BS_OEMName			3		/* OEM name (8-byte) */
N#define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
N#define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
N#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
N#define BPB_NumFATs			16		/* Number of FATs (BYTE) */
N#define BPB_RootEntCnt		17		/* Size of root directory area for FAT12/16 [entry] (WORD) */
N#define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
N#define BPB_Media			21		/* Media descriptor byte (BYTE) */
N#define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
N#define BPB_SecPerTrk		24		/* Track size for int13h [sector] (WORD) */
N#define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
N#define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
N#define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
N#define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
N#define BS_NTres			37		/* Error flag (BYTE) */
N#define BS_BootSig			38		/* Extended boot signature (BYTE) */
N#define BS_VolID			39		/* Volume serial number (DWORD) */
N#define BS_VolLab			43		/* Volume label string (8-byte) */
N#define BS_FilSysType		54		/* File system type string (8-byte) */
N#define BS_BootCode			62		/* Boot code (448-byte) */
N#define BS_55AA				510		/* Signature word (WORD) */
N
N#define BPB_FATSz32			36		/* FAT32: FAT size [sector] (DWORD) */
N#define BPB_ExtFlags32		40		/* FAT32: Extended flags (WORD) */
N#define BPB_FSVer32			42		/* FAT32: File system version (WORD) */
N#define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
N#define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
N#define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
N#define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
N#define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
N#define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
N#define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
N#define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
N#define BS_FilSysType32		82		/* FAT32: File system type string (8-byte) */
N#define BS_BootCode32		90		/* FAT32: Boot code (420-byte) */
N
N#define BPB_ZeroedEx		11		/* exFAT: MBZ field (53-byte) */
N#define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
N#define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
N#define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
N#define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
N#define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
N#define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
N#define BPB_RootClusEx		96		/* exFAT: Root directory cluster (DWORD) */
N#define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
N#define BPB_FSVerEx			104		/* exFAT: File system version (WORD) */
N#define BPB_VolFlagEx		106		/* exFAT: Volume flags (BYTE) */
N#define BPB_ActFatEx		107		/* exFAT: Active FAT flags (BYTE) */
N#define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in byte (BYTE) */
N#define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in sector (BYTE) */
N#define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
N#define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
N#define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
N#define	BPB_RsvdEx			113		/* exFAT: Reserved (7-byte) */
N#define BS_BootCodeEx		120		/* exFAT: Boot code (390-byte) */
N
N#define	FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
N#define	FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
N#define	FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
N#define	FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
N
N#define MBR_Table			446		/* MBR: Offset of partition table in the MBR */
N#define	SZ_PTE				16		/* MBR: Size of a partition table entry */
N#define PTE_Boot			0		/* MBR PTE: Boot indicator */
N#define PTE_StHead			1		/* MBR PTE: Start head */
N#define PTE_StSec			2		/* MBR PTE: Start sector */
N#define PTE_StCyl			3		/* MBR PTE: Start cylinder */
N#define PTE_System			4		/* MBR PTE: System ID */
N#define PTE_EdHead			5		/* MBR PTE: End head */
N#define PTE_EdSec			6		/* MBR PTE: End sector */
N#define PTE_EdCyl			7		/* MBR PTE: End cylinder */
N#define PTE_StLba			8		/* MBR PTE: Start in LBA */
N#define PTE_SizLba			12		/* MBR PTE: Size in LBA */
N
N#define	DIR_Name			0		/* Short file name (11-byte) */
N#define	DIR_Attr			11		/* Attribute (BYTE) */
N#define	DIR_NTres			12		/* Lower case flag (BYTE) */
N#define DIR_CrtTime10		13		/* Created time sub-second (BYTE) */
N#define	DIR_CrtTime			14		/* Created time (DWORD) */
N#define DIR_LstAccDate		18		/* Last accessed date (WORD) */
N#define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
N#define	DIR_ModTime			22		/* Modified time (DWORD) */
N#define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
N#define	DIR_FileSize		28		/* File size (DWORD) */
N#define	LDIR_Ord			0		/* LFN entry order and LLE flag (BYTE) */
N#define	LDIR_Attr			11		/* LFN attribute (BYTE) */
N#define	LDIR_Type			12		/* LFN type (BYTE) */
N#define	LDIR_Chksum			13		/* Checksum of the SFN entry (BYTE) */
N#define	LDIR_FstClusLO		26		/* Must be zero (WORD) */
N#define	XDIR_Type			0		/* Type of exFAT directory entry (BYTE) */
N#define	XDIR_NumLabel		1		/* Number of volume label characters (BYTE) */
N#define	XDIR_Label			2		/* Volume label (11-WORD) */
N#define	XDIR_CaseSum		4		/* Sum of case conversion table (DWORD) */
N#define	XDIR_NumSec			1		/* Number of secondary entries (BYTE) */
N#define	XDIR_SetSum			2		/* Sum of the set of directory entries (WORD) */
N#define	XDIR_Attr			4		/* File attribute (WORD) */
N#define	XDIR_CrtTime		8		/* Created time (DWORD) */
N#define	XDIR_ModTime		12		/* Modified time (DWORD) */
N#define	XDIR_AccTime		16		/* Last accessed time (DWORD) */
N#define	XDIR_CrtTime10		20		/* Created time subsecond (BYTE) */
N#define	XDIR_ModTime10		21		/* Modified time subsecond (BYTE) */
N#define	XDIR_CrtTZ			22		/* Created timezone (BYTE) */
N#define	XDIR_ModTZ			23		/* Modified timezone (BYTE) */
N#define	XDIR_AccTZ			24		/* Last accessed timezone (BYTE) */
N#define	XDIR_GenFlags		33		/* Gneral secondary flags (WORD) */
N#define	XDIR_NumName		35		/* Number of file name characters (BYTE) */
N#define	XDIR_NameHash		36		/* Hash of file name (WORD) */
N#define XDIR_ValidFileSize	40		/* Valid file size (QWORD) */
N#define	XDIR_FstClus		52		/* First cluster of the file data (DWORD) */
N#define	XDIR_FileSize		56		/* File/Directory size (QWORD) */
N
N#define	SZDIRE				32		/* Size of a directory entry */
N#define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
N#define	DDEM				0xE5	/* Deleted directory entry mark set to DIR_Name[0] */
N#define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
N
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Module Private Work Area
N
N---------------------------------------------------------------------------*/
N
N/* Remark: Variables here without initial value shall be guaranteed zero/null
N/  at start-up. If not, either the linker or start-up routine being used is
N/  not compliance with C standard. */
N
N#if _VOLUMES < 1 || _VOLUMES > 9
X#if 1 < 1 || 1 > 9
S#error Wrong _VOLUMES setting
N#endif
Nstatic FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
Xstatic FATFS *FatFs[1];	 
Nstatic WORD Fsid;				/* File system mount ID */
N
N#if _FS_RPATH != 0 && _VOLUMES >= 2
X#if 0 != 0 && 1 >= 2
Sstatic BYTE CurrVol;			/* Current drive */
N#endif
N
N#if _FS_LOCK != 0
X#if 0 != 0
Sstatic FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
N#endif
N
N#if _USE_LFN == 0			/* Non-LFN configuration */
X#if 1 == 0			 
S#define	DEF_NAMBUF
S#define INIT_NAMBUF(fs)
S#define	FREE_NAMBUF()
N#else
N#if _MAX_LFN < 12 || _MAX_LFN > 255
X#if 255 < 12 || 255 > 255
S#error Wrong _MAX_LFN setting
N#endif
N
N#if _USE_LFN == 1		/* LFN enabled with static working buffer */
X#if 1 == 1		 
N#if _FS_EXFAT
X#if 0
Sstatic BYTE	DirBuf[SZDIRE*19];	/* Directory entry block scratchpad buffer (19 entries in size) */
N#endif
Nstatic WCHAR LfnBuf[_MAX_LFN+1];	/* LFN enabled with static working buffer */
Xstatic WCHAR LfnBuf[255+1];	 
N#define	DEF_NAMBUF
N#define INIT_NAMBUF(fs)
N#define	FREE_NAMBUF()
N
N#elif _USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
S#if _FS_EXFAT
S#define	DEF_NAMBUF		WCHAR lbuf[_MAX_LFN+1]; BYTE dbuf[SZDIRE*19];
S#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }
S#define	FREE_NAMBUF()
S#else
S#define	DEF_NAMBUF		WCHAR lbuf[_MAX_LFN+1];
S#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
S#define	FREE_NAMBUF()
S#endif
S
S#elif _USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
S#if _FS_EXFAT
S#define	DEF_NAMBUF		WCHAR *lfn;
S#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((_MAX_LFN+1)*2 + SZDIRE*19); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+_MAX_LFN+1); }
S#define	FREE_NAMBUF()	ff_memfree(lfn)
S#else
S#define	DEF_NAMBUF		WCHAR *lfn;
S#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }
S#define	FREE_NAMBUF()	ff_memfree(lfn)
S#endif
S
S#else
S#error Wrong _USE_LFN setting
N#endif
N#endif
N
N#ifdef _EXCVT
Sstatic const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for SBCS extended characters */
N#endif
N
N
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Module Private Functions
N
N---------------------------------------------------------------------------*/
N
N
N/*-----------------------------------------------------------------------*/
N/* Load/Store multi-byte word in the FAT structure                       */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NWORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
N{
N	WORD rv;
N
N	rv = ptr[1];
N	rv = rv << 8 | ptr[0];
N	return rv;
N}
N
Nstatic
NDWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
N{
N	DWORD rv;
N
N	rv = ptr[3];
N	rv = rv << 8 | ptr[2];
N	rv = rv << 8 | ptr[1];
N	rv = rv << 8 | ptr[0];
N	return rv;
N}
N
N#if _FS_EXFAT
X#if 0
Sstatic
SQWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
S{
S	QWORD rv;
S
S	rv = ptr[7];
S	rv = rv << 8 | ptr[6];
S	rv = rv << 8 | ptr[5];
S	rv = rv << 8 | ptr[4];
S	rv = rv << 8 | ptr[3];
S	rv = rv << 8 | ptr[2];
S	rv = rv << 8 | ptr[1];
S	rv = rv << 8 | ptr[0];
S	return rv;
S}
N#endif
N
N#if !_FS_READONLY
X#if !0
Nstatic
Nvoid st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
N{
N	*ptr++ = (BYTE)val; val >>= 8;
N	*ptr++ = (BYTE)val;
N}
N
Nstatic
Nvoid st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
N{
N	*ptr++ = (BYTE)val; val >>= 8;
N	*ptr++ = (BYTE)val; val >>= 8;
N	*ptr++ = (BYTE)val; val >>= 8;
N	*ptr++ = (BYTE)val;
N}
N
N#if _FS_EXFAT
X#if 0
Sstatic
Svoid st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
S{
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val; val >>= 8;
S	*ptr++ = (BYTE)val;
S}
N#endif
N#endif	/* !_FS_READONLY */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* String functions                                                      */
N/*-----------------------------------------------------------------------*/
N
N/* Copy memory to memory */
Nstatic
Nvoid mem_cpy (void* dst, const void* src, UINT cnt) {
N	BYTE *d = (BYTE*)dst;
N	const BYTE *s = (const BYTE*)src;
N
N	if (cnt) {
N		do *d++ = *s++; while (--cnt);
N	}
N}
N
N/* Fill memory block */
Nstatic
Nvoid mem_set (void* dst, int val, UINT cnt) {
N	BYTE *d = (BYTE*)dst;
N
N	do *d++ = (BYTE)val; while (--cnt);
N}
N
N/* Compare memory block */
Nstatic
Nint mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
N	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
N	int r = 0;
N
N	do {
N		r = *d++ - *s++;
N	} while (--cnt && r == 0);
N
N	return r;
N}
N
N/* Check if chr is contained in the string */
Nstatic
Nint chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
N	while (*str && *str != chr) str++;
N	return *str;
N}
N
N
N
N
N#if _FS_REENTRANT
X#if 0
S/*-----------------------------------------------------------------------*/
S/* Request/Release grant to access the volume                            */
S/*-----------------------------------------------------------------------*/
Sstatic
Sint lock_fs (
S	FATFS* fs		/* File system object */
S)
S{
S	return ff_req_grant(fs->sobj);
S}
S
S
Sstatic
Svoid unlock_fs (
S	FATFS* fs,		/* File system object */
S	FRESULT res		/* Result code to be returned */
S)
S{
S	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
S		ff_rel_grant(fs->sobj);
S	}
S}
S
N#endif
N
N
N
N#if _FS_LOCK != 0
X#if 0 != 0
S/*-----------------------------------------------------------------------*/
S/* File lock control functions                                           */
S/*-----------------------------------------------------------------------*/
S
Sstatic
SFRESULT chk_lock (	/* Check if the file can be accessed */
S	DIR* dp,		/* Directory object pointing the file to be checked */
S	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
S)
S{
S	UINT i, be;
S
S	/* Search file semaphore table */
S	for (i = be = 0; i < _FS_LOCK; i++) {
S		if (Files[i].fs) {	/* Existing entry */
S			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
S				Files[i].clu == dp->obj.sclust &&
S				Files[i].ofs == dp->dptr) break;
S		} else {			/* Blank entry */
S			be = 1;
S		}
S	}
S	if (i == _FS_LOCK) {	/* The object is not opened */
S		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
S	}
S
S	/* The object has been opened. Reject any open against writing file and all write mode open */
S	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
S}
S
S
Sstatic
Sint enq_lock (void)	/* Check if an entry is available for a new object */
S{
S	UINT i;
S
S	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
S	return (i == _FS_LOCK) ? 0 : 1;
S}
S
S
Sstatic
SUINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
S	DIR* dp,	/* Directory object pointing the file to register or increment */
S	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
S)
S{
S	UINT i;
S
S
S	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
S		if (Files[i].fs == dp->obj.fs &&
S			Files[i].clu == dp->obj.sclust &&
S			Files[i].ofs == dp->dptr) break;
S	}
S
S	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
S		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
S		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
S		Files[i].fs = dp->obj.fs;
S		Files[i].clu = dp->obj.sclust;
S		Files[i].ofs = dp->dptr;
S		Files[i].ctr = 0;
S	}
S
S	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
S
S	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
S
S	return i + 1;
S}
S
S
Sstatic
SFRESULT dec_lock (	/* Decrement object open counter */
S	UINT i			/* Semaphore index (1..) */
S)
S{
S	WORD n;
S	FRESULT res;
S
S
S	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
S		n = Files[i].ctr;
S		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
S		if (n > 0) n--;				/* Decrement read mode open count */
S		Files[i].ctr = n;
S		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
S		res = FR_OK;
S	} else {
S		res = FR_INT_ERR;			/* Invalid index nunber */
S	}
S	return res;
S}
S
S
Sstatic
Svoid clear_lock (	/* Clear lock entries of the volume */
S	FATFS *fs
S)
S{
S	UINT i;
S
S	for (i = 0; i < _FS_LOCK; i++) {
S		if (Files[i].fs == fs) Files[i].fs = 0;
S	}
S}
S
N#endif	/* _FS_LOCK != 0 */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Move/Flush disk access window in the file system object               */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !0
Nstatic
NFRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
N	FATFS* fs			/* File system object */
N)
N{
N	DWORD wsect;
N	UINT nf;
N	FRESULT res = FR_OK;
N
N
N	if (fs->wflag) {	/* Write back the sector if it is dirty */
N		wsect = fs->winsect;	/* Current sector number */
N		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
N			res = FR_DISK_ERR;
N		} else {
N			fs->wflag = 0;
N			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
N				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
N					wsect += fs->fsize;
N					disk_write(fs->drv, fs->win, wsect, 1);
N				}
N			}
N		}
N	}
N	return res;
N}
N#endif
N
N
Nstatic
NFRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
N	FATFS* fs,			/* File system object */
N	DWORD sector		/* Sector number to make appearance in the fs->win[] */
N)
N{
N	FRESULT res = FR_OK;
N
N
N	if (sector != fs->winsect) {	/* Window offset changed? */
N#if !_FS_READONLY
X#if !0
N		res = sync_window(fs);		/* Write-back changes */
N#endif
N		if (res == FR_OK) {			/* Fill sector window with new data */
N			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
N				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
N				res = FR_DISK_ERR;
N			}
N			fs->winsect = sector;
N		}
N	}
N	return res;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Synchronize file system and strage device                             */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
N	FATFS* fs		/* File system object */
N)
N{
N	FRESULT res;
N
N
N	res = sync_window(fs);
N	if (res == FR_OK) {
N		/* Update FSInfo sector if needed */
N		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
X		if (fs->fs_type == 3 && fs->fsi_flag == 1) {
N			/* Create FSInfo structure */
N			mem_set(fs->win, 0, SS(fs));
X			mem_set(fs->win, 0, ((UINT)512));
N			st_word(fs->win + BS_55AA, 0xAA55);
X			st_word(fs->win + 510, 0xAA55);
N			st_dword(fs->win + FSI_LeadSig, 0x41615252);
X			st_dword(fs->win + 0, 0x41615252);
N			st_dword(fs->win + FSI_StrucSig, 0x61417272);
X			st_dword(fs->win + 484, 0x61417272);
N			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
X			st_dword(fs->win + 488, fs->free_clst);
N			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
X			st_dword(fs->win + 492, fs->last_clst);
N			/* Write it into the FSInfo sector */
N			fs->winsect = fs->volbase + 1;
N			disk_write(fs->drv, fs->win, fs->winsect, 1);
N			fs->fsi_flag = 0;
N		}
N		/* Make sure that no pending write process in the physical drive */
N		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
X		if (disk_ioctl(fs->drv, 0, 0) != RES_OK) res = FR_DISK_ERR;
N	}
N
N	return res;
N}
N
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Get sector# from cluster#                                             */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NDWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
N	FATFS* fs,		/* File system object */
N	DWORD clst		/* Cluster# to be converted */
N)
N{
N	clst -= 2;
N	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
N	return clst * fs->csize + fs->database;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT access - Read value of a FAT entry                                */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NDWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
N	_FDID* obj,	/* Corresponding object */
N	DWORD clst	/* Cluster number to get the value */
N)
N{
N	UINT wc, bc;
N	DWORD val;
N	FATFS *fs = obj->fs;
N
N
N	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
N		val = 1;	/* Internal error */
N
N	} else {
N		val = 0xFFFFFFFF;	/* Default value falls on disk error */
N
N		switch (fs->fs_type) {
N		case FS_FAT12 :
X		case 1 :
N			bc = (UINT)clst; bc += bc / 2;
N			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
X			if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
N			wc = fs->win[bc++ % SS(fs)];
X			wc = fs->win[bc++ % ((UINT)512)];
N			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
X			if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
N			wc |= fs->win[bc % SS(fs)] << 8;
X			wc |= fs->win[bc % ((UINT)512)] << 8;
N			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
N			break;
N
N		case FS_FAT16 :
X		case 2 :
N			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
X			if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2))) != FR_OK) break;
N			val = ld_word(fs->win + clst * 2 % SS(fs));
X			val = ld_word(fs->win + clst * 2 % ((UINT)512));
N			break;
N
N		case FS_FAT32 :
X		case 3 :
N			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
X			if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4))) != FR_OK) break;
N			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
X			val = ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0x0FFFFFFF;
N			break;
N#if _FS_EXFAT
X#if 0
S		case FS_EXFAT :
S			if (obj->objsize) {
S				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
S				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
S
S				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
S					if (cofs <= clen) {
S						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
S						break;
S					}
S				}
S				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the contiguous part? */
S					val = clst + 1; 	/* Generate the value */
S					break;
S				}
S				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
S					if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
S					val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
S					break;
S				}
S			}
S			/* go next */
N#endif
N		default:
N			val = 1;	/* Internal error */
N		}
N	}
N
N	return val;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* FAT access - Change value of a FAT entry                              */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
N	FATFS* fs,		/* Corresponding file system object */
N	DWORD clst,		/* FAT index number (cluster number) to be changed */
N	DWORD val		/* New value to be set to the entry */
N)
N{
N	UINT bc;
N	BYTE *p;
N	FRESULT res = FR_INT_ERR;
N
N
N	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
N		switch (fs->fs_type) {
N		case FS_FAT12 :	/* Bitfield items */
X		case 1 :	 
N			bc = (UINT)clst; bc += bc / 2;
N			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
X			res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
N			if (res != FR_OK) break;
N			p = fs->win + bc++ % SS(fs);
X			p = fs->win + bc++ % ((UINT)512);
N			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
N			fs->wflag = 1;
N			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
X			res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
N			if (res != FR_OK) break;
N			p = fs->win + bc % SS(fs);
X			p = fs->win + bc % ((UINT)512);
N			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
N			fs->wflag = 1;
N			break;
N
N		case FS_FAT16 :	/* WORD aligned items */
X		case 2 :	 
N			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
X			res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2)));
N			if (res != FR_OK) break;
N			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
X			st_word(fs->win + clst * 2 % ((UINT)512), (WORD)val);
N			fs->wflag = 1;
N			break;
N
N		case FS_FAT32 :	/* DWORD aligned items */
X		case 3 :	 
N#if _FS_EXFAT
X#if 0
S		case FS_EXFAT :
N#endif
N			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
X			res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4)));
N			if (res != FR_OK) break;
N			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
X			if (!0 || fs->fs_type != 4) {
N				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
X				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0xF0000000);
N			}
N			st_dword(fs->win + clst * 4 % SS(fs), val);
X			st_dword(fs->win + clst * 4 % ((UINT)512), val);
N			fs->wflag = 1;
N			break;
N		}
N	}
N	return res;
N}
N
N#endif /* !_FS_READONLY */
N
N
N
N
N#if _FS_EXFAT && !_FS_READONLY
X#if 0 && !0
S/*-----------------------------------------------------------------------*/
S/* exFAT: Accessing FAT and Allocation Bitmap                            */
S/*-----------------------------------------------------------------------*/
S
S/*---------------------------------------------*/
S/* exFAT: Find a contiguous free cluster block */
S/*---------------------------------------------*/
S
Sstatic
SDWORD find_bitmap (	/* 0:No free cluster, 2..:Free cluster found, 0xFFFFFFFF:Disk error */
S	FATFS* fs,	/* File system object */
S	DWORD clst,	/* Cluster number to scan from */
S	DWORD ncl	/* Number of contiguous clusters to find (1..) */
S)
S{
S	BYTE bm, bv;
S	UINT i;
S	DWORD val, scl, ctr;
S
S
S	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
S	if (clst >= fs->n_fatent - 2) clst = 0;
S	scl = val = clst; ctr = 0;
S	for (;;) {
S		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;	/* (assuming bitmap is located top of the cluster heap) */
S		i = val / 8 % SS(fs); bm = 1 << (val % 8);
S		do {
S			do {
S				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
S				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
S					val = 0; bm = 0; i = 4096;
S				}
S				if (!bv) {	/* Is it a free cluster? */
S					if (++ctr == ncl) return scl + 2;	/* Check run length */
S				} else {
S					scl = val; ctr = 0;		/* Encountered a live cluster, restart to scan */
S				}
S				if (val == clst) return 0;	/* All cluster scanned? */
S			} while (bm);
S			bm = 1;
S		} while (++i < SS(fs));
S	}
S}
S
S
S/*------------------------------------*/
S/* exFAT: Set/Clear a block of bitmap */
S/*------------------------------------*/
S
Sstatic
SFRESULT change_bitmap (
S	FATFS* fs,	/* File system object */
S	DWORD clst,	/* Cluster number to change from */
S	DWORD ncl,	/* Number of clusters to be changed */
S	int bv		/* bit value to be set (0 or 1) */
S)
S{
S	BYTE bm;
S	UINT i;
S	DWORD sect;
S
S
S	clst -= 2;	/* The first bit corresponds to cluster #2 */
S	sect = fs->database + clst / 8 / SS(fs);	/* Sector address (assuming bitmap is located top of the cluster heap) */
S	i = clst / 8 % SS(fs);						/* Byte offset in the sector */
S	bm = 1 << (clst % 8);						/* Bit mask in the byte */
S	for (;;) {
S		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
S		do {
S			do {
S				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
S				fs->win[i] ^= bm;	/* Flip the bit */
S				fs->wflag = 1;
S				if (--ncl == 0) return FR_OK;	/* All bits processed? */
S			} while (bm <<= 1);		/* Next bit */
S			bm = 1;
S		} while (++i < SS(fs));		/* Next byte */
S		i = 0;
S	}
S}
S
S
S/*---------------------------------------------*/
S/* Complement contiguous part of the FAT chain */
S/*---------------------------------------------*/
S
Sstatic
SFRESULT fill_fat_chain (
S	_FDID* obj	/* Pointer to the corresponding object */
S)
S{
S	FRESULT res;
S	DWORD cl, n;
S
S	if (obj->stat == 3) {	/* Has the object been changed 'fragmented'? */
S		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
S			res = put_fat(obj->fs, cl, cl + 1);
S			if (res != FR_OK) return res;
S		}
S		obj->stat = 0;	/* Change status 'FAT chain is valid' */
S	}
S	return FR_OK;
S}
S
N#endif	/* _FS_EXFAT && !_FS_READONLY */
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Remove a cluster chain                                 */
N/*-----------------------------------------------------------------------*/
Nstatic
NFRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
N	_FDID* obj,			/* Corresponding object */
N	DWORD clst,			/* Cluster to remove a chain from */
N	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
N)
N{
N	FRESULT res = FR_OK;
N	DWORD nxt;
N	FATFS *fs = obj->fs;
N#if _FS_EXFAT || _USE_TRIM
X#if 0 || 0
S	DWORD scl = clst, ecl = clst;
N#endif
N#if _USE_TRIM
X#if 0
S	DWORD rt[2];
N#endif
N
N	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
N
N	/* Mark the previous cluster 'EOC' on the FAT if it exists */
N	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
X	if (pclst && (!0 || fs->fs_type != 4 || obj->stat != 2)) {
N		res = put_fat(fs, pclst, 0xFFFFFFFF);
N		if (res != FR_OK) return res;
N	}
N
N	/* Remove the chain */
N	do {
N		nxt = get_fat(obj, clst);			/* Get cluster status */
N		if (nxt == 0) break;				/* Empty cluster? */
N		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
N		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
N		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
X		if (!0 || fs->fs_type != 4) {
N			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
N			if (res != FR_OK) return res;
N		}
N		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
N			fs->free_clst++;
N			fs->fsi_flag |= 1;
N		}
N#if _FS_EXFAT || _USE_TRIM
X#if 0 || 0
S		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
S			ecl = nxt;
S		} else {				/* End of contiguous cluster block */ 
S#if _FS_EXFAT
S			if (fs->fs_type == FS_EXFAT) {
S				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
S				if (res != FR_OK) return res;
S			}
S#endif
S#if _USE_TRIM
S			rt[0] = clust2sect(fs, scl);					/* Start sector */
S			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
S			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
S#endif
S			scl = ecl = nxt;
S		}
N#endif
N		clst = nxt;					/* Next cluster */
N	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
N
N#if _FS_EXFAT
X#if 0
S	if (fs->fs_type == FS_EXFAT) {
S		if (pclst == 0) {	/* Does object have no chain? */
S			obj->stat = 0;		/* Change the object status 'initial' */
S		} else {
S			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain got contiguous? */
S				obj->stat = 2;	/* Change the object status 'contiguous' */
S			}
S		}
S	}
N#endif
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Stretch a chain or Create a new chain                  */
N/*-----------------------------------------------------------------------*/
Nstatic
NDWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
N	_FDID* obj,			/* Corresponding object */
N	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
N)
N{
N	DWORD cs, ncl, scl;
N	FRESULT res;
N	FATFS *fs = obj->fs;
N
N
N	if (clst == 0) {	/* Create a new chain */
N		scl = fs->last_clst;				/* Get suggested cluster to start from */
N		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
N	}
N	else {				/* Stretch current chain */
N		cs = get_fat(obj, clst);			/* Check the cluster status */
N		if (cs < 2) return 1;				/* Invalid value */
N		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
N		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
N		scl = clst;
N	}
N
N#if _FS_EXFAT
X#if 0
S	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
S		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
S		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
S		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
S		if (res == FR_INT_ERR) return 1;
S		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
S		if (clst == 0) {							/* Is it a new chain? */
S			obj->stat = 2;							/* Set status 'contiguous chain' */
S		} else {									/* This is a stretched chain */
S			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
S				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
S				obj->stat = 3;						/* Change status 'just fragmented' */
S			}
S		}
S	} else
N#endif
N	{	/* On the FAT12/16/32 volume */
N		ncl = scl;	/* Start cluster */
N		for (;;) {
N			ncl++;							/* Next cluster */
N			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
N				ncl = 2;
N				if (ncl > scl) return 0;	/* No free cluster */
N			}
N			cs = get_fat(obj, ncl);			/* Get the cluster status */
N			if (cs == 0) break;				/* Found a free cluster */
N			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
N			if (ncl == scl) return 0;		/* No free cluster */
N		}
N	}
N
N	if (_FS_EXFAT && fs->fs_type == FS_EXFAT && obj->stat == 2) {	/* Is it a contiguous chain? */
X	if (0 && fs->fs_type == 4 && obj->stat == 2) {	 
N		res = FR_OK;						/* FAT does not need to be written */
N	} else {
N		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
N		if (res == FR_OK && clst) {
N			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
N		}
N	}
N
N	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
N		fs->last_clst = ncl;
N		if (fs->free_clst < fs->n_fatent - 2) fs->free_clst--;
N		fs->fsi_flag |= 1;
N	} else {
N		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Create error status */
N	}
N
N	return ncl;		/* Return new cluster number or error status */
N}
N
N#endif /* !_FS_READONLY */
N
N
N
N
N#if _USE_FASTSEEK
X#if 0
S/*-----------------------------------------------------------------------*/
S/* FAT handling - Convert offset into cluster with link map table        */
S/*-----------------------------------------------------------------------*/
S
Sstatic
SDWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
S	FIL* fp,		/* Pointer to the file object */
S	FSIZE_t ofs		/* File offset to be converted to cluster# */
S)
S{
S	DWORD cl, ncl, *tbl;
S	FATFS *fs = fp->obj.fs;
S
S
S	tbl = fp->cltbl + 1;	/* Top of CLMT */
S	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
S	for (;;) {
S		ncl = *tbl++;			/* Number of cluters in the fragment */
S		if (ncl == 0) return 0;	/* End of table? (error) */
S		if (cl < ncl) break;	/* In this fragment? */
S		cl -= ncl; tbl++;		/* Next fragment */
S	}
S	return cl + *tbl;	/* Return the cluster number */
S}
S
N#endif	/* _USE_FASTSEEK */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Set directory index                              */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
N	DIR* dp,		/* Pointer to directory object */
N	DWORD ofs		/* Offset of directory table */
N)
N{
N	DWORD csz, clst;
N	FATFS *fs = dp->obj.fs;
N
N
N	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
X	if (ofs >= (DWORD)((0 && fs->fs_type == 4) ? 0x10000000 : 0x200000) || ofs % 32) {	 
N		return FR_INT_ERR;
N	}
N	dp->dptr = ofs;				/* Set current offset */
N	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
N	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
X	if (clst == 0 && fs->fs_type >= 3) {	 
N		clst = fs->dirbase;
N		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
X		if (0) dp->obj.stat = 0;	 
N	}
N
N	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
N		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
X		if (ofs / 32 >= fs->n_rootdir)	return FR_INT_ERR;	 
N		dp->sect = fs->dirbase;
N
N	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
N		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
X		csz = (DWORD)fs->csize * ((UINT)512);	 
N		while (ofs >= csz) {				/* Follow cluster chain */
N			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
N			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
N			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
N			ofs -= csz;
N		}
N		dp->sect = clust2sect(fs, clst);
N	}
N	dp->clust = clst;					/* Current cluster# */
N	if (!dp->sect) return FR_INT_ERR;
N	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
X	dp->sect += ofs / ((UINT)512);			 
N	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
X	dp->dir = fs->win + (ofs % ((UINT)512));	 
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Move directory table index next                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
N	DIR* dp,		/* Pointer to the directory object */
N	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
N)
N{
N	DWORD ofs, clst;
N	FATFS *fs = dp->obj.fs;
N#if !_FS_READONLY
X#if !0
N	UINT n;
N#endif
N
N	ofs = dp->dptr + SZDIRE;	/* Next entry */
X	ofs = dp->dptr + 32;	 
N	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
X	if (!dp->sect || ofs >= (DWORD)((0 && fs->fs_type == 4) ? 0x10000000 : 0x200000)) return FR_NO_FILE;	 
N
N	if (ofs % SS(fs) == 0) {	/* Sector changed? */
X	if (ofs % ((UINT)512) == 0) {	 
N		dp->sect++;				/* Next sector */
N
N		if (!dp->clust) {		/* Static table */
N			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
X			if (ofs / 32 >= fs->n_rootdir) {	 
N				dp->sect = 0; return FR_NO_FILE;
N			}
N		}
N		else {					/* Dynamic table */
N			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
X			if ((ofs / ((UINT)512) & (fs->csize - 1)) == 0) {		 
N				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
N				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
N				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
N				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
N#if !_FS_READONLY
X#if !0
N					if (!stretch) {								/* If no stretch, report EOT */
N						dp->sect = 0; return FR_NO_FILE;
N					}
N					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
N					if (clst == 0) return FR_DENIED;			/* No free cluster */
N					if (clst == 1) return FR_INT_ERR;			/* Internal error */
N					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
N					/* Clean-up the stretched table */
N					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
X					if (0) dp->obj.stat |= 4;			 
N					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
N					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
X					mem_set(fs->win, 0, ((UINT)512));				 
N					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
N						fs->wflag = 1;
N						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
N					}
N					fs->winsect -= n;							/* Restore window offset */
N#else
S					if (!stretch) dp->sect = 0;					/* If no stretch, report EOT (this is to suppress warning) */
S					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
N#endif
N				}
N				dp->clust = clst;		/* Initialize data for new cluster */
N				dp->sect = clust2sect(fs, clst);
N			}
N		}
N	}
N	dp->dptr = ofs;						/* Current entry */
N	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
X	dp->dir = fs->win + ofs % ((UINT)512);	 
N
N	return FR_OK;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Reserve a block of directory entries             */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
N	DIR* dp,		/* Pointer to the directory object */
N	UINT nent		/* Number of contiguous entries to allocate */
N)
N{
N	FRESULT res;
N	UINT n;
N	FATFS *fs = dp->obj.fs;
N
N
N	res = dir_sdi(dp, 0);
N	if (res == FR_OK) {
N		n = 0;
N		do {
N			res = move_window(fs, dp->sect);
N			if (res != FR_OK) break;
N#if _FS_EXFAT
X#if 0
S			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
N#else
N			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
X			if (dp->dir[0] == 0xE5 || dp->dir[0] == 0) {
N#endif
N				if (++n == nent) break;	/* A block of contiguous free entries is found */
N			} else {
N				n = 0;					/* Not a blank entry. Restart to search */
N			}
N			res = dir_next(dp, 1);
N		} while (res == FR_OK);	/* Next entry with table stretch enabled */
N	}
N
N	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
N	return res;
N}
N
N#endif	/* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT: Directory handling - Load/Store start cluster number             */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NDWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
N	FATFS* fs,		/* Pointer to the fs object */
N	const BYTE* dir	/* Pointer to the key entry */
N)
N{
N	DWORD cl;
N
N	cl = ld_word(dir + DIR_FstClusLO);
X	cl = ld_word(dir + 26);
N	if (fs->fs_type == FS_FAT32) {
X	if (fs->fs_type == 3) {
N		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
X		cl |= (DWORD)ld_word(dir + 20) << 16;
N	}
N
N	return cl;
N}
N
N
N#if !_FS_READONLY
X#if !0
Nstatic
Nvoid st_clust (
N	FATFS* fs,	/* Pointer to the fs object */
N	BYTE* dir,	/* Pointer to the key entry */
N	DWORD cl	/* Value to be set */
N)
N{
N	st_word(dir + DIR_FstClusLO, (WORD)cl);
X	st_word(dir + 26, (WORD)cl);
N	if (fs->fs_type == FS_FAT32) {
X	if (fs->fs_type == 3) {
N		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
X		st_word(dir + 20, (WORD)(cl >> 16));
N	}
N}
N#endif
N
N
N
N#if _USE_LFN != 0
X#if 1 != 0
N/*------------------------------------------------------------------------*/
N/* FAT-LFN: LFN handling                                                  */
N/*------------------------------------------------------------------------*/
Nstatic
Nconst BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
N
N
N/*--------------------------------------------------------*/
N/* FAT-LFN: Compare a part of file name with an LFN entry */
N/*--------------------------------------------------------*/
Nstatic
Nint cmp_lfn (				/* 1:matched, 0:not matched */
N	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
N	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
N)
N{
N	UINT i, s;
N	WCHAR wc, uc;
N
N
N	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
X	if (ld_word(dir + 26) != 0) return 0;	 
N
N	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
X	i = ((dir[0] & 0x3F) - 1) * 13;	 
N
N	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
N		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
N		if (wc) {
N			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
X			if (i >= 255 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	 
N				return 0;					/* Not matched */
N			}
N			wc = uc;
N		} else {
N			if (uc != 0xFFFF) return 0;		/* Check filler */
N		}
N	}
N
N	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
X	if ((dir[0] & 0x40) && wc && lfnbuf[i]) return 0;	 
N
N	return 1;		/* The part of LFN matched */
N}
N
N
N#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
X#if 0 <= 1 || 0 >= 2 || 0 || 0
N/*-----------------------------------------------------*/
N/* FAT-LFN: Pick a part of file name from an LFN entry */
N/*-----------------------------------------------------*/
Nstatic
Nint pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
N	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
N	BYTE* dir			/* Pointer to the LFN entry */
N)
N{
N	UINT i, s;
N	WCHAR wc, uc;
N
N
N	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
X	if (ld_word(dir + 26) != 0) return 0;	 
N
N	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
X	i = ((dir[0] & 0x3F) - 1) * 13;	 
N
N	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
N		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
N		if (wc) {
N			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
X			if (i >= 255) return 0;	 
N			lfnbuf[i++] = wc = uc;			/* Store it */
N		} else {
N			if (uc != 0xFFFF) return 0;		/* Check filler */
N		}
N	}
N
N	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
X	if (dir[0] & 0x40) {				 
N		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
X		if (i >= 255) return 0;		 
N		lfnbuf[i] = 0;
N	}
N
N	return 1;		/* The part of LFN is valid */
N}
N#endif
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------*/
N/* FAT-LFN: Create an entry of LFN entries */
N/*-----------------------------------------*/
Nstatic
Nvoid put_lfn (
N	const WCHAR* lfn,	/* Pointer to the LFN */
N	BYTE* dir,			/* Pointer to the LFN entry to be created */
N	BYTE ord,			/* LFN order (1-20) */
N	BYTE sum			/* Checksum of the corresponding SFN */
N)
N{
N	UINT i, s;
N	WCHAR wc;
N
N
N	dir[LDIR_Chksum] = sum;			/* Set checksum */
X	dir[13] = sum;			 
N	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
X	dir[11] = 0x0F;		 
N	dir[LDIR_Type] = 0;
X	dir[12] = 0;
N	st_word(dir + LDIR_FstClusLO, 0);
X	st_word(dir + 26, 0);
N
N	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
N	s = wc = 0;
N	do {
N		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
N		st_word(dir + LfnOfs[s], wc);		/* Put it */
N		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
N	} while (++s < 13);
N	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
X	if (wc == 0xFFFF || !lfn[i]) ord |= 0x40;	 
N	dir[LDIR_Ord] = ord;			/* Set the LFN order */
X	dir[0] = ord;			 
N}
N
N#endif	/* !_FS_READONLY */
N#endif	/* _USE_LFN != 0 */
N
N
N
N#if _USE_LFN != 0 && !_FS_READONLY
X#if 1 != 0 && !0
N/*-----------------------------------------------------------------------*/
N/* FAT-LFN: Create a Numbered SFN                                        */
N/*-----------------------------------------------------------------------*/
N
Nstatic
Nvoid gen_numname (
N	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
N	const BYTE* src,	/* Pointer to SFN */
N	const WCHAR* lfn,	/* Pointer to LFN */
N	UINT seq			/* Sequence number */
N)
N{
N	BYTE ns[8], c;
N	UINT i, j;
N	WCHAR wc;
N	DWORD sr;
N
N
N	mem_cpy(dst, src, 11);
N
N	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
N		sr = seq;
N		while (*lfn) {	/* Create a CRC */
N			wc = *lfn++;
N			for (i = 0; i < 16; i++) {
N				sr = (sr << 1) + (wc & 1);
N				wc >>= 1;
N				if (sr & 0x10000) sr ^= 0x11021;
N			}
N		}
N		seq = (UINT)sr;
N	}
N
N	/* itoa (hexdecimal) */
N	i = 7;
N	do {
N		c = (BYTE)((seq % 16) + '0');
N		if (c > '9') c += 7;
N		ns[i--] = c;
N		seq /= 16;
N	} while (seq);
N	ns[i] = '~';
N
N	/* Append the number */
N	for (j = 0; j < i && dst[j] != ' '; j++) {
N		if (IsDBCS1(dst[j])) {
X		if (((BYTE)(dst[j]) >= 0x81 && (BYTE)(dst[j]) <= 0xFE)) {
N			if (j == i - 1) break;
N			j++;
N		}
N	}
N	do {
N		dst[j++] = (i < 8) ? ns[i++] : ' ';
N	} while (j < 8);
N}
N#endif	/* _USE_LFN != 0 && !_FS_READONLY */
N
N
N
N#if _USE_LFN != 0
X#if 1 != 0
N/*-----------------------------------------------------------------------*/
N/* FAT-LFN: Calculate checksum of an SFN entry                           */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NBYTE sum_sfn (
N	const BYTE* dir		/* Pointer to the SFN entry */
N)
N{
N	BYTE sum = 0;
N	UINT n = 11;
N
N	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
N	return sum;
N}
N
N#endif	/* _USE_LFN != 0 */
N
N
N
N#if _FS_EXFAT
X#if 0
S/*-----------------------------------------------------------------------*/
S/* exFAT: Checksum                                                       */
S/*-----------------------------------------------------------------------*/
S
Sstatic
SWORD xdir_sum (			/* Get checksum of the directoly block */
S	const BYTE* dir		/* Directory entry block to be calculated */
S)
S{
S	UINT i, szblk;
S	WORD sum;
S
S
S	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
S	for (i = sum = 0; i < szblk; i++) {
S		if (i == XDIR_SetSum) {	/* Skip sum field */
S			i++;
S		} else {
S			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
S		}
S	}
S	return sum;
S}
S
S
S
Sstatic
SWORD xname_sum (		/* Get check sum (to be used as hash) of the name */
S	const WCHAR* name	/* File name to be calculated */
S)
S{
S	WCHAR chr;
S	WORD sum = 0;
S
S
S	while ((chr = *name++) != 0) {
S		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
S		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
S		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
S	}
S	return sum;
S}
S
S
S#if !_FS_READONLY && _USE_MKFS
Sstatic
SDWORD xsum32 (
S	BYTE  dat,	/* Data to be sumed */
S	DWORD sum	/* Previous value */
S)
S{
S	sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
S	return sum;
S}
S#endif
S
S
S#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
S/*------------------------------------------------------*/
S/* exFAT: Get object information from a directory block */
S/*------------------------------------------------------*/
S
Sstatic
Svoid get_xdir_info (
S	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
S	FILINFO* fno		/* Buffer to store the extracted file information */
S)
S{
S	UINT di, si;
S	WCHAR w;
S#if !_LFN_UNICODE
S	UINT nc;
S#endif
S
S	/* Get file name */
S#if _LFN_UNICODE
S	if (dirb[XDIR_NumName] <= _MAX_LFN) {
S		for (si = SZDIRE * 2, di = 0; di < dirb[XDIR_NumName]; si += 2, di++) {
S			if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
S			w = ld_word(dirb + si);				/* Get a character */
S			fno->fname[di] = w;					/* Store it */
S		}
S	} else {
S		di = 0;	/* Buffer overflow and inaccessible object */
S	}
S#else
S	for (si = SZDIRE * 2, di = nc = 0; nc < dirb[XDIR_NumName]; si += 2, nc++) {
S		if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
S		w = ld_word(dirb + si);				/* Get a character */
S		w = ff_convert(w, 0);				/* Unicode -> OEM */
S		if (w == 0) { di = 0; break; }		/* Could not be converted and inaccessible object */
S		if (_DF1S && w >= 0x100) {			/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
S			fno->fname[di++] = (char)(w >> 8);
S		}
S		if (di >= _MAX_LFN) { di = 0; break; }	/* Buffer overflow and inaccessible object */
S		fno->fname[di++] = (char)w;
S	}
S#endif
S	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object? */
S	fno->fname[di] = 0;						/* Terminate file name */
S
S	fno->altname[0] = 0;							/* No SFN */
S	fno->fattrib = dirb[XDIR_Attr];					/* Attribute */
S	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
S	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
S	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
S}
S
S#endif	/* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
S
S
S/*-----------------------------------*/
S/* exFAT: Get a directry entry block */
S/*-----------------------------------*/
S
Sstatic
SFRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
S	DIR* dp			/* Pointer to the reading direcotry object pointing the 85 entry */
S)
S{
S	FRESULT res;
S	UINT i, nent;
S	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
S
S
S	/* Load 85 entry */
S	res = move_window(dp->obj.fs, dp->sect);
S	if (res != FR_OK) return res;
S	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
S	mem_cpy(dirb, dp->dir, SZDIRE);
S	nent = dirb[XDIR_NumSec] + 1;
S
S	/* Load C0 entry */
S	res = dir_next(dp, 0);
S	if (res != FR_OK) return res;
S	res = move_window(dp->obj.fs, dp->sect);
S	if (res != FR_OK) return res;
S	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
S	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
S
S	/* Load C1 entries */
S	if (nent < 3 || nent > 19) return FR_NO_FILE;
S	i = SZDIRE * 2; nent *= SZDIRE;
S	do {
S		res = dir_next(dp, 0);
S		if (res != FR_OK) return res;
S		res = move_window(dp->obj.fs, dp->sect);
S		if (res != FR_OK) return res;
S		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
S		mem_cpy(dirb + i, dp->dir, SZDIRE);
S		i += SZDIRE;
S	} while (i < nent);
S
S	/* Sanity check */
S	if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
S
S	return FR_OK;
S}
S
S
S#if !_FS_READONLY || _FS_RPATH != 0 
S/*------------------------------------------------*/
S/* exFAT: Load the object's directory entry block */
S/*------------------------------------------------*/
Sstatic
SFRESULT load_obj_dir (	
S	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
S	const _FDID* obj	/* Object with containing directory information */
S)
S{
S	FRESULT res;
S
S
S	/* Open object containing directory */
S	dp->obj.fs = obj->fs;
S	dp->obj.sclust = obj->c_scl;
S	dp->obj.stat = (BYTE)obj->c_size;
S	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
S	dp->blk_ofs = obj->c_ofs;
S
S	res = dir_sdi(dp, dp->blk_ofs);	/* Goto the block location */
S	if (res == FR_OK) {
S		res = load_xdir(dp);		/* Load the object's entry block */
S	}
S	return res;
S}
S#endif
S
S
S#if !_FS_READONLY
S/*-----------------------------------------------*/
S/* exFAT: Store the directory block to the media */
S/*-----------------------------------------------*/
Sstatic
SFRESULT store_xdir (
S	DIR* dp				/* Pointer to the direcotry object */
S)
S{
S	FRESULT res;
S	UINT nent;
S	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
S
S	/* Create set sum */
S	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
S	nent = dirb[XDIR_NumSec] + 1;
S
S	/* Store the set of directory to the volume */
S	res = dir_sdi(dp, dp->blk_ofs);
S	while (res == FR_OK) {
S		res = move_window(dp->obj.fs, dp->sect);
S		if (res != FR_OK) break;
S		mem_cpy(dp->dir, dirb, SZDIRE);
S		dp->obj.fs->wflag = 1;
S		if (--nent == 0) break;
S		dirb += SZDIRE;
S		res = dir_next(dp, 0);
S	}
S	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
S}
S
S
S
S/*-------------------------------------------*/
S/* exFAT: Create a new directory enrty block */
S/*-------------------------------------------*/
S
Sstatic
Svoid create_xdir (
S	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
S	const WCHAR* lfn	/* Pointer to the nul terminated file name */
S)
S{
S	UINT i;
S	BYTE nb, nc;
S	WCHAR chr;
S
S
S	mem_set(dirb, 0, 2 * SZDIRE);			/* Initialize 85+C0 entry */
S	dirb[XDIR_Type] = 0x85;
S	dirb[XDIR_Type + SZDIRE] = 0xC0;
S	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
S
S	i = SZDIRE * 2;	/* C1 offset */
S	nc = 0; nb = 1; chr = 1;
S	do {
S		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
S		do {	/* Fill name field */
S			if (chr && (chr = lfn[nc]) != 0) nc++;	/* Get a character if exist */
S			st_word(dirb + i, chr); i += 2;	/* Store it */
S		} while (i % SZDIRE);
S		nb++;
S	} while (lfn[nc]);	/* Fill next entry if any char follows */
S
S	dirb[XDIR_NumName] = nc;	/* Set name length */
S	dirb[XDIR_NumSec] = nb;		/* Set number of C0+C1s */
S}
S
S#endif	/* !_FS_READONLY */
N#endif	/* _FS_EXFAT */
N
N
N
N#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
X#if 0 <= 1 || 0 >= 2 || 0 || 0
N/*-----------------------------------------------------------------------*/
N/* Read an object from the directory                                     */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_read (
N	DIR* dp,		/* Pointer to the directory object */
N	int vol			/* Filtered by 0:file/directory or 1:volume label */
N)
N{
N	FRESULT res = FR_NO_FILE;
N	FATFS *fs = dp->obj.fs;
N	BYTE a, c;
N#if _USE_LFN != 0
X#if 1 != 0
N	BYTE ord = 0xFF, sum = 0xFF;
N#endif
N
N	while (dp->sect) {
N		res = move_window(fs, dp->sect);
N		if (res != FR_OK) break;
N		c = dp->dir[DIR_Name];	/* Test for the entry type */
X		c = dp->dir[0];	 
N		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of the directory */
N#if _FS_EXFAT
X#if 0
S		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
S			if (_USE_LABEL && vol) {
S				if (c == 0x83) break;	/* Volume label entry? */
S			} else {
S				if (c == 0x85) {		/* Start of the file entry block? */
S					dp->blk_ofs = dp->dptr;	/* Get location of the block */
S					res = load_xdir(dp);	/* Load the entry block */
S					if (res == FR_OK) {
S						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
S					}
S					break;
S				}
S			}
S		} else
N#endif
N		{	/* On the FAT12/16/32 volume */
N			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
X			dp->obj.attr = a = dp->dir[11] & 0x3F;	 
N#if _USE_LFN != 0	/* LFN configuration */
X#if 1 != 0	 
N			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
X			if (c == 0xE5 || c == '.' || (int)((a & ~0x20) == 0x08) != vol) {	 
N				ord = 0xFF;
N			} else {
N				if (a == AM_LFN) {			/* An LFN entry is found */
X				if (a == 0x0F) {			 
N					if (c & LLEF) {			/* Is it start of an LFN sequence? */
X					if (c & 0x40) {			 
N						sum = dp->dir[LDIR_Chksum];
X						sum = dp->dir[13];
N						c &= (BYTE)~LLEF; ord = c;
X						c &= (BYTE)~0x40; ord = c;
N						dp->blk_ofs = dp->dptr;
N					}
N					/* Check LFN validity and capture it */
N					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
X					ord = (c == ord && sum == dp->dir[13] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
N				} else {					/* An SFN entry is found */
N					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
N						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
N					}
N					break;
N				}
N			}
N#else		/* Non LFN configuration */
S			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
S				break;
S			}
N#endif
N		}
N		res = dir_next(dp, 0);		/* Next entry */
N		if (res != FR_OK) break;
N	}
N
N	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
N	return res;
N}
N
N#endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Find an object in the directory                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
N	DIR* dp			/* Pointer to the directory object with the file name */
N)
N{
N	FRESULT res;
N	FATFS *fs = dp->obj.fs;
N	BYTE c;
N#if _USE_LFN != 0
X#if 1 != 0
N	BYTE a, ord, sum;
N#endif
N
N	res = dir_sdi(dp, 0);			/* Rewind directory object */
N	if (res != FR_OK) return res;
N#if _FS_EXFAT
X#if 0
S	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
S		BYTE nc;
S		UINT di, ni;
S		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
S
S		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
S			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip the comparison if hash value mismatched */
S			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
S				if ((di % SZDIRE) == 0) di += 2;
S				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
S			}
S			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
S		}
S		return res;
S	}
N#endif
N	/* On the FAT12/16/32 volume */
N#if _USE_LFN != 0
X#if 1 != 0
N	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
N#endif
N	do {
N		res = move_window(fs, dp->sect);
N		if (res != FR_OK) break;
N		c = dp->dir[DIR_Name];
X		c = dp->dir[0];
N		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
N#if _USE_LFN != 0	/* LFN configuration */
X#if 1 != 0	 
N		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
X		dp->obj.attr = a = dp->dir[11] & 0x3F;
N		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
X		if (c == 0xE5 || ((a & 0x08) && a != 0x0F)) {	 
N			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
N		} else {
N			if (a == AM_LFN) {			/* An LFN entry is found */
X			if (a == 0x0F) {			 
N				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
X				if (!(dp->fn[11] & 0x40)) {
N					if (c & LLEF) {		/* Is it start of LFN sequence? */
X					if (c & 0x40) {		 
N						sum = dp->dir[LDIR_Chksum];
X						sum = dp->dir[13];
N						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
X						c &= (BYTE)~0x40; ord = c;	 
N						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
N					}
N					/* Check validity of the LFN entry and compare it with given name */
N					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
X					ord = (c == ord && sum == dp->dir[13] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
N				}
N			} else {					/* An SFN entry is found */
N				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
N				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
X				if (!(dp->fn[11] & 0x01) && !mem_cmp(dp->dir, dp->fn, 11)) break;	 
N				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
N			}
N		}
N#else		/* Non LFN configuration */
S		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
S		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
N#endif
N		res = dir_next(dp, 0);	/* Next entry */
N	} while (res == FR_OK);
N
N	return res;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Register an object to the directory                                   */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
N	DIR* dp				/* Target directory with object name to be created */
N)
N{
N	FRESULT res;
N	FATFS *fs = dp->obj.fs;
N#if _USE_LFN != 0	/* LFN configuration */
X#if 1 != 0	 
N	UINT n, nlen, nent;
N	BYTE sn[12], sum;
N
N
N	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
X	if (dp->fn[11] & (0x20 | 0x80)) return FR_INVALID_NAME;	 
N	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
N
N#if _FS_EXFAT
X#if 0
S	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
S		DIR dj;
S
S		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
S		res = dir_alloc(dp, nent);		/* Allocate entries */
S		if (res != FR_OK) return res;
S		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);			/* Set block position */
S
S		if (dp->obj.sclust != 0 && (dp->obj.stat & 4)) {	/* Has the sub-directory been stretched? */
S			dp->obj.stat &= 3;
S			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase object size by cluster size */
S			res = fill_fat_chain(&dp->obj);	/* Complement FAT chain if needed */
S			if (res != FR_OK) return res;
S			res = load_obj_dir(&dj, &dp->obj);
S			if (res != FR_OK) return res;	/* Load the object status */
S			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
S			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
S			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
S			res = store_xdir(&dj);			/* Store the object status */
S			if (res != FR_OK) return res;
S		}
S
S		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
S		return FR_OK;
S	}
N#endif
N	/* On the FAT12/16/32 volume */
N	mem_cpy(sn, dp->fn, 12);
N	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
X	if (sn[11] & 0x01) {			 
N		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
X		dp->fn[11] = 0x40;		 
N		for (n = 1; n < 100; n++) {
N			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
N			res = dir_find(dp);				/* Check if the name collides with existing SFN */
N			if (res != FR_OK) break;
N		}
N		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
N		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
N		dp->fn[NSFLAG] = sn[NSFLAG];
X		dp->fn[11] = sn[11];
N	}
N
N	/* Create an SFN with/without LFNs. */
N	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
X	nent = (sn[11] & 0x02) ? (nlen + 12) / 13 + 1 : 1;	 
N	res = dir_alloc(dp, nent);		/* Allocate entries */
N	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
N		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
X		res = dir_sdi(dp, dp->dptr - nent * 32);
N		if (res == FR_OK) {
N			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
N			do {					/* Store LFN entries in bottom first */
N				res = move_window(fs, dp->sect);
N				if (res != FR_OK) break;
N				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
N				fs->wflag = 1;
N				res = dir_next(dp, 0);	/* Next entry */
N			} while (res == FR_OK && --nent);
N		}
N	}
N
N#else	/* Non LFN configuration */
S	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
S
N#endif
N
N	/* Set SFN entry */
N	if (res == FR_OK) {
N		res = move_window(fs, dp->sect);
N		if (res == FR_OK) {
N			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
X			mem_set(dp->dir, 0, 32);	 
N			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
X			mem_cpy(dp->dir + 0, dp->fn, 11);	 
N#if _USE_LFN != 0
X#if 1 != 0
N			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
X			dp->dir[12] = dp->fn[11] & (0x08 | 0x10);	 
N#endif
N			fs->wflag = 1;
N		}
N	}
N
N	return res;
N}
N
N#endif /* !_FS_READONLY */
N
N
N
N#if !_FS_READONLY && _FS_MINIMIZE == 0
X#if !0 && 0 == 0
N/*-----------------------------------------------------------------------*/
N/* Remove an object from the directory                                   */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
N	DIR* dp				/* Directory object pointing the entry to be removed */
N)
N{
N	FRESULT res;
N	FATFS *fs = dp->obj.fs;
N#if _USE_LFN != 0	/* LFN configuration */
X#if 1 != 0	 
N	DWORD last = dp->dptr;
N
N	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
N	if (res == FR_OK) {
N		do {
N			res = move_window(fs, dp->sect);
N			if (res != FR_OK) break;
N			/* Mark an entry 'deleted' */
N			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
X			if (0 && fs->fs_type == 4) {	 
N				dp->dir[XDIR_Type] &= 0x7F;
X				dp->dir[0] &= 0x7F;
N			} else {									/* On the FAT12/16/32 volume */
N				dp->dir[DIR_Name] = DDEM;
X				dp->dir[0] = 0xE5;
N			}
N			fs->wflag = 1;
N			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
N			res = dir_next(dp, 0);	/* Next entry */
N		} while (res == FR_OK);
N		if (res == FR_NO_FILE) res = FR_INT_ERR;
N	}
N#else			/* Non LFN configuration */
S
S	res = move_window(fs, dp->sect);
S	if (res == FR_OK) {
S		dp->dir[DIR_Name] = DDEM;
S		fs->wflag = 1;
S	}
N#endif
N
N	return res;
N}
N
N#endif /* !_FS_READONLY && _FS_MINIMIZE == 0 */
N
N
N
N#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
X#if 0 <= 1 || 0 >= 2
N/*-----------------------------------------------------------------------*/
N/* Get file information from directory entry                             */
N/*-----------------------------------------------------------------------*/
N
Nstatic
Nvoid get_fileinfo (		/* No return code */
N	DIR* dp,			/* Pointer to the directory object */
N	FILINFO* fno	 	/* Pointer to the file information to be filled */
N)
N{
N	UINT i, j;
N	TCHAR c;
N	DWORD tm;
N#if _USE_LFN != 0
X#if 1 != 0
N	WCHAR w, lfv;
N	FATFS *fs = dp->obj.fs;
N#endif
N
N
N	fno->fname[0] = 0;		/* Invaidate file info */
N	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
N
N#if _USE_LFN != 0	/* LFN configuration */
X#if 1 != 0	 
N#if _FS_EXFAT
X#if 0
S	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
S		get_xdir_info(fs->dirbuf, fno);
S		return;
S	} else
N#endif
N	{	/* On the FAT12/16/32 volume */
N		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
N			i = j = 0;
N			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
N#if !_LFN_UNICODE
X#if !0
N				w = ff_convert(w, 0);		/* Unicode -> OEM */
N				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
N				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
X				if (0x81 && w >= 0x100) {	 
N					fno->fname[i++] = (char)(w >> 8);
N				}
N#endif
N				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
X				if (i >= 255) { i = 0; break; }	 
N				fno->fname[i++] = (TCHAR)w;
N			}
N			fno->fname[i] = 0;	/* Terminate the LFN */
N		}
N	}
N
N	i = j = 0;
N	lfv = fno->fname[i];	/* LFN is exist if non-zero */
N	while (i < 11) {		/* Copy name body and extension */
N		c = (TCHAR)dp->dir[i++];
N		if (c == ' ') continue;				/* Skip padding spaces */
N		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
X		if (c == 0x05) c = (TCHAR)0xE5;	 
N		if (i == 9) {						/* Insert a . if extension is exist */
N			if (!lfv) fno->fname[j] = '.';
N			fno->altname[j++] = '.';
N		}
N#if _LFN_UNICODE
X#if 0
S		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
S			c = c << 8 | dp->dir[i++];
S		}
S		c = ff_convert(c, 1);	/* OEM -> Unicode */
S		if (!c) c = '?';
N#endif
N		fno->altname[j] = c;
N		if (!lfv) {
N			if (IsUpper(c) && (dp->dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY))) {
X			if ((((c)>= 'A')&&((c)<= 'Z')) && (dp->dir[12] & (i >= 9 ? 0x10 : 0x08))) {
N				c += 0x20;			/* To lower */
N			}
N			fno->fname[j] = c;
N		}
N		j++;
N	}
N	if (!lfv) {
N		fno->fname[j] = 0;
N		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
X		if (!dp->dir[12]) j = 0;	 
N	}
N	fno->altname[j] = 0;	/* Terminate the SFN */
N
N#else	/* Non-LFN configuration */
S	i = j = 0;
S	while (i < 11) {		/* Copy name body and extension */
S		c = (TCHAR)dp->dir[i++];
S		if (c == ' ') continue;				/* Skip padding spaces */
S		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
S		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
S		fno->fname[j++] = c;
S	}
S	fno->fname[j] = 0;
N#endif
N
N	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
X	fno->fattrib = dp->dir[11];				 
N	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
X	fno->fsize = ld_dword(dp->dir + 28);	 
N	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
X	tm = ld_dword(dp->dir + 22);			 
N	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
N}
N
N#endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
N
N
N
N#if _USE_FIND && _FS_MINIMIZE <= 1
X#if 0 && 0 <= 1
S/*-----------------------------------------------------------------------*/
S/* Pattern matching                                                      */
S/*-----------------------------------------------------------------------*/
S
Sstatic
SWCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
S	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
S)
S{
S#if !_LFN_UNICODE
S	WCHAR chr;
S
S	chr = (BYTE)*(*ptr)++;					/* Get a byte */
S	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
S#ifdef _EXCVT
S	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
S#else
S	if (IsDBCS1(chr) && IsDBCS2(**ptr)) {		/* Get DBC 2nd byte if needed */
S		chr = chr << 8 | (BYTE)*(*ptr)++;
S	}
S#endif
S	return chr;
S#else
S	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
S#endif
S}
S
S
Sstatic
Sint pattern_matching (	/* 0:not matched, 1:matched */
S	const TCHAR* pat,	/* Matching pattern */
S	const TCHAR* nam,	/* String to be tested */
S	int skip,			/* Number of pre-skip chars (number of ?s) */
S	int inf				/* Infinite search (* specified) */
S)
S{
S	const TCHAR *pp, *np;
S	WCHAR pc, nc;
S	int nm, nx;
S
S
S	while (skip--) {				/* Pre-skip name chars */
S		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
S	}
S	if (!*pat && inf) return 1;		/* (short circuit) */
S
S	do {
S		pp = pat; np = nam;			/* Top of pattern and name to match */
S		for (;;) {
S			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
S				nm = nx = 0;
S				do {				/* Analyze the wildcard chars */
S					if (*pp++ == '?') nm++; else nx = 1;
S				} while (*pp == '?' || *pp == '*');
S				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
S				nc = *np; break;	/* Branch mismatched */
S			}
S			pc = get_achar(&pp);	/* Get a pattern char */
S			nc = get_achar(&np);	/* Get a name char */
S			if (pc != nc) break;	/* Branch mismatched? */
S			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
S		}
S		get_achar(&nam);			/* nam++ */
S	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
S
S	return 0;
S}
S
N#endif /* _USE_FIND && _FS_MINIMIZE <= 1 */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Pick a top segment and create the object name in directory form       */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
N	DIR* dp,			/* Pointer to the directory object */
N	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
N)
N{
N#if _USE_LFN != 0	/* LFN configuration */
X#if 1 != 0	 
N	BYTE b, cf;
N	WCHAR w, *lfn;
N	UINT i, ni, si, di;
N	const TCHAR *p;
N
N	/* Create LFN in Unicode */
N	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
N	for (;;) {
N		w = p[si++];					/* Get a character */
N		if (w < ' ') break;				/* Break if end of the path name */
N		if (w == '/' || w == '\\') {	/* Break if a separator is found */
N			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
N			break;
N		}
N		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
X		if (di >= 255) return FR_INVALID_NAME;	 
N#if !_LFN_UNICODE
X#if !0
N		w &= 0xFF;
N		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
X		if (((BYTE)(w) >= 0x81 && (BYTE)(w) <= 0xFE)) {				 
N			b = (BYTE)p[si++];			/* Get 2nd byte */
N			w = (w << 8) + b;			/* Create a DBC */
N			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
X			if (!(((BYTE)(b) >= 0x40 && (BYTE)(b) <= 0x7E) || ((BYTE)(b) >= 0x80 && (BYTE)(b) <= 0xFE))) return FR_INVALID_NAME;	 
N		}
N		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
N		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
N#endif
N		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
N		lfn[di++] = w;					/* Store the Unicode character */
N	}
N	*path = &p[si];						/* Return pointer to the next segment */
N	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
X	cf = (w < ' ') ? 0x04 : 0;		 
N#if _FS_RPATH != 0
X#if 0 != 0
S	if ((di == 1 && lfn[di - 1] == '.') ||
S		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
S		lfn[di] = 0;
S		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
S			dp->fn[i] = (i < di) ? '.' : ' ';
S		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
S		return FR_OK;
S	}
N#endif
N	while (di) {						/* Snip off trailing spaces and dots if exist */
N		w = lfn[di - 1];
N		if (w != ' ' && w != '.') break;
N		di--;
N	}
N	lfn[di] = 0;						/* LFN is created */
N	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
N
N	/* Create SFN in directory form */
N	mem_set(dp->fn, ' ', 11);
N	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
N	if (si) cf |= NS_LOSS | NS_LFN;
X	if (si) cf |= 0x01 | 0x02;
N	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
N
N	i = b = 0; ni = 8;
N	for (;;) {
N		w = lfn[si++];					/* Get an LFN character */
N		if (!w) break;					/* Break on end of the LFN */
N		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
N			cf |= NS_LOSS | NS_LFN; continue;
X			cf |= 0x01 | 0x02; continue;
N		}
N
N		if (i >= ni || si == di) {		/* Extension or end of SFN */
N			if (ni == 11) {				/* Long extension */
N				cf |= NS_LOSS | NS_LFN; break;
X				cf |= 0x01 | 0x02; break;
N			}
N			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
X			if (si != di) cf |= 0x01 | 0x02;	 
N			if (si > di) break;			/* No extension */
N			si = di; i = 8; ni = 11;	/* Enter extension section */
N			b <<= 2; continue;
N		}
N
N		if (w >= 0x80) {				/* Non ASCII character */
N#ifdef _EXCVT
S			w = ff_convert(w, 0);		/* Unicode -> OEM code */
S			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
N#else
N			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
N#endif
N			cf |= NS_LFN;				/* Force create LFN entry */
X			cf |= 0x02;				 
N		}
N
N		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
X		if (0x81 && w >= 0x100) {		 
N			if (i >= ni - 1) {
N				cf |= NS_LOSS | NS_LFN; i = ni; continue;
X				cf |= 0x01 | 0x02; i = ni; continue;
N			}
N			dp->fn[i++] = (BYTE)(w >> 8);
N		} else {						/* SBC */
N			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
N				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
X				w = '_'; cf |= 0x01 | 0x02; 
N			} else {
N				if (IsUpper(w)) {		/* ASCII large capital */
X				if ((((w)>= 'A')&&((w)<= 'Z'))) {		 
N					b |= 2;
N				} else {
N					if (IsLower(w)) {	/* ASCII small capital */
X					if ((((w)>= 'a')&&((w)<= 'z'))) {	 
N						b |= 1; w -= 0x20;
N					}
N				}
N			}
N		}
N		dp->fn[i++] = (BYTE)w;
N	}
N
N	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
X	if (dp->fn[0] == 0xE5) dp->fn[0] = 0x05;	 
N
N	if (ni == 8) b <<= 2;
N	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
X	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= 0x02;	 
N	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
X	if (!(cf & 0x02)) {						 
N		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
X		if ((b & 0x03) == 0x01) cf |= 0x10;	 
N		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
X		if ((b & 0x0C) == 0x04) cf |= 0x08;	 
N	}
N
N	dp->fn[NSFLAG] = cf;	/* SFN is created */
X	dp->fn[11] = cf;	 
N
N	return FR_OK;
N
N
N#else	/* _USE_LFN != 0 : Non-LFN configuration */
S	BYTE c, d, *sfn;
S	UINT ni, si, i;
S	const char *p;
S
S	/* Create file name in directory form */
S	p = *path; sfn = dp->fn;
S	mem_set(sfn, ' ', 11);
S	si = i = 0; ni = 8;
S#if _FS_RPATH != 0
S	if (p[si] == '.') { /* Is this a dot entry? */
S		for (;;) {
S			c = (BYTE)p[si++];
S			if (c != '.' || si >= 3) break;
S			sfn[i++] = c;
S		}
S		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
S		*path = p + si;								/* Return pointer to the next segment */
S		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
S		return FR_OK;
S	}
S#endif
S	for (;;) {
S		c = (BYTE)p[si++];
S		if (c <= ' ') break; 			/* Break if end of the path name */
S		if (c == '/' || c == '\\') {	/* Break if a separator is found */
S			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
S			break;
S		}
S		if (c == '.' || i >= ni) {		/* End of body or over size? */
S			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
S			i = 8; ni = 11;				/* Goto extension */
S			continue;
S		}
S		if (c >= 0x80) {				/* Extended character? */
S#ifdef _EXCVT
S			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
S#else
S#if !_DF1S
S			return FR_INVALID_NAME;		/* Reject extended characters (ASCII only cfg) */
S#endif
S#endif
S		}
S		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
S			d = (BYTE)p[si++];			/* Get 2nd byte */
S			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
S			sfn[i++] = c;
S			sfn[i++] = d;
S		} else {						/* SBC */
S			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
S			if (IsLower(c)) c -= 0x20;	/* To upper */
S			sfn[i++] = c;
S		}
S	}
S	*path = p + si;						/* Return pointer to the next segment */
S	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
S
S	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
S	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
S
S	return FR_OK;
N#endif /* _USE_LFN != 0 */
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Follow a file path                                                    */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
N	DIR* dp,			/* Directory object to return last directory and found object */
N	const TCHAR* path	/* Full-path string to find a file or directory */
N)
N{
N	FRESULT res;
N	BYTE ns;
N	_FDID *obj = &dp->obj;
N	FATFS *fs = obj->fs;
N
N
N#if _FS_RPATH != 0
X#if 0 != 0
S	if (*path != '/' && *path != '\\') {	/* Without heading separator */
S		obj->sclust = fs->cdir;				/* Start from the current directory */
S	} else
N#endif
N	{										/* With heading separator */
N		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
N		obj->sclust = 0;					/* Start from the root directory */
N	}
N#if _FS_EXFAT && _FS_RPATH != 0
X#if 0 && 0 != 0
S	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
S		DIR dj;
S
S		obj->c_scl = fs->cdc_scl;
S		obj->c_size = fs->cdc_size;
S		obj->c_ofs = fs->cdc_ofs;
S		res = load_obj_dir(&dj, obj);
S		if (res != FR_OK) return res;
S		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
S		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
S	}
N#endif
N
N	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
N		dp->fn[NSFLAG] = NS_NONAME;
X		dp->fn[11] = 0x80;
N		res = dir_sdi(dp, 0);
N
N	} else {								/* Follow path */
N		for (;;) {
N			res = create_name(dp, &path);	/* Get a segment name of the path */
N			if (res != FR_OK) break;
N			res = dir_find(dp);				/* Find an object with the segment name */
N			ns = dp->fn[NSFLAG];
X			ns = dp->fn[11];
N			if (res != FR_OK) {				/* Failed to find the object */
N				if (res == FR_NO_FILE) {	/* Object is not found */
N					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
X					if (0 && (ns & 0x20)) {	 
N						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
X						if (!(ns & 0x04)) continue;	 
N						dp->fn[NSFLAG] = NS_NONAME;
X						dp->fn[11] = 0x80;
N						res = FR_OK;
N					} else {							/* Could not find the object */
N						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
X						if (!(ns & 0x04)) res = FR_NO_PATH;	 
N					}
N				}
N				break;
N			}
N			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
X			if (ns & 0x04) break;			 
N			/* Get into the sub-directory */
N			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
X			if (!(obj->attr & 0x10)) {		 
N				res = FR_NO_PATH; break;
N			}
N#if _FS_EXFAT
X#if 0
S			if (fs->fs_type == FS_EXFAT) {
S				obj->c_scl = obj->sclust;		/* Save containing directory information for next dir */
S				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
S				obj->c_ofs = dp->blk_ofs;
S				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
S				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
S				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
S			} else
N#endif
N			{
N				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
X				obj->sclust = ld_clust(fs, fs->win + dp->dptr % ((UINT)512));	 
N			}
N		}
N	}
N
N	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Get logical drive number from path name                               */
N/*-----------------------------------------------------------------------*/
N
Nstatic
Nint get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
N	const TCHAR** path	/* Pointer to pointer to the path name */
N)
N{
N	const TCHAR *tp, *tt;
N	UINT i;
N	int vol = -1;
N#if _STR_VOLUME_ID		/* Find string drive id */
X#if 0		 
S	static const char* const str[] = {_VOLUME_STRS};
S	const char *sp;
S	char c;
S	TCHAR tc;
N#endif
N
N
N	if (*path) {	/* If the pointer is not a null */
N		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
X		for (tt = *path; (UINT)*tt >= (1 ? ' ' : '!') && *tt != ':'; tt++) ;	 
N		if (*tt == ':') {	/* If a ':' is exist in the path name */
N			tp = *path;
N			i = *tp++ - '0'; 
N			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
N				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
X				if (i < 1) {	 
N					vol = (int)i;
N					*path = ++tt;
N				}
N			}
N#if _STR_VOLUME_ID
X#if 0
S			 else {	/* No numeric drive number, find string drive id */
S				i = 0; tt++;
S				do {
S					sp = str[i]; tp = *path;
S					do {	/* Compare a string drive id with path name */
S						c = *sp++; tc = *tp++;
S						if (IsLower(tc)) tc -= 0x20;
S					} while (c && (TCHAR)c == tc);
S				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
S				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
S					vol = (int)i;
S					*path = tt;
S				}
S			}
N#endif
N			return vol;
N		}
N#if _FS_RPATH != 0 && _VOLUMES >= 2
X#if 0 != 0 && 1 >= 2
S		vol = CurrVol;	/* Current drive */
N#else
N		vol = 0;		/* Drive 0 */
N#endif
N	}
N	return vol;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Load a sector and check if it is an FAT boot sector                   */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NBYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
N	FATFS* fs,	/* File system object */
N	DWORD sect	/* Sector# (lba) to check if it is an FAT-VBR or not */
N)
N{
N	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
N	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
N
N	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
X	if (ld_word(fs->win + 510) != 0xAA55) return 3;	 
N
N	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
X	if (fs->win[0] == 0xE9 || (fs->win[0] == 0xEB && fs->win[0 + 2] == 0x90)) {
N		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
X		if ((ld_dword(fs->win + 54) & 0xFFFFFF) == 0x544146) return 0;	 
N		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
X		if (ld_dword(fs->win + 82) == 0x33544146) return 0;			 
N	}
N#if _FS_EXFAT
X#if 0
S	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
N#endif
N	return 2;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Find logical drive and check if the volume is mounted                 */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
N	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
N	FATFS** rfs,		/* Pointer to pointer to the found file system object */
N	BYTE mode			/* !=0: Check write protection for write access */
N)
N{
N	BYTE fmt, *pt;
N	int vol;
N	DSTATUS stat;
N	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
N	WORD nrsv;
N	FATFS *fs;
N	UINT i;
N
N
N	/* Get logical drive number */
N	*rfs = 0;
N	vol = get_ldnumber(path);
N	if (vol < 0) return FR_INVALID_DRIVE;
N
N	/* Check if the file system object is valid or not */
N	fs = FatFs[vol];					/* Get pointer to the file system object */
N	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
N
N	ENTER_FF(fs);						/* Lock the volume */
X	;						 
N	*rfs = fs;							/* Return pointer to the file system object */
N
N	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
X	mode &= (BYTE)~0x01;				 
N	if (fs->fs_type) {					/* If the volume has been mounted */
N		stat = disk_status(fs->drv);
N		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
X		if (!(stat & 0x01)) {		 
N			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
X			if (!0 && mode && (stat & 0x04)) {	 
N				return FR_WRITE_PROTECTED;
N			}
N			return FR_OK;				/* The file system object is valid */
N		}
N	}
N
N	/* The file system object is not valid. */
N	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
N
N	fs->fs_type = 0;					/* Clear the file system object */
N	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
X	fs->drv = (BYTE)(vol);				 
N	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
N	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
X	if (stat & 0x01) { 			 
N		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
N	}
N	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
X	if (!0 && mode && (stat & 0x04)) {  
N		return FR_WRITE_PROTECTED;
N	}
N#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
X#if 512 != 512						 
S	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
S	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
N#endif
N	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
N	bsect = 0;
N	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
N	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
X	if (fmt == 2 || (fmt < 2 && 0 != 0)) {	 
N		for (i = 0; i < 4; i++) {			/* Get partition offset */
N			pt = fs->win + (MBR_Table + i * SZ_PTE);
X			pt = fs->win + (446 + i * 16);
N			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
X			br[i] = pt[4] ? ld_dword(pt + 8) : 0;
N		}
N		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
X		i = 0;						 
N		if (i) i--;
N		do {								/* Find an FAT volume */
N			bsect = br[i];
N			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
N		} while (!LD2PT(vol) && fmt >= 2 && ++i < 4);
X		} while (!0 && fmt >= 2 && ++i < 4);
N	}
N	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
N	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
N
N	/* An FAT volume is found. Following code initializes the file system object */
N
N#if _FS_EXFAT
X#if 0
S	if (fmt == 1) {
S		QWORD maxlba;
S
S		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
S		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
S
S		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
S
S		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs))	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
S			return FR_NO_FILESYSTEM;
S
S		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
S		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
S
S		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
S
S		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
S		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
S
S		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
S		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
S
S		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
S		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
S		fs->n_fatent = nclst + 2;
S
S		/* Boundaries and Limits */
S		fs->volbase = bsect;
S		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
S		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
S		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
S		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
S
S		/* Check if bitmap location is in assumption (at the first cluster) */
S		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
S		for (i = 0; i < SS(fs); i += SZDIRE) {
S			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
S		}
S		if (i == SS(fs)) return FR_NO_FILESYSTEM;
S#if !_FS_READONLY
S		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
S#endif
S		fmt = FS_EXFAT;			/* FAT sub-type */
S	} else
N#endif	/* _FS_EXFAT */
N	{
N		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
X		if (ld_word(fs->win + 11) != ((UINT)512)) return FR_NO_FILESYSTEM;	 
N
N		fasize = ld_word(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
X		fasize = ld_word(fs->win + 22);			 
N		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
X		if (fasize == 0) fasize = ld_dword(fs->win + 36);
N		fs->fsize = fasize;
N
N		fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FATs */
X		fs->n_fats = fs->win[16];					 
N		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
N		fasize *= fs->n_fats;								/* Number of sectors for FAT area */
N
N		fs->csize = fs->win[BPB_SecPerClus];				/* Cluster size */
X		fs->csize = fs->win[13];				 
N		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
N
N		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
X		fs->n_rootdir = ld_word(fs->win + 17);	 
N		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
X		if (fs->n_rootdir % (((UINT)512) / 32)) return FR_NO_FILESYSTEM;	 
N
N		tsect = ld_word(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
X		tsect = ld_word(fs->win + 19);			 
N		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
X		if (tsect == 0) tsect = ld_dword(fs->win + 32);
N
N		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
X		nrsv = ld_word(fs->win + 14);			 
N		if (nrsv == 0) return FR_NO_FILESYSTEM;				/* (Must not be 0) */
N
N		/* Determine the FAT sub type */
N		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
X		sysect = nrsv + fasize + fs->n_rootdir / (((UINT)512) / 32);	 
N		if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
N		nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
N		if (nclst == 0) return FR_NO_FILESYSTEM;			/* (Invalid volume size) */
N		fmt = FS_FAT32;
X		fmt = 3;
N		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
X		if (nclst <= 0xFFF5) fmt = 2;
N		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
X		if (nclst <= 0xFF5) fmt = 1;
N
N		/* Boundaries and Limits */
N		fs->n_fatent = nclst + 2;							/* Number of FAT entries */
N		fs->volbase = bsect;								/* Volume start sector */
N		fs->fatbase = bsect + nrsv; 						/* FAT start sector */
N		fs->database = bsect + sysect;						/* Data start sector */
N		if (fmt == FS_FAT32) {
X		if (fmt == 3) {
N			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
X			if (ld_word(fs->win + 42) != 0) return FR_NO_FILESYSTEM;	 
N			if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
N			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
X			fs->dirbase = ld_dword(fs->win + 44);	 
N			szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
N		} else {
N			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
N			fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
N			szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
X			szbfat = (fmt == 2) ?					 
N				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
N		}
N		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
X		if (fs->fsize < (szbfat + (((UINT)512) - 1)) / ((UINT)512)) return FR_NO_FILESYSTEM;	 
N
N#if !_FS_READONLY
X#if !0
N		/* Get FSINFO if available */
N		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
N		fs->fsi_flag = 0x80;
N#if (_FS_NOFSINFO & 3) != 3
X#if (0 & 3) != 3
N		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
X		if (fmt == 3				 
N			&& ld_word(fs->win + BPB_FSInfo32) == 1
X			&& ld_word(fs->win + 48) == 1
N			&& move_window(fs, bsect + 1) == FR_OK)
N		{
N			fs->fsi_flag = 0;
N			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
X			if (ld_word(fs->win + 510) == 0xAA55	 
N				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
X				&& ld_dword(fs->win + 0) == 0x41615252
N				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
X				&& ld_dword(fs->win + 484) == 0x61417272)
N			{
N#if (_FS_NOFSINFO & 1) == 0
X#if (0 & 1) == 0
N				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
X				fs->free_clst = ld_dword(fs->win + 488);
N#endif
N#if (_FS_NOFSINFO & 2) == 0
X#if (0 & 2) == 0
N				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
X				fs->last_clst = ld_dword(fs->win + 492);
N#endif
N			}
N		}
N#endif	/* (_FS_NOFSINFO & 3) != 3 */
N#endif	/* !_FS_READONLY */
N	}
N
N	fs->fs_type = fmt;	/* FAT sub-type */
N	fs->id = ++Fsid;	/* File system mount ID */
N#if _USE_LFN == 1
X#if 1 == 1
N	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
N#if _FS_EXFAT
X#if 0
S	fs->dirbuf = DirBuf;	/* Static directory block working buuffer */
N#endif
N#endif
N#if _FS_RPATH != 0
X#if 0 != 0
S	fs->cdir = 0;		/* Initialize current directory */
N#endif
N#if _FS_LOCK != 0		/* Clear file lock semaphores */
X#if 0 != 0		 
S	clear_lock(fs);
N#endif
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Check if the file/directory object is valid or not                    */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
N	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
N	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
N)
N{
N	FRESULT res;
N
N
N	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
X	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & 0x01)) {
N		*fs = 0;				/* The object is invalid */
N		res = FR_INVALID_OBJECT;
N	} else {
N		*fs = obj->fs;			/* Owner file sytem object */
N		ENTER_FF(obj->fs);		/* Lock file system */
X		;		 
N		res = FR_OK;
N	}
N	return res;
N}
N
N
N
N
N/*---------------------------------------------------------------------------
N
N   Public Functions (FatFs API)
N
N----------------------------------------------------------------------------*/
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Mount/Unmount a Logical Drive                                         */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_mount (
N	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
N	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
N	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
N)
N{
N	FATFS *cfs;
N	int vol;
N	FRESULT res;
N	const TCHAR *rp = path;
N
N
N	/* Get logical drive number */
N	vol = get_ldnumber(&rp);
N	if (vol < 0) return FR_INVALID_DRIVE;
N	cfs = FatFs[vol];					/* Pointer to fs object */
N
N	if (cfs) {
N#if _FS_LOCK != 0
X#if 0 != 0
S		clear_lock(cfs);
N#endif
N#if _FS_REENTRANT						/* Discard sync object of the current volume */
X#if 0						 
S		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
N#endif
N		cfs->fs_type = 0;				/* Clear old fs object */
N	}
N
N	if (fs) {
N		fs->fs_type = 0;				/* Clear new fs object */
N#if _FS_REENTRANT						/* Create sync object for the new volume */
X#if 0						 
S		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
N#endif
N	}
N	FatFs[vol] = fs;					/* Register new fs object */
N
N	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
N
N	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Open or Create a File                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_open (
N	FIL* fp,			/* Pointer to the blank file object */
N	const TCHAR* path,	/* Pointer to the file name */
N	BYTE mode			/* Access mode and file open mode flags */
N)
N{
N	FRESULT res;
N	DIR dj;
N	FATFS *fs;
N#if !_FS_READONLY
X#if !0
N	DWORD dw, cl, bcs, clst, sc;
N	FSIZE_t ofs;
N#endif
N	DEF_NAMBUF
X	
N
N
N	if (!fp) return FR_INVALID_OBJECT;
N
N	/* Get logical drive */
N	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
X	mode &= 0 ? 0x01 : 0x01 | 0x02 | 0x08 | 0x04 | 0x10 | 0x30 | 0x20;
N	res = find_volume(&path, &fs, mode);
N	if (res == FR_OK) {
N		dj.obj.fs = fs;
N		INIT_NAMBUF(fs);
X		;
N		res = follow_path(&dj, path);	/* Follow the file path */
N#if !_FS_READONLY	/* R/W configuration */
X#if !0	 
N		if (res == FR_OK) {
N			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
X			if (dj.fn[11] & 0x80) {	 
N				res = FR_INVALID_NAME;
N			}
N#if _FS_LOCK != 0
X#if 0 != 0
S			else {
S				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
S			}
N#endif
N		}
N		/* Create or Open a file */
N		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
X		if (mode & (0x08 | 0x10 | 0x04)) {
N			if (res != FR_OK) {					/* No file, create new */
N				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
N#if _FS_LOCK != 0
X#if 0 != 0
S					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
N#else
N					res = dir_register(&dj);
N#endif
N				mode |= FA_CREATE_ALWAYS;		/* File is created */
X				mode |= 0x08;		 
N			}
N			else {								/* Any object is already existing */
N				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
X				if (dj.obj.attr & (0x01 | 0x10)) {	 
N					res = FR_DENIED;
N				} else {
N					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
X					if (mode & 0x04) res = FR_EXIST;	 
N				}
N			}
N			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
X			if (res == FR_OK && (mode & 0x08)) {	 
N				dw = GET_FATTIME();
X				dw = get_fattime();
N#if _FS_EXFAT
X#if 0
S				if (fs->fs_type == FS_EXFAT) {
S					/* Get current allocation info */
S					fp->obj.fs = fs;
S					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
S					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
S					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
S					/* Initialize directory entry block */
S					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
S					fs->dirbuf[XDIR_CrtTime10] = 0;
S					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
S					fs->dirbuf[XDIR_ModTime10] = 0;
S					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
S					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
S					st_qword(fs->dirbuf + XDIR_FileSize, 0);
S					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
S					fs->dirbuf[XDIR_GenFlags] = 1;
S					res = store_xdir(&dj);
S					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
S						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
S						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
S					}
S				} else
N#endif
N				{
N					/* Clean directory info */
N					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
X					st_dword(dj.dir + 14, dw);	 
N					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
X					st_dword(dj.dir + 22, dw);	 
N					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
X					dj.dir[11] = 0x20;			 
N					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
N					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
N					st_dword(dj.dir + DIR_FileSize, 0);
X					st_dword(dj.dir + 28, 0);
N					fs->wflag = 1;
N
N					if (cl) {							/* Remove the cluster chain if exist */
N						dw = fs->winsect;
N						res = remove_chain(&dj.obj, cl, 0);
N						if (res == FR_OK) {
N							res = move_window(fs, dw);
N							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
N						}
N					}
N				}
N			}
N		}
N		else {	/* Open an existing file */
N			if (res == FR_OK) {					/* Following succeeded */
N				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
X				if (dj.obj.attr & 0x10) {		 
N					res = FR_NO_FILE;
N				} else {
N					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
X					if ((mode & 0x02) && (dj.obj.attr & 0x01)) {  
N						res = FR_DENIED;
N					}
N				}
N			}
N		}
N		if (res == FR_OK) {
N			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
X			if (mode & 0x08)		 
N				mode |= FA_MODIFIED;
X				mode |= 0x40;
N			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
N			fp->dir_ptr = dj.dir;
N#if _FS_LOCK != 0
X#if 0 != 0
S			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
S			if (!fp->obj.lockid) res = FR_INT_ERR;
N#endif
N		}
N#else		/* R/O configuration */
S		if (res == FR_OK) {
S			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
S				res = FR_INVALID_NAME;
S			} else {
S				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
S					res = FR_NO_FILE;
S				}
S			}
S		}
N#endif
N
N		if (res == FR_OK) {
N#if _FS_EXFAT
X#if 0
S			if (fs->fs_type == FS_EXFAT) {
S				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Get allocation info */
S				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
S				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
S				fp->obj.c_scl = dj.obj.sclust;
S				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
S				fp->obj.c_ofs = dj.blk_ofs;
S			} else
N#endif
N			{
N				fp->obj.sclust = ld_clust(fs, dj.dir);				/* Get allocation info */
N				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
X				fp->obj.objsize = ld_dword(dj.dir + 28);
N			}
N#if _USE_FASTSEEK
X#if 0
S			fp->cltbl = 0;			/* Disable fast seek mode */
N#endif
N			fp->obj.fs = fs;	 	/* Validate the file object */
N			fp->obj.id = fs->id;
N			fp->flag = mode;		/* Set file access mode */
N			fp->err = 0;			/* Clear error flag */
N			fp->sect = 0;			/* Invalidate current data sector */
N			fp->fptr = 0;			/* Set file pointer top of the file */
N#if !_FS_READONLY
X#if !0
N#if !_FS_TINY
X#if !0
N			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
X			mem_set(fp->buf, 0, 512);	 
N#endif
N			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
X			if ((mode & 0x20) && fp->obj.objsize > 0) {	 
N				fp->fptr = fp->obj.objsize;			/* Offset to seek */
N				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
X				bcs = (DWORD)fs->csize * ((UINT)512);	 
N				clst = fp->obj.sclust;				/* Follow the cluster chain */
N				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
N					clst = get_fat(&fp->obj, clst);
N					if (clst <= 1) res = FR_INT_ERR;
N					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
N				}
N				fp->clust = clst;
N				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
X				if (res == FR_OK && ofs % ((UINT)512)) {	 
N					if ((sc = clust2sect(fs, clst)) == 0) {
N						res = FR_INT_ERR;
N					} else {
N						fp->sect = sc + (DWORD)(ofs / SS(fs));
X						fp->sect = sc + (DWORD)(ofs / ((UINT)512));
N#if !_FS_TINY
X#if !0
N						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
N#endif
N					}
N				}
N			}
N#endif
N		}
N
N		FREE_NAMBUF();
X		;
N	}
N
N	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read File                                                             */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_read (
N	FIL* fp, 	/* Pointer to the file object */
N	void* buff,	/* Pointer to data buffer */
N	UINT btr,	/* Number of bytes to read */
N	UINT* br	/* Pointer to number of bytes read */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DWORD clst, sect;
N	FSIZE_t remain;
N	UINT rcnt, cc, csect;
N	BYTE *rbuff = (BYTE*)buff;
N
N
N	*br = 0;	/* Clear read byte counter */
N	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
N	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
X	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;	 
N	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
X	if (!(fp->flag & 0x01)) return FR_DENIED;  
N	remain = fp->obj.objsize - fp->fptr;
N	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
N
N	for ( ;  btr;								/* Repeat until all data read */
N		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
N		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
X		if (fp->fptr % ((UINT)512) == 0) {			 
N			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
X			csect = (UINT)(fp->fptr / ((UINT)512) & (fs->csize - 1));	 
N			if (csect == 0) {					/* On the cluster boundary? */
N				if (fp->fptr == 0) {			/* On the top of the file? */
N					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
N				} else {						/* Middle or end of the file */
N#if _USE_FASTSEEK
X#if 0
S					if (fp->cltbl) {
S						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
S					} else
N#endif
N					{
N						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
N					}
N				}
N				if (clst < 2) ABORT(fs, FR_INT_ERR);
X				if (clst < 2) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N				fp->clust = clst;				/* Update current cluster */
N			}
N			sect = clust2sect(fs, fp->clust);	/* Get current sector */
N			if (!sect) ABORT(fs, FR_INT_ERR);
X			if (!sect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N			sect += csect;
N			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
X			cc = btr / ((UINT)512);					 
N			if (cc) {							/* Read maximum contiguous sectors directly */
N				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
N					cc = fs->csize - csect;
N				}
N				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
X				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
X#if !0 && 0 <= 2			 
N#if _FS_TINY
X#if 0
S				if (fs->wflag && fs->winsect - sect < cc) {
S					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
S				}
N#else
N				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
X				if ((fp->flag & 0x80) && fp->sect - sect < cc) {
N					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
X					mem_cpy(rbuff + ((fp->sect - sect) * ((UINT)512)), fp->buf, ((UINT)512));
N				}
N#endif
N#endif
N				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
X				rcnt = ((UINT)512) * cc;				 
N				continue;
N			}
N#if !_FS_TINY
X#if !0
N			if (fp->sect != sect) {			/* Load data sector if not in cache */
N#if !_FS_READONLY
X#if !0
N				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
X				if (fp->flag & 0x80) {		 
N					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
X					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N					fp->flag &= (BYTE)~FA_DIRTY;
X					fp->flag &= (BYTE)~0x80;
N				}
N#endif
N				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
X				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };	 
N			}
N#endif
N			fp->sect = sect;
N		}
N		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
X		rcnt = ((UINT)512) - (UINT)fp->fptr % ((UINT)512);	 
N		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
N#if _FS_TINY
X#if 0
S		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
S		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
N#else
N		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
X		mem_cpy(rbuff, fp->buf + fp->fptr % ((UINT)512), rcnt);	 
N#endif
N	}
N
N	LEAVE_FF(fs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Write File                                                            */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_write (
N	FIL* fp,			/* Pointer to the file object */
N	const void* buff,	/* Pointer to the data to be written */
N	UINT btw,			/* Number of bytes to write */
N	UINT* bw			/* Pointer to number of bytes written */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DWORD clst, sect;
N	UINT wcnt, cc, csect;
N	const BYTE *wbuff = (const BYTE*)buff;
N
N
N	*bw = 0;	/* Clear write byte counter */
N	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
N	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
X	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;	 
N	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
X	if (!(fp->flag & 0x02)) return FR_DENIED;	 
N
N	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
N	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
X	if ((!0 || fs->fs_type != 4) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
N		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
N	}
N
N	for ( ;  btw;							/* Repeat until all data written */
N		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
N		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
X		if (fp->fptr % ((UINT)512) == 0) {		 
N			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
X			csect = (UINT)(fp->fptr / ((UINT)512)) & (fs->csize - 1);	 
N			if (csect == 0) {				/* On the cluster boundary? */
N				if (fp->fptr == 0) {		/* On the top of the file? */
N					clst = fp->obj.sclust;	/* Follow from the origin */
N					if (clst == 0) {		/* If no cluster is allocated, */
N						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
N					}
N				} else {					/* On the middle or end of the file */
N#if _USE_FASTSEEK
X#if 0
S					if (fp->cltbl) {
S						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
S					} else
N#endif
N					{
N						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
N					}
N				}
N				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
N				if (clst == 1) ABORT(fs, FR_INT_ERR);
X				if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N				fp->clust = clst;			/* Update current cluster */
N				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
N			}
N#if _FS_TINY
X#if 0
S			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
N#else
N			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
X			if (fp->flag & 0x80) {		 
N				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
X				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N				fp->flag &= (BYTE)~FA_DIRTY;
X				fp->flag &= (BYTE)~0x80;
N			}
N#endif
N			sect = clust2sect(fs, fp->clust);	/* Get current sector */
N			if (!sect) ABORT(fs, FR_INT_ERR);
X			if (!sect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N			sect += csect;
N			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
X			cc = btw / ((UINT)512);				 
N			if (cc) {						/* Write maximum contiguous sectors directly */
N				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
N					cc = fs->csize - csect;
N				}
N				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
X				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N#if _FS_MINIMIZE <= 2
X#if 0 <= 2
N#if _FS_TINY
X#if 0
S				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
S					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
S					fs->wflag = 0;
S				}
N#else
N				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
N					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
X					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT)512)), ((UINT)512));
N					fp->flag &= (BYTE)~FA_DIRTY;
X					fp->flag &= (BYTE)~0x80;
N				}
N#endif
N#endif
N				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
X				wcnt = ((UINT)512) * cc;		 
N				continue;
N			}
N#if _FS_TINY
X#if 0
S			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
S				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
S				fs->winsect = sect;
S			}
N#else
N			if (fp->sect != sect && 		/* Fill sector cache with file data */
N				fp->fptr < fp->obj.objsize &&
N				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
N					ABORT(fs, FR_DISK_ERR);
X					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N			}
N#endif
N			fp->sect = sect;
N		}
N		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
X		wcnt = ((UINT)512) - (UINT)fp->fptr % ((UINT)512);	 
N		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
N#if _FS_TINY
X#if 0
S		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
S		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
S		fs->wflag = 1;
N#else
N		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
X		mem_cpy(fp->buf + fp->fptr % ((UINT)512), wbuff, wcnt);	 
N		fp->flag |= FA_DIRTY;
X		fp->flag |= 0x80;
N#endif
N	}
N
N	fp->flag |= FA_MODIFIED;				/* Set file change flag */
X	fp->flag |= 0x40;				 
N
N	LEAVE_FF(fs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Synchronize the File                                                  */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_sync (
N	FIL* fp		/* Pointer to the file object */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DWORD tm;
N	BYTE *dir;
N	DEF_NAMBUF
X	
N
N
N	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
N	if (res == FR_OK) {
N		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
X		if (fp->flag & 0x40) {	 
N#if !_FS_TINY
X#if !0
N			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
X			if (fp->flag & 0x80) {	 
N				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
X				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) return FR_DISK_ERR;
N				fp->flag &= (BYTE)~FA_DIRTY;
X				fp->flag &= (BYTE)~0x80;
N			}
N#endif
N			/* Update the directory entry */
N			tm = GET_FATTIME();				/* Modified time */
X			tm = get_fattime();				 
N#if _FS_EXFAT
X#if 0
S			if (fs->fs_type == FS_EXFAT) {
S				res = fill_fat_chain(&fp->obj);	/* Create FAT chain if needed */
S				if (res == FR_OK) {
S					DIR dj;
S
S					INIT_NAMBUF(fs);
S					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
S					if (res == FR_OK) {
S						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive bit */
S						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation info */
S						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
S						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
S						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
S						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
S						fs->dirbuf[XDIR_ModTime10] = 0;
S						st_dword(fs->dirbuf + XDIR_AccTime, 0);
S						res = store_xdir(&dj);	/* Restore it to the directory */
S						if (res == FR_OK) {
S							res = sync_fs(fs);
S							fp->flag &= (BYTE)~FA_MODIFIED;
S						}
S					}
S					FREE_NAMBUF();
S				}
S			} else
N#endif
N			{
N				res = move_window(fs, fp->dir_sect);
N				if (res == FR_OK) {
N					dir = fp->dir_ptr;
N					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
X					dir[11] |= 0x20;						 
N					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
N					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
X					st_dword(dir + 28, (DWORD)fp->obj.objsize);	 
N					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
X					st_dword(dir + 22, tm);				 
N					st_word(dir + DIR_LstAccDate, 0);
X					st_word(dir + 18, 0);
N					fs->wflag = 1;
N					res = sync_fs(fs);					/* Restore it to the directory */
N					fp->flag &= (BYTE)~FA_MODIFIED;
X					fp->flag &= (BYTE)~0x40;
N				}
N			}
N		}
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Close File                                                            */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_close (
N	FIL* fp		/* Pointer to the file object to be closed */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N
N#if !_FS_READONLY
X#if !0
N	res = f_sync(fp);					/* Flush cached data */
N	if (res == FR_OK)
N#endif
N	{
N		res = validate(&fp->obj, &fs);	/* Lock volume */
N		if (res == FR_OK) {
N#if _FS_LOCK != 0
X#if 0 != 0
S			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
S			if (res == FR_OK)
N#endif
N			{
N				fp->obj.fs = 0;			/* Invalidate file object */
N			}
N#if _FS_REENTRANT
X#if 0
S			unlock_fs(fs, FR_OK);		/* Unlock volume */
N#endif
N		}
N	}
N	return res;
N}
N
N
N
N
N#if _FS_RPATH >= 1
X#if 0 >= 1
S/*-----------------------------------------------------------------------*/
S/* Change Current Directory or Current Drive, Get Current Directory      */
S/*-----------------------------------------------------------------------*/
S
S#if _VOLUMES >= 2
SFRESULT f_chdrive (
S	const TCHAR* path		/* Drive number */
S)
S{
S	int vol;
S
S
S	/* Get logical drive number */
S	vol = get_ldnumber(&path);
S	if (vol < 0) return FR_INVALID_DRIVE;
S
S	CurrVol = (BYTE)vol;	/* Set it as current volume */
S
S	return FR_OK;
S}
S#endif
S
S
SFRESULT f_chdir (
S	const TCHAR* path	/* Pointer to the directory path */
S)
S{
S	FRESULT res;
S	DIR dj;
S	FATFS *fs;
S	DEF_NAMBUF
S
S	/* Get logical drive */
S	res = find_volume(&path, &fs, 0);
S	if (res == FR_OK) {
S		dj.obj.fs = fs;
S		INIT_NAMBUF(fs);
S		res = follow_path(&dj, path);		/* Follow the path */
S		if (res == FR_OK) {					/* Follow completed */
S			if (dj.fn[NSFLAG] & NS_NONAME) {
S				fs->cdir = dj.obj.sclust;	/* It is the start directory itself */
S#if _FS_EXFAT
S				if (fs->fs_type == FS_EXFAT) {
S					fs->cdc_scl = dj.obj.c_scl;
S					fs->cdc_size = dj.obj.c_size;
S					fs->cdc_ofs = dj.obj.c_ofs;
S				}
S#endif
S			} else {
S				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
S#if _FS_EXFAT
S					if (fs->fs_type == FS_EXFAT) {
S						fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
S						fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
S						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
S						fs->cdc_ofs = dj.blk_ofs;
S					} else
S#endif
S					{
S						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
S					}
S				} else {
S					res = FR_NO_PATH;		/* Reached but a file */
S				}
S			}
S		}
S		FREE_NAMBUF();
S		if (res == FR_NO_FILE) res = FR_NO_PATH;
S	}
S
S	LEAVE_FF(fs, res);
S}
S
S
S#if _FS_RPATH >= 2
SFRESULT f_getcwd (
S	TCHAR* buff,	/* Pointer to the directory path */
S	UINT len		/* Size of path */
S)
S{
S	FRESULT res;
S	DIR dj;
S	FATFS *fs;
S	UINT i, n;
S	DWORD ccl;
S	TCHAR *tp;
S	FILINFO fno;
S	DEF_NAMBUF
S
S
S	*buff = 0;
S	/* Get logical drive */
S	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
S	if (res == FR_OK) {
S		dj.obj.fs = fs;
S		INIT_NAMBUF(fs);
S		i = len;			/* Bottom of buffer (directory stack base) */
S		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
S			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
S			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
S				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
S				if (res != FR_OK) break;
S				res = move_window(fs, dj.sect);
S				if (res != FR_OK) break;
S				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
S				res = dir_sdi(&dj, 0);
S				if (res != FR_OK) break;
S				do {							/* Find the entry links to the child directory */
S					res = dir_read(&dj, 0);
S					if (res != FR_OK) break;
S					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
S					res = dir_next(&dj, 0);
S				} while (res == FR_OK);
S				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
S				if (res != FR_OK) break;
S				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
S				for (n = 0; fno.fname[n]; n++) ;
S				if (i < n + 3) {
S					res = FR_NOT_ENOUGH_CORE; break;
S				}
S				while (n) buff[--i] = fno.fname[--n];
S				buff[--i] = '/';
S			}
S		}
S		tp = buff;
S		if (res == FR_OK) {
S#if _VOLUMES >= 2
S			*tp++ = '0' + CurrVol;			/* Put drive number */
S			*tp++ = ':';
S#endif
S			if (i == len) {					/* Root-directory */
S				*tp++ = '/';
S			} else {						/* Sub-directroy */
S				do		/* Add stacked path str */
S					*tp++ = buff[i++];
S				while (i < len);
S			}
S		}
S		*tp = 0;
S		FREE_NAMBUF();
S	}
S
S	LEAVE_FF(fs, res);
S}
S
S#endif /* _FS_RPATH >= 2 */
N#endif /* _FS_RPATH >= 1 */
N
N
N
N#if _FS_MINIMIZE <= 2
X#if 0 <= 2
N/*-----------------------------------------------------------------------*/
N/* Seek File R/W Pointer                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_lseek (
N	FIL* fp,		/* Pointer to the file object */
N	FSIZE_t ofs		/* File pointer from top of file */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DWORD clst, bcs, nsect;
N	FSIZE_t ifptr;
N#if _USE_FASTSEEK
X#if 0
S	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
N#endif
N
N	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
N	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
X	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;	 
N#if _USE_FASTSEEK
X#if 0
S	if (fp->cltbl) {	/* Fast seek */
S		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
S			tbl = fp->cltbl;
S			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
S			cl = fp->obj.sclust;		/* Origin of the chain */
S			if (cl) {
S				do {
S					/* Get a fragment */
S					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
S					do {
S						pcl = cl; ncl++;
S						cl = get_fat(&fp->obj, cl);
S						if (cl <= 1) ABORT(fs, FR_INT_ERR);
S						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
S					} while (cl == pcl + 1);
S					if (ulen <= tlen) {		/* Store the length and top of the fragment */
S						*tbl++ = ncl; *tbl++ = tcl;
S					}
S				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
S			}
S			*fp->cltbl = ulen;	/* Number of items used */
S			if (ulen <= tlen) {
S				*tbl = 0;		/* Terminate table */
S			} else {
S				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
S			}
S		} else {						/* Fast seek */
S			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
S			fp->fptr = ofs;				/* Set file pointer */
S			if (ofs) {
S				fp->clust = clmt_clust(fp, ofs - 1);
S				dsc = clust2sect(fs, fp->clust);
S				if (!dsc) ABORT(fs, FR_INT_ERR);
S				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
S				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
S#if !_FS_TINY
S#if !_FS_READONLY
S					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
S						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
S						fp->flag &= (BYTE)~FA_DIRTY;
S					}
S#endif
S					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
S#endif
S					fp->sect = dsc;
S				}
S			}
S		}
S	} else
N#endif
N
N	/* Normal Seek */
N	{
N#if _FS_EXFAT
X#if 0
S		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
N#endif
N		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
X		if (ofs > fp->obj.objsize && (0 || !(fp->flag & 0x02))) {	 
N			ofs = fp->obj.objsize;
N		}
N		ifptr = fp->fptr;
N		fp->fptr = nsect = 0;
N		if (ofs) {
N			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
X			bcs = (DWORD)fs->csize * ((UINT)512);	 
N			if (ifptr > 0 &&
N				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
N				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
N				ofs -= fp->fptr;
N				clst = fp->clust;
N			} else {									/* When seek to back cluster, */
N				clst = fp->obj.sclust;					/* start from the first cluster */
N#if !_FS_READONLY
X#if !0
N				if (clst == 0) {						/* If no cluster chain, create a new chain */
N					clst = create_chain(&fp->obj, 0);
N					if (clst == 1) ABORT(fs, FR_INT_ERR);
X					if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
X					if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N					fp->obj.sclust = clst;
N				}
N#endif
N				fp->clust = clst;
N			}
N			if (clst != 0) {
N				while (ofs > bcs) {						/* Cluster following loop */
N					ofs -= bcs; fp->fptr += bcs;
N#if !_FS_READONLY
X#if !0
N					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
X					if (fp->flag & 0x02) {			 
N						if (_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
X						if (0 && fp->fptr > fp->obj.objsize) {	 
N							fp->obj.objsize = fp->fptr;
N							fp->flag |= FA_MODIFIED;
X							fp->flag |= 0x40;
N						}
N						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
N						if (clst == 0) {				/* Clip file size in case of disk full */
N							ofs = 0; break;
N						}
N					} else
N#endif
N					{
N						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
N					}
N					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
X					if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
X					if (clst <= 1 || clst >= fs->n_fatent) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N					fp->clust = clst;
N				}
N				fp->fptr += ofs;
N				if (ofs % SS(fs)) {
X				if (ofs % ((UINT)512)) {
N					nsect = clust2sect(fs, clst);	/* Current sector */
N					if (!nsect) ABORT(fs, FR_INT_ERR);
X					if (!nsect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
N					nsect += (DWORD)(ofs / SS(fs));
X					nsect += (DWORD)(ofs / ((UINT)512));
N				}
N			}
N		}
N		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
X		if (!0 && fp->fptr > fp->obj.objsize) {		 
N			fp->obj.objsize = fp->fptr;
N			fp->flag |= FA_MODIFIED;
X			fp->flag |= 0x40;
N		}
N		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
X		if (fp->fptr % ((UINT)512) && nsect != fp->sect) {	 
N#if !_FS_TINY
X#if !0
N#if !_FS_READONLY
X#if !0
N			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
X			if (fp->flag & 0x80) {			 
N				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
X				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
N				fp->flag &= (BYTE)~FA_DIRTY;
X				fp->flag &= (BYTE)~0x80;
N			}
N#endif
N			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
X			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };	 
N#endif
N			fp->sect = nsect;
N		}
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
N/*-----------------------------------------------------------------------*/
N/* Create a Directory Object                                             */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_opendir (
N	DIR* dp,			/* Pointer to directory object to create */
N	const TCHAR* path	/* Pointer to the directory path */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	_FDID *obj;
N	DEF_NAMBUF
X	
N
N
N	if (!dp) return FR_INVALID_OBJECT;
N
N	/* Get logical drive */
N	obj = &dp->obj;
N	res = find_volume(&path, &fs, 0);
N	if (res == FR_OK) {
N		obj->fs = fs;
N		INIT_NAMBUF(fs);
X		;
N		res = follow_path(dp, path);			/* Follow the path to the directory */
N		if (res == FR_OK) {						/* Follow completed */
N			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
X			if (!(dp->fn[11] & 0x80)) {	 
N				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
X				if (obj->attr & 0x10) {		 
N#if _FS_EXFAT
X#if 0
S					if (fs->fs_type == FS_EXFAT) {
S						obj->c_scl = obj->sclust;	/* Save containing directory inforamation */
S						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
S						obj->c_ofs = dp->blk_ofs;
S						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object location and status */
S						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
S						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
S					} else
N#endif
N					{
N						obj->sclust = ld_clust(fs, dp->dir);	/* Get object location */
N					}
N				} else {						/* This object is a file */
N					res = FR_NO_PATH;
N				}
N			}
N			if (res == FR_OK) {
N				obj->id = fs->id;
N				res = dir_sdi(dp, 0);			/* Rewind directory */
N#if _FS_LOCK != 0
X#if 0 != 0
S				if (res == FR_OK) {
S					if (obj->sclust) {
S						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
S						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
S					} else {
S						obj->lockid = 0;	/* Root directory need not to be locked */
S					}
S				}
N#endif
N			}
N		}
N		FREE_NAMBUF();
X		;
N		if (res == FR_NO_FILE) res = FR_NO_PATH;
N	}
N	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Close Directory                                                       */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_closedir (
N	DIR *dp		/* Pointer to the directory object to be closed */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N
N
N	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
N	if (res == FR_OK) {
N#if _FS_LOCK != 0
X#if 0 != 0
S		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
S			res = dec_lock(dp->obj.lockid);
S		}
S		if (res == FR_OK)
N#endif
N		{
N			dp->obj.fs = 0;			/* Invalidate directory object */
N		}
N#if _FS_REENTRANT
X#if 0
S		unlock_fs(fs, FR_OK);		/* Unlock volume */
N#endif
N	}
N	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read Directory Entries in Sequence                                    */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_readdir (
N	DIR* dp,			/* Pointer to the open directory object */
N	FILINFO* fno		/* Pointer to file information to return */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DEF_NAMBUF
X	
N
N
N	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
N	if (res == FR_OK) {
N		if (!fno) {
N			res = dir_sdi(dp, 0);			/* Rewind the directory object */
N		} else {
N			INIT_NAMBUF(fs);
X			;
N			res = dir_read(dp, 0);			/* Read an item */
N			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
N			if (res == FR_OK) {				/* A valid entry is found */
N				get_fileinfo(dp, fno);		/* Get the object information */
N				res = dir_next(dp, 0);		/* Increment index for next */
N				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
N			}
N			FREE_NAMBUF();
X			;
N		}
N	}
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N#if _USE_FIND
X#if 0
S/*-----------------------------------------------------------------------*/
S/* Find Next File                                                        */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_findnext (
S	DIR* dp,		/* Pointer to the open directory object */
S	FILINFO* fno	/* Pointer to the file information structure */
S)
S{
S	FRESULT res;
S
S
S	for (;;) {
S		res = f_readdir(dp, fno);		/* Get a directory item */
S		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
S		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
S#if _USE_LFN != 0 && _USE_FIND == 2
S		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
S#endif
S	}
S	return res;
S}
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Find First File                                                       */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_findfirst (
S	DIR* dp,				/* Pointer to the blank directory object */
S	FILINFO* fno,			/* Pointer to the file information structure */
S	const TCHAR* path,		/* Pointer to the directory to open */
S	const TCHAR* pattern	/* Pointer to the matching pattern */
S)
S{
S	FRESULT res;
S
S
S	dp->pat = pattern;		/* Save pointer to pattern string */
S	res = f_opendir(dp, path);		/* Open the target directory */
S	if (res == FR_OK) {
S		res = f_findnext(dp, fno);	/* Find the first item */
S	}
S	return res;
S}
S
N#endif	/* _USE_FIND */
N
N
N
N#if _FS_MINIMIZE == 0
X#if 0 == 0
N/*-----------------------------------------------------------------------*/
N/* Get File Status                                                       */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_stat (
N	const TCHAR* path,	/* Pointer to the file path */
N	FILINFO* fno		/* Pointer to file information to return */
N)
N{
N	FRESULT res;
N	DIR dj;
N	DEF_NAMBUF
X	
N
N
N	/* Get logical drive */
N	res = find_volume(&path, &dj.obj.fs, 0);
N	if (res == FR_OK) {
N		INIT_NAMBUF(dj.obj.fs);
X		;
N		res = follow_path(&dj, path);	/* Follow the file path */
N		if (res == FR_OK) {				/* Follow completed */
N			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
X			if (dj.fn[11] & 0x80) {	 
N				res = FR_INVALID_NAME;
N			} else {							/* Found an object */
N				if (fno) get_fileinfo(&dj, fno);
N			}
N		}
N		FREE_NAMBUF();
X		;
N	}
N
N	LEAVE_FF(dj.obj.fs, res);
X	return res;
N}
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Get Number of Free Clusters                                           */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_getfree (
N	const TCHAR* path,	/* Path name of the logical drive number */
N	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
N	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DWORD nfree, clst, sect, stat;
N	UINT i;
N	BYTE *p;
N	_FDID obj;
N
N
N	/* Get logical drive */
N	res = find_volume(&path, &fs, 0);
N	if (res == FR_OK) {
N		*fatfs = fs;				/* Return ptr to the fs object */
N		/* If free_clst is valid, return it without full cluster scan */
N		if (fs->free_clst <= fs->n_fatent - 2) {
N			*nclst = fs->free_clst;
N		} else {
N			/* Get number of free clusters */
N			nfree = 0;
N			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
X			if (fs->fs_type == 1) {	 
N				clst = 2; obj.fs = fs;
N				do {
N					stat = get_fat(&obj, clst);
N					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
N					if (stat == 1) { res = FR_INT_ERR; break; }
N					if (stat == 0) nfree++;
N				} while (++clst < fs->n_fatent);
N			} else {
N#if _FS_EXFAT
X#if 0
S				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan bitmap table */
S					BYTE bm;
S					UINT b;
S
S					clst = fs->n_fatent - 2;
S					sect = fs->database;
S					i = 0;
S					do {
S						if (i == 0 && (res = move_window(fs, sect++)) != FR_OK) break;
S						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
S							if (!(bm & 1)) nfree++;
S							bm >>= 1;
S						}
S						i = (i + 1) % SS(fs);
S					} while (clst);
S				} else
N#endif
N				{	/* FAT16/32: Sector alighed FAT entries */
N					clst = fs->n_fatent; sect = fs->fatbase;
N					i = 0; p = 0;
N					do {
N						if (i == 0) {
N							res = move_window(fs, sect++);
N							if (res != FR_OK) break;
N							p = fs->win;
N							i = SS(fs);
X							i = ((UINT)512);
N						}
N						if (fs->fs_type == FS_FAT16) {
X						if (fs->fs_type == 2) {
N							if (ld_word(p) == 0) nfree++;
N							p += 2; i -= 2;
N						} else {
N							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
N							p += 4; i -= 4;
N						}
N					} while (--clst);
N				}
N			}
N			*nclst = nfree;			/* Return the free clusters */
N			fs->free_clst = nfree;	/* Now free_clst is valid */
N			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
N		}
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Truncate File                                                         */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_truncate (
N	FIL* fp		/* Pointer to the file object */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DWORD ncl;
N
N
N	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
N	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
X	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;
N	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
X	if (!(fp->flag & 0x02)) return FR_DENIED;	 
N
N	if (fp->obj.objsize > fp->fptr) {
N		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
N			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
N			fp->obj.sclust = 0;
N		} else {				/* When truncate a part of the file, remove remaining clusters */
N			ncl = get_fat(&fp->obj, fp->clust);
N			res = FR_OK;
N			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
N			if (ncl == 1) res = FR_INT_ERR;
N			if (res == FR_OK && ncl < fs->n_fatent) {
N				res = remove_chain(&fp->obj, ncl, fp->clust);
N			}
N		}
N		fp->obj.objsize = fp->fptr;	/* Set file size to current R/W point */
N		fp->flag |= FA_MODIFIED;
X		fp->flag |= 0x40;
N#if !_FS_TINY
X#if !0
N		if (res == FR_OK && (fp->flag & FA_DIRTY)) {
X		if (res == FR_OK && (fp->flag & 0x80)) {
N			if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
N				res = FR_DISK_ERR;
N			} else {
N				fp->flag &= (BYTE)~FA_DIRTY;
X				fp->flag &= (BYTE)~0x80;
N			}
N		}
N#endif
N		if (res != FR_OK) ABORT(fs, res);
X		if (res != FR_OK) { fp->err = (BYTE)(res); return res; };
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Delete a File/Directory                                               */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_unlink (
N	const TCHAR* path		/* Pointer to the file or directory path */
N)
N{
N	FRESULT res;
N	DIR dj, sdj;
N	DWORD dclst = 0;
N	FATFS *fs;
N#if _FS_EXFAT
X#if 0
S	_FDID obj;
N#endif
N	DEF_NAMBUF
X	
N
N
N	/* Get logical drive */
N	res = find_volume(&path, &fs, FA_WRITE);
X	res = find_volume(&path, &fs, 0x02);
N	dj.obj.fs = fs;
N	if (res == FR_OK) {
N		INIT_NAMBUF(fs);
X		;
N		res = follow_path(&dj, path);		/* Follow the file path */
N		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
X		if (0 && res == FR_OK && (dj.fn[11] & 0x20)) {
N			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
N		}
N#if _FS_LOCK != 0
X#if 0 != 0
S		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
N#endif
N		if (res == FR_OK) {					/* The object is accessible */
N			if (dj.fn[NSFLAG] & NS_NONAME) {
X			if (dj.fn[11] & 0x80) {
N				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
N			} else {
N				if (dj.obj.attr & AM_RDO) {
X				if (dj.obj.attr & 0x01) {
N					res = FR_DENIED;		/* Cannot remove R/O object */
N				}
N			}
N			if (res == FR_OK) {
N#if _FS_EXFAT
X#if 0
S				obj.fs = fs;
S				if (fs->fs_type == FS_EXFAT) {
S					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
S					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
S					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
S				} else
N#endif
N				{
N					dclst = ld_clust(fs, dj.dir);
N				}
N				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory ? */
X				if (dj.obj.attr & 0x10) {			 
N#if _FS_RPATH != 0
X#if 0 != 0
S					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
S						res = FR_DENIED;
S					} else
N#endif
N					{
N						sdj.obj.fs = fs;						/* Open the sub-directory */
N						sdj.obj.sclust = dclst;
N#if _FS_EXFAT
X#if 0
S						if (fs->fs_type == FS_EXFAT) {
S							sdj.obj.objsize = obj.objsize;
S							sdj.obj.stat = obj.stat;
S						}
N#endif
N						res = dir_sdi(&sdj, 0);
N						if (res == FR_OK) {
N							res = dir_read(&sdj, 0);			/* Read an item */
N							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
N							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
N						}
N					}
N				}
N			}
N			if (res == FR_OK) {
N				res = dir_remove(&dj);			/* Remove the directory entry */
N				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
N#if _FS_EXFAT
X#if 0
S					res = remove_chain(&obj, dclst, 0);
N#else
N					res = remove_chain(&dj.obj, dclst, 0);
N#endif
N				}
N				if (res == FR_OK) res = sync_fs(fs);
N			}
N		}
N		FREE_NAMBUF();
X		;
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Create a Directory                                                    */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_mkdir (
N	const TCHAR* path		/* Pointer to the directory path */
N)
N{
N	FRESULT res;
N	DIR dj;
N	FATFS *fs;
N	BYTE *dir;
N	UINT n;
N	DWORD dsc, dcl, pcl, tm;
N	DEF_NAMBUF
X	
N
N
N	/* Get logical drive */
N	res = find_volume(&path, &fs, FA_WRITE);
X	res = find_volume(&path, &fs, 0x02);
N	dj.obj.fs = fs;
N	if (res == FR_OK) {
N		INIT_NAMBUF(fs);
X		;
N		res = follow_path(&dj, path);			/* Follow the file path */
N		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
N		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
X		if (0 && res == FR_NO_FILE && (dj.fn[11] & 0x20)) {
N			res = FR_INVALID_NAME;
N		}
N		if (res == FR_NO_FILE) {				/* Can create a new directory */
N			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
N			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
X			dj.obj.objsize = (DWORD)fs->csize * ((UINT)512);
N			res = FR_OK;
N			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
N			if (dcl == 1) res = FR_INT_ERR;
N			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
N			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
N			tm = GET_FATTIME();
X			tm = get_fattime();
N			if (res == FR_OK) {					/* Initialize the new directory table */
N				dsc = clust2sect(fs, dcl);
N				dir = fs->win;
N				mem_set(dir, 0, SS(fs));
X				mem_set(dir, 0, ((UINT)512));
N				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
X				if (!0 || fs->fs_type != 4) {
N					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
X					mem_set(dir + 0, ' ', 11);	 
N					dir[DIR_Name] = '.';
X					dir[0] = '.';
N					dir[DIR_Attr] = AM_DIR;
X					dir[11] = 0x10;
N					st_dword(dir + DIR_ModTime, tm);
X					st_dword(dir + 22, tm);
N					st_clust(fs, dir, dcl);
N					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
X					mem_cpy(dir + 32, dir, 32); 	 
N					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
X					dir[32 + 1] = '.'; pcl = dj.obj.sclust;
N					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
X					if (fs->fs_type == 3 && pcl == fs->dirbase) pcl = 0;
N					st_clust(fs, dir + SZDIRE, pcl);
X					st_clust(fs, dir + 32, pcl);
N				}
N				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
N					fs->winsect = dsc++;
N					fs->wflag = 1;
N					res = sync_window(fs);
N					if (res != FR_OK) break;
N					mem_set(dir, 0, SS(fs));
X					mem_set(dir, 0, ((UINT)512));
N				}
N			}
N			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
N			if (res == FR_OK) {
N#if _FS_EXFAT
X#if 0
S				if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
S					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
S					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
S					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
S					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
S					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag (contiguous) */
S					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
S					res = store_xdir(&dj);
S				} else
N#endif
N				{
N					dir = dj.dir;
N					st_dword(dir + DIR_ModTime, tm);	/* Created time */
X					st_dword(dir + 22, tm);	 
N					st_clust(fs, dir, dcl);				/* Table start cluster */
N					dir[DIR_Attr] = AM_DIR;				/* Attribute */
X					dir[11] = 0x10;				 
N					fs->wflag = 1;
N				}
N				if (res == FR_OK) res = sync_fs(fs);
N			} else {
N				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
N			}
N		}
N		FREE_NAMBUF();
X		;
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Rename a File/Directory                                               */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_rename (
N	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
N	const TCHAR* path_new	/* Pointer to the new name */
N)
N{
N	FRESULT res;
N	DIR djo, djn;
N	FATFS *fs;
N	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
X	BYTE buf[0 ? 32 * 2 : 24], *dir;
N	DWORD dw;
N	DEF_NAMBUF
X	
N
N
N	get_ldnumber(&path_new);						/* Ignore drive number of new name */
N	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
X	res = find_volume(&path_old, &fs, 0x02);	 
N	if (res == FR_OK) {
N		djo.obj.fs = fs;
N		INIT_NAMBUF(fs);
X		;
N		res = follow_path(&djo, path_old);		/* Check old object */
N		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
X		if (res == FR_OK && (djo.fn[11] & (0x20 | 0x80))) res = FR_INVALID_NAME;	 
N#if _FS_LOCK != 0
X#if 0 != 0
S		if (res == FR_OK) res = chk_lock(&djo, 2);
N#endif
N		if (res == FR_OK) {						/* Object to be renamed is found */
N#if _FS_EXFAT
X#if 0
S			if (fs->fs_type == FS_EXFAT) {	/* At exFAT */
S				BYTE nf, nn;
S				WORD nh;
S
S				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
S				mem_cpy(&djn, &djo, sizeof djo);
S				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
S				if (res == FR_OK) {						/* Is new name already in use by any other object? */
S					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
S				}
S				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
S					res = dir_register(&djn);			/* Register the new entry */
S					if (res == FR_OK) {
S						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
S						nh = ld_word(fs->dirbuf + XDIR_NameHash);
S						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);
S						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
S						st_word(fs->dirbuf + XDIR_NameHash, nh);
S/* Start of critical section where any interruption can cause a cross-link */
S						res = store_xdir(&djn);
S					}
S				}
S			} else
N#endif
N			{	/* At FAT12/FAT16/FAT32 */
N				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
X				mem_cpy(buf, djo.dir + 11, 21);	 
N				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
N				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
N				if (res == FR_OK) {						/* Is new name already in use by any other object? */
N					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
N				}
N				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
N					res = dir_register(&djn);			/* Register the new entry */
N					if (res == FR_OK) {
N						dir = djn.dir;					/* Copy information about object except name */
N						mem_cpy(dir + 13, buf + 2, 19);
N						dir[DIR_Attr] = buf[0] | AM_ARC;
X						dir[11] = buf[0] | 0x20;
N						fs->wflag = 1;
N						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
X						if ((dir[11] & 0x10) && djo.obj.sclust != djn.obj.sclust) {	 
N							dw = clust2sect(fs, ld_clust(fs, dir));
N							if (!dw) {
N								res = FR_INT_ERR;
N							} else {
N/* Start of critical section where any interruption can cause a cross-link */
N								res = move_window(fs, dw);
N								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
X								dir = fs->win + 32 * 1;	 
N								if (res == FR_OK && dir[1] == '.') {
N									st_clust(fs, dir, djn.obj.sclust);
N									fs->wflag = 1;
N								}
N							}
N						}
N					}
N				}
N			}
N			if (res == FR_OK) {
N				res = dir_remove(&djo);		/* Remove old entry */
N				if (res == FR_OK) {
N					res = sync_fs(fs);
N				}
N			}
N/* End of critical section */
N		}
N		FREE_NAMBUF();
X		;
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N#endif /* !_FS_READONLY */
N#endif /* _FS_MINIMIZE == 0 */
N#endif /* _FS_MINIMIZE <= 1 */
N#endif /* _FS_MINIMIZE <= 2 */
N
N
N
N#if _USE_CHMOD && !_FS_READONLY
X#if 0 && !0
S/*-----------------------------------------------------------------------*/
S/* Change Attribute                                                      */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_chmod (
S	const TCHAR* path,	/* Pointer to the file path */
S	BYTE attr,			/* Attribute bits */
S	BYTE mask			/* Attribute mask to change */
S)
S{
S	FRESULT res;
S	DIR dj;
S	FATFS *fs;
S	DEF_NAMBUF
S
S
S	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
S	dj.obj.fs = fs;
S	if (res == FR_OK) {
S		INIT_NAMBUF(fs);
S		res = follow_path(&dj, path);	/* Follow the file path */
S		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
S		if (res == FR_OK) {
S			mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
S#if _FS_EXFAT
S			if (fs->fs_type == FS_EXFAT) {
S				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
S				res = store_xdir(&dj);
S			} else
S#endif
S			{
S				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
S				fs->wflag = 1;
S			}
S			if (res == FR_OK) res = sync_fs(fs);
S		}
S		FREE_NAMBUF();
S	}
S
S	LEAVE_FF(fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Change Timestamp                                                      */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_utime (
S	const TCHAR* path,	/* Pointer to the file/directory name */
S	const FILINFO* fno	/* Pointer to the time stamp to be set */
S)
S{
S	FRESULT res;
S	DIR dj;
S	FATFS *fs;
S	DEF_NAMBUF
S
S
S	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
S	dj.obj.fs = fs;
S	if (res == FR_OK) {
S		INIT_NAMBUF(fs);
S		res = follow_path(&dj, path);	/* Follow the file path */
S		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
S		if (res == FR_OK) {
S#if _FS_EXFAT
S			if (fs->fs_type == FS_EXFAT) {
S				st_dword(fs->dirbuf + XDIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
S				res = store_xdir(&dj);
S			} else
S#endif
S			{
S				st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
S				fs->wflag = 1;
S			}
S			if (res == FR_OK) res = sync_fs(fs);
S		}
S		FREE_NAMBUF();
S	}
S
S	LEAVE_FF(fs, res);
S}
S
N#endif	/* _USE_CHMOD && !_FS_READONLY */
N
N
N
N#if _USE_LABEL
X#if 0
S/*-----------------------------------------------------------------------*/
S/* Get Volume Label                                                      */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_getlabel (
S	const TCHAR* path,	/* Path name of the logical drive number */
S	TCHAR* label,		/* Pointer to a buffer to return the volume label */
S	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
S)
S{
S	FRESULT res;
S	DIR dj;
S	FATFS *fs;
S	UINT si, di;
S#if _LFN_UNICODE || _FS_EXFAT
S	WCHAR w;
S#endif
S
S	/* Get logical drive */
S	res = find_volume(&path, &fs, 0);
S
S	/* Get volume label */
S	if (res == FR_OK && label) {
S		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
S		res = dir_sdi(&dj, 0);
S		if (res == FR_OK) {
S		 	res = dir_read(&dj, 1);			/* Find a volume label entry */
S		 	if (res == FR_OK) {
S#if _FS_EXFAT
S				if (fs->fs_type == FS_EXFAT) {
S					for (si = di = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
S						w = ld_word(dj.dir + XDIR_Label + si * 2);
S#if _LFN_UNICODE
S						label[di++] = w;
S#else
S						w = ff_convert(w, 0);	/* Unicode -> OEM */
S						if (w == 0) w = '?';	/* Replace wrong character */
S						if (_DF1S && w >= 0x100) label[di++] = (char)(w >> 8);
S						label[di++] = (char)w;
S#endif
S					}
S					label[di] = 0;
S				} else
S#endif
S				{
S					si = di = 0;		/* Extract volume label from AM_VOL entry with code comversion */
S					do {
S#if _LFN_UNICODE
S						w = (si < 11) ? dj.dir[si++] : ' ';
S						if (IsDBCS1(w) && si < 11 && IsDBCS2(dj.dir[si])) {
S							w = w << 8 | dj.dir[si++];
S						}
S						label[di++] = ff_convert(w, 1);	/* OEM -> Unicode */
S#else
S						label[di++] = dj.dir[si++];
S#endif
S					} while (di < 11);
S					do {				/* Truncate trailing spaces */
S						label[di] = 0;
S						if (di == 0) break;
S					} while (label[--di] == ' ');
S				}
S			}
S		}
S		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
S			label[0] = 0;
S			res = FR_OK;
S		}
S	}
S
S	/* Get volume serial number */
S	if (res == FR_OK && vsn) {
S		res = move_window(fs, fs->volbase);
S		if (res == FR_OK) {
S			switch (fs->fs_type) {
S			case FS_EXFAT: di = BPB_VolIDEx; break;
S			case FS_FAT32: di = BS_VolID32; break;
S			default:       di = BS_VolID;
S			}
S			*vsn = ld_dword(fs->win + di);
S		}
S	}
S
S	LEAVE_FF(fs, res);
S}
S
S
S
S#if !_FS_READONLY
S/*-----------------------------------------------------------------------*/
S/* Set Volume Label                                                      */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_setlabel (
S	const TCHAR* label	/* Pointer to the volume label to set */
S)
S{
S	FRESULT res;
S	DIR dj;
S	FATFS *fs;
S	BYTE dirvn[22];
S	UINT i, j, slen;
S	WCHAR w;
S	static const char badchr[] = "\"*+,.:;<=>\?[]|\x7F";
S
S
S	/* Get logical drive */
S	res = find_volume(&label, &fs, FA_WRITE);
S	if (res != FR_OK) LEAVE_FF(fs, res);
S	dj.obj.fs = fs;
S
S	/* Get length of given volume label */
S	for (slen = 0; (UINT)label[slen] >= ' '; slen++) ;	/* Get name length */
S
S#if _FS_EXFAT
S	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
S		for (i = j = 0; i < slen; ) {	/* Create volume label in directory form */
S			w = label[i++];
S#if !_LFN_UNICODE
S			if (IsDBCS1(w)) {
S				w = (i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
S			}
S			w = ff_convert(w, 1);
S#endif
S			if (w == 0 || chk_chr(badchr, w) || j == 22) {	/* Check validity check validity of the volume label */
S				LEAVE_FF(fs, FR_INVALID_NAME);
S			}
S			st_word(dirvn + j, w); j += 2;
S		}
S		slen = j;
S	} else
S#endif
S	{	/* On the FAT12/16/32 volume */
S		for ( ; slen && label[slen - 1] == ' '; slen--) ;	/* Remove trailing spaces */
S		if (slen) {		/* Is there a volume label to be set? */
S			dirvn[0] = 0; i = j = 0;	/* Create volume label in directory form */
S			do {
S#if _LFN_UNICODE
S				w = ff_convert(ff_wtoupper(label[i++]), 0);
S#else
S				w = (BYTE)label[i++];
S				if (IsDBCS1(w)) {
S					w = (j < 10 && i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
S				}
S#if _USE_LFN != 0
S				w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
S#else
S				if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
S#ifdef _EXCVT
S				if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
S#else
S				if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
S#endif
S#endif
S#endif
S				if (w == 0 || chk_chr(badchr, w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
S					LEAVE_FF(fs, FR_INVALID_NAME);
S				}
S				if (w >= 0x100) dirvn[j++] = (BYTE)(w >> 8);
S				dirvn[j++] = (BYTE)w;
S			} while (i < slen);
S			while (j < 11) dirvn[j++] = ' ';	/* Fill remaining name field */
S			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
S		}
S	}
S
S	/* Set volume label */
S	dj.obj.sclust = 0;		/* Open root directory */
S	res = dir_sdi(&dj, 0);
S	if (res == FR_OK) {
S		res = dir_read(&dj, 1);	/* Get volume label entry */
S		if (res == FR_OK) {
S			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
S				dj.dir[XDIR_NumLabel] = (BYTE)(slen / 2);	/* Change the volume label */
S				mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
S			} else {
S				if (slen) {
S					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
S				} else {
S					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
S				}
S			}
S			fs->wflag = 1;
S			res = sync_fs(fs);
S		} else {			/* No volume label entry is found or error */
S			if (res == FR_NO_FILE) {
S				res = FR_OK;
S				if (slen) {	/* Create a volume label entry */
S					res = dir_alloc(&dj, 1);	/* Allocate an entry */
S					if (res == FR_OK) {
S						mem_set(dj.dir, 0, SZDIRE);	/* Clear the entry */
S						if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
S							dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
S							dj.dir[XDIR_NumLabel] = (BYTE)(slen / 2);
S							mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
S						} else {
S							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
S							mem_cpy(dj.dir, dirvn, 11);
S						}
S						fs->wflag = 1;
S						res = sync_fs(fs);
S					}
S				}
S			}
S		}
S	}
S
S	LEAVE_FF(fs, res);
S}
S
S#endif /* !_FS_READONLY */
N#endif /* _USE_LABEL */
N
N
N
N#if _USE_EXPAND && !_FS_READONLY
X#if 0 && !0
S/*-----------------------------------------------------------------------*/
S/* Allocate a Contiguous Blocks to the File                              */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_expand (
S	FIL* fp,		/* Pointer to the file object */
S	FSIZE_t fsz,	/* File size to be expanded to */
S	BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
S)
S{
S	FRESULT res;
S	FATFS *fs;
S	DWORD n, clst, stcl, scl, ncl, tcl, lclst;
S
S
S	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
S	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
S	if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
S#if _FS_EXFAT
S	if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
S#endif
S	n = (DWORD)fs->csize * SS(fs);	/* Cluster size */
S	tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 0);	/* Number of clusters required */
S	stcl = fs->last_clst; lclst = 0;
S	if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
S
S#if _FS_EXFAT
S	if (fs->fs_type == FS_EXFAT) {
S		scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
S		if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
S		if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
S		if (res == FR_OK) {
S			if (opt) {
S				res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
S				lclst = scl + tcl - 1;
S			} else {
S				lclst = scl - 1;
S			}
S		}
S	} else
S#endif
S	{
S		scl = clst = stcl; ncl = 0;
S		for (;;) {	/* Find a contiguous cluster block */
S			n = get_fat(&fp->obj, clst);
S			if (++clst >= fs->n_fatent) clst = 2;
S			if (n == 1) { res = FR_INT_ERR; break; }
S			if (n == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
S			if (n == 0) {	/* Is it a free cluster? */
S				if (++ncl == tcl) break;	/* Break if a contiguous cluster block is found */
S			} else {
S				scl = clst; ncl = 0;		/* Not a free cluster */
S			}
S			if (clst == stcl) { res = FR_DENIED; break; }	/* No contiguous cluster? */
S		}
S		if (res == FR_OK) {
S			if (opt) {
S				for (clst = scl, n = tcl; n; clst++, n--) {	/* Create a cluster chain on the FAT */
S					res = put_fat(fs, clst, (n == 1) ? 0xFFFFFFFF : clst + 1);
S					if (res != FR_OK) break;
S					lclst = clst;
S				}
S			} else {
S				lclst = scl - 1;
S			}
S		}
S	}
S
S	if (res == FR_OK) {
S		fs->last_clst = lclst;		/* Set suggested start cluster to start next */
S		if (opt) {
S			fp->obj.sclust = scl;		/* Update object allocation information */
S			fp->obj.objsize = fsz;
S			if (_FS_EXFAT) fp->obj.stat = 2;	/* Set status 'contiguous chain' */
S			fp->flag |= FA_MODIFIED;
S			if (fs->free_clst  < fs->n_fatent - 2) {	/* Update FSINFO */
S				fs->free_clst -= tcl;
S				fs->fsi_flag |= 1;
S			}
S		}
S	}
S
S	LEAVE_FF(fs, res);
S}
S
N#endif /* _USE_EXPAND && !_FS_READONLY */
N
N
N
N#if _USE_FORWARD
X#if 0
S/*-----------------------------------------------------------------------*/
S/* Forward data to the stream directly                                   */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_forward (
S	FIL* fp, 						/* Pointer to the file object */
S	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
S	UINT btf,						/* Number of bytes to forward */
S	UINT* bf						/* Pointer to number of bytes forwarded */
S)
S{
S	FRESULT res;
S	FATFS *fs;
S	DWORD clst, sect;
S	FSIZE_t remain;
S	UINT rcnt, csect;
S	BYTE *dbuf;
S
S
S	*bf = 0;	/* Clear transfer byte counter */
S	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
S	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
S	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
S
S	remain = fp->obj.objsize - fp->fptr;
S	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
S
S	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream goes busy */
S		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
S		csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
S		if (fp->fptr % SS(fs) == 0) {				/* On the sector boundary? */
S			if (csect == 0) {						/* On the cluster boundary? */
S				clst = (fp->fptr == 0) ?			/* On the top of the file? */
S					fp->obj.sclust : get_fat(&fp->obj, fp->clust);
S				if (clst <= 1) ABORT(fs, FR_INT_ERR);
S				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
S				fp->clust = clst;					/* Update current cluster */
S			}
S		}
S		sect = clust2sect(fs, fp->clust);			/* Get current data sector */
S		if (!sect) ABORT(fs, FR_INT_ERR);
S		sect += csect;
S#if _FS_TINY
S		if (move_window(fs, sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window to the file data */
S		dbuf = fs->win;
S#else
S		if (fp->sect != sect) {		/* Fill sector cache with file data */
S#if !_FS_READONLY
S			if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
S				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
S				fp->flag &= (BYTE)~FA_DIRTY;
S			}
S#endif
S			if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
S		}
S		dbuf = fp->buf;
S#endif
S		fp->sect = sect;
S		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
S		if (rcnt > btf) rcnt = btf;					/* Clip it by btr if needed */
S		rcnt = (*func)(dbuf + ((UINT)fp->fptr % SS(fs)), rcnt);	/* Forward the file data */
S		if (!rcnt) ABORT(fs, FR_INT_ERR);
S	}
S
S	LEAVE_FF(fs, FR_OK);
S}
N#endif /* _USE_FORWARD */
N
N
N
N#if _USE_MKFS && !_FS_READONLY
X#if 0 && !0
S/*-----------------------------------------------------------------------*/
S/* Create FAT file system on the logical drive                           */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_mkfs (
S	const TCHAR* path,	/* Logical drive number */
S	BYTE opt,			/* Format option */
S	DWORD au,			/* Size of allocation unit [byte] */
S	void* work,			/* Pointer to working buffer */
S	UINT len			/* Size of working buffer */
S)
S{
S	const UINT n_fats = 1;		/* Number of FATs for FAT12/16/32 volume (1 or 2) */
S	const UINT n_rootdir = 512;	/* Number of root directory entries for FAT12/16 volume */
S	static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};	/* Cluster size boundary for FAT12/16 volume (4Ks unit) */
S	static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};	/* Cluster size boundary for FAT32 volume (128Ks unit) */
S	BYTE fmt, sys, *buf, *pte, pdrv, part;
S	WORD ss;
S	DWORD szb_buf, sz_buf, sz_blk, n_clst, pau, sect, nsect, n;
S	DWORD b_vol, b_fat, b_data;				/* Base LBA for volume, fat, data */
S	DWORD sz_vol, sz_rsv, sz_fat, sz_dir;	/* Size for volume, fat, dir, data */
S	UINT i;
S	int vol;
S	DSTATUS stat;
S#if _USE_TRIM || _FS_EXFAT
S	DWORD tbl[3];
S#endif
S
S
S	/* Check mounted drive and clear work area */
S	vol = get_ldnumber(&path);					/* Get target logical drive */
S	if (vol < 0) return FR_INVALID_DRIVE;
S	if (FatFs[vol]) FatFs[vol]->fs_type = 0;	/* Clear mounted volume */
S	pdrv = LD2PD(vol);	/* Physical drive */
S	part = LD2PT(vol);	/* Partition (0:create as new, 1-4:get from partition table) */
S
S	/* Check physical drive status */
S	stat = disk_initialize(pdrv);
S	if (stat & STA_NOINIT) return FR_NOT_READY;
S	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
S	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;	/* Erase block to align data area */
S#if _MAX_SS != _MIN_SS		/* Get sector size of the medium */
S	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;
S	if (ss > _MAX_SS || ss < _MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;
S#else
S	ss = _MAX_SS;
S#endif
S	if ((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;	/* Check if au is valid */
S	au /= ss;	/* Cluster size in unit of sector */
S
S	/* Get working buffer */
S	buf = (BYTE*)work;		/* Working buffer */
S	sz_buf = len / ss;		/* Size of working buffer (sector) */
S	szb_buf = sz_buf * ss;	/* Size of working buffer (byte) */
S	if (!szb_buf) return FR_MKFS_ABORTED;
S
S	/* Determine where the volume to be located (b_vol, sz_vol) */
S	if (_MULTI_PARTITION && part != 0) {
S		/* Get partition information from partition table in the MBR */
S		if (disk_read(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Load MBR */
S		if (ld_word(buf + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;	/* Check if MBR is valid */
S		pte = buf + (MBR_Table + (part - 1) * SZ_PTE);
S		if (!pte[PTE_System]) return FR_MKFS_ABORTED;	/* No partition? */
S		b_vol = ld_dword(pte + PTE_StLba);		/* Get volume start sector */
S		sz_vol = ld_dword(pte + PTE_SizLba);	/* Get volume size */
S	} else {
S		/* Create a single-partition in this function */
S		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) return FR_DISK_ERR;
S		b_vol = (opt & FM_SFD) ? 0 : 63;		/* Volume start sector */
S		if (sz_vol < b_vol) return FR_MKFS_ABORTED;
S		sz_vol -= b_vol;						/* Volume size */
S	}
S	if (sz_vol < 128) return FR_MKFS_ABORTED;	/* Check if volume size is >=128s */
S
S	/* Pre-determine the FAT type */
S	do {
S		if (_FS_EXFAT && (opt & FM_EXFAT)) {	/* exFAT possible? */
S			if ((opt & FM_ANY) == FM_EXFAT || sz_vol >= 0x4000000 || au > 128) {	/* exFAT only, vol >= 64Ms or au > 128s ? */
S				fmt = FS_EXFAT; break;
S			}
S		}
S		if (au > 128) return FR_INVALID_PARAMETER;	/* Too large au for FAT/FAT32 */
S		if (opt & FM_FAT32) {	/* FAT32 possible? */
S			if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {	/* FAT32 only or no-FAT? */
S				fmt = FS_FAT32; break;
S			}
S		}
S		if (!(opt & FM_FAT)) return FR_INVALID_PARAMETER;	/* no-FAT? */
S		fmt = FS_FAT16;
S	} while (0);
S
S#if _FS_EXFAT
S	if (fmt == FS_EXFAT) {	/* Create an exFAT volume */
S		DWORD szb_bit, szb_case, sum, nb, cl;
S		WCHAR ch, si;
S		UINT j, st;
S		BYTE b;
S
S		if (sz_vol < 0x1000) return FR_MKFS_ABORTED;	/* Too small volume? */
S#if _USE_TRIM
S		tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area can be erased */
S		disk_ioctl(pdrv, CTRL_TRIM, tbl);
S#endif
S		/* Determine FAT location, data location and number of clusters */
S		if (!au) {	/* au auto-selection */
S			au = 8;
S			if (sz_vol >= 0x80000) au = 64;		/* >= 512Ks */
S			if (sz_vol >= 0x4000000) au = 256;	/* >= 64Ms */
S		}
S		b_fat = b_vol + 32;										/* FAT start at offset 32 */
S		sz_fat = ((sz_vol / au + 2) * 4 + ss - 1) / ss;			/* Number of FAT sectors */
S		b_data = (b_fat + sz_fat + sz_blk - 1) & ~(sz_blk - 1);	/* Align data area to the erase block boundary */
S		if (b_data >= sz_vol / 2) return FR_MKFS_ABORTED;		/* Too small volume? */
S		n_clst = (sz_vol - (b_data - b_vol)) / au;				/* Number of clusters */
S		if (n_clst <16) return FR_MKFS_ABORTED;					/* Too few clusters? */
S		if (n_clst > MAX_EXFAT) return FR_MKFS_ABORTED;			/* Too many clusters? */
S
S		szb_bit = (n_clst + 7) / 8;						/* Size of allocation bitmap */
S		tbl[0] = (szb_bit + au * ss - 1) / (au * ss);	/* Number of allocation bitmap clusters */
S
S		/* Create a compressed up-case table */
S		sect = b_data + au * tbl[0];	/* Table start sector */
S		sum = 0;						/* Table checksum to be stored in the 82 entry */
S		st = si = i = j = szb_case = 0;
S		do {
S			switch (st) {
S			case 0:
S				ch = ff_wtoupper(si);	/* Get an up-case char */
S				if (ch != si) {
S					si++; break;		/* Store the up-case char if exist */
S				}
S				for (j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;	/* Get run length of no-case block */
S				if (j >= 128) {
S					ch = 0xFFFF; st = 2; break;	/* Compress the no-case block if run is >= 128 */
S				}
S				st = 1;			/* Do not compress short run */
S				/* continue */
S			case 1:
S				ch = si++;		/* Fill the short run */
S				if (--j == 0) st = 0;
S				break;
S			default:
S				ch = (WCHAR)j; si += j;	/* Number of chars to skip */
S				st = 0;
S			}
S			sum = xsum32(buf[i + 0] = (BYTE)ch, sum);		/* Put it into the write buffer */
S			sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);
S			i += 2; szb_case += 2;
S			if (!si || i == szb_buf) {		/* Write buffered data when buffer full or end of process */
S				n = (i + ss - 1) / ss;
S				if (disk_write(pdrv, buf, sect, n) != RES_OK) return FR_DISK_ERR;
S				sect += n; i = 0;
S			}
S		} while (si);
S		tbl[1] = (szb_case + au * ss - 1) / (au * ss);	/* Number of up-case table clusters */
S		tbl[2] = 1;										/* Number of root dir clusters */
S
S		/* Initialize the allocation bitmap */
S		sect = b_data; nsect = (szb_bit + ss - 1) / ss;	/* Start of bitmap and number of sectors */
S		nb = tbl[0] + tbl[1] + tbl[2];					/* Number of clusters in-use by system */
S		do {
S			mem_set(buf, 0, szb_buf);
S			for (i = 0; nb >= 8 && i < szb_buf; buf[i++] = 0xFF, nb -= 8) ;
S			for (b = 1; nb && i < szb_buf; buf[i] |= b, b <<= 1, nb--) ;
S			n = (nsect > sz_buf) ? sz_buf : nsect;		/* Write the buffered data */
S			if (disk_write(pdrv, buf, sect, n) != RES_OK) return FR_DISK_ERR;
S			sect += n; nsect -= n;
S		} while (nsect);
S
S		/* Initialize the FAT */
S		sect = b_fat; nsect = sz_fat;	/* Start of FAT and number of FAT sectors */
S		j = nb = cl = 0;
S		do {
S			mem_set(buf, 0, szb_buf); i = 0;	/* Clear work area and reset write index */
S			if (cl == 0) {	/* Set entry 0 and 1 */
S				st_dword(buf + i, 0xFFFFFFF8); i += 4; cl++;
S				st_dword(buf + i, 0xFFFFFFFF); i += 4; cl++;
S			}
S			do {			/* Create chains of bitmap, up-case and root dir */
S				while (nb && i < szb_buf) {			/* Create a chain */
S					st_dword(buf + i, (nb > 1) ? cl + 1 : 0xFFFFFFFF);
S					i += 4; cl++; nb--;
S				}
S				if (!nb && j < 3) nb = tbl[j++];	/* Next chain */
S			} while (nb && i < szb_buf);
S			n = (nsect > sz_buf) ? sz_buf : nsect;	/* Write the buffered data */
S			if (disk_write(pdrv, buf, sect, n) != RES_OK) return FR_DISK_ERR;
S			sect += n; nsect -= n;
S		} while (nsect);
S
S		/* Initialize the root directory */
S		mem_set(buf, 0, szb_buf);
S		buf[SZDIRE * 0 + 0] = 0x83;		/* 83 entry (volume label) */
S		buf[SZDIRE * 1 + 0] = 0x81;		/* 81 entry (allocation bitmap) */
S		st_dword(buf + SZDIRE * 1 + 20, 2);
S		st_dword(buf + SZDIRE * 1 + 24, szb_bit);
S		buf[SZDIRE * 2 + 0] = 0x82;		/* 82 entry (up-case table) */
S		st_dword(buf + SZDIRE * 2 + 4, sum);
S		st_dword(buf + SZDIRE * 2 + 20, 2 + tbl[0]);
S		st_dword(buf + SZDIRE * 2 + 24, szb_case);
S		sect = b_data + au * (tbl[0] + tbl[1]);	nsect = au;	/* Start of the root directory and number of sectors */
S		do {	/* Fill root directory sectors */
S			n = (nsect > sz_buf) ? sz_buf : nsect;
S			if (disk_write(pdrv, buf, sect, n) != RES_OK) return FR_DISK_ERR;
S			mem_set(buf, 0, ss);
S			sect += n; nsect -= n;
S		} while (nsect);
S
S		/* Create two set of the exFAT VBR blocks */
S		sect = b_vol;
S		for (n = 0; n < 2; n++) {
S			/* Main record (+0) */
S			mem_set(buf, 0, ss);
S			mem_cpy(buf + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11);	/* Boot jump code (x86), OEM name */
S			st_dword(buf + BPB_VolOfsEx, b_vol);					/* Volume offset in the physical drive [sector] */
S			st_dword(buf + BPB_TotSecEx, sz_vol);					/* Volume size [sector] */
S			st_dword(buf + BPB_FatOfsEx, b_fat - b_vol);			/* FAT offset [sector] */
S			st_dword(buf + BPB_FatSzEx, sz_fat);					/* FAT size [sector] */
S			st_dword(buf + BPB_DataOfsEx, b_data - b_vol);			/* Data offset [sector] */
S			st_dword(buf + BPB_NumClusEx, n_clst);					/* Number of clusters */
S			st_dword(buf + BPB_RootClusEx, 2 + tbl[0] + tbl[1]);	/* Root dir cluster # */
S			st_dword(buf + BPB_VolIDEx, GET_FATTIME());				/* VSN */
S			st_word(buf + BPB_FSVerEx, 0x100);						/* File system version (1.00) */
S			for (buf[BPB_BytsPerSecEx] = 0, i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;	/* Log2 of sector size [byte] */
S			for (buf[BPB_SecPerClusEx] = 0, i = au; i >>= 1; buf[BPB_SecPerClusEx]++) ;	/* Log2 of cluster size [sector] */
S			buf[BPB_NumFATsEx] = 1;					/* Number of FATs */
S			buf[BPB_DrvNumEx] = 0x80;				/* Drive number (for int13) */
S			st_word(buf + BS_BootCodeEx, 0xFEEB);	/* Boot code (x86) */
S			st_word(buf + BS_55AA, 0xAA55);			/* Signature (placed here regardless of sector size) */
S			for (i = sum = 0; i < ss; i++) {		/* VBR checksum */
S				if (i != BPB_VolFlagEx && i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum32(buf[i], sum);
S			}
S			if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
S			/* Extended bootstrap record (+1..+8) */
S			mem_set(buf, 0, ss);
S			st_word(buf + ss - 2, 0xAA55);	/* Signature (placed at end of sector) */
S			for (j = 1; j < 9; j++) {
S				for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
S				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
S			}
S			/* OEM/Reserved record (+9..+10) */
S			mem_set(buf, 0, ss);
S			for ( ; j < 11; j++) {
S				for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;	/* VBR checksum */
S				if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
S			}
S			/* Sum record (+11) */
S			for (i = 0; i < ss; i += 4) st_dword(buf + i, sum);		/* Fill with checksum value */
S			if (disk_write(pdrv, buf, sect++, 1) != RES_OK) return FR_DISK_ERR;
S		}
S
S	} else
S#endif	/* _FS_EXFAT */
S	{	/* Create an FAT12/16/32 volume */
S		do {
S			pau = au;
S			/* Pre-determine number of clusters and FAT sub-type */
S			if (fmt == FS_FAT32) {	/* FAT32 volume */
S				if (!pau) {	/* au auto-selection */
S					n = sz_vol / 0x20000;	/* Volume size in unit of 128KS */
S					for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get from table */
S				}
S				n_clst = sz_vol / pau;	/* Number of clusters */
S				sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;	/* FAT size [sector] */
S				sz_rsv = 32;	/* Number of reserved sectors */
S				sz_dir = 0;		/* No static directory */
S				if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) return FR_MKFS_ABORTED;
S			} else {				/* FAT12/16 volume */
S				if (!pau) {	/* au auto-selection */
S					n = sz_vol / 0x1000;	/* Volume size in unit of 4KS */
S					for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get from table */
S				}
S				n_clst = sz_vol / pau;
S				if (n_clst > MAX_FAT12) {
S					n = n_clst * 2 + 4;		/* FAT size [byte] */
S				} else {
S					fmt = FS_FAT12;
S					n = (n_clst * 3 + 1) / 2 + 3;	/* FAT size [byte] */
S				}
S				sz_fat = (n + ss - 1) / ss;		/* FAT size [sector] */
S				sz_rsv = 1;						/* Number of reserved sectors */
S				sz_dir = (DWORD)n_rootdir * SZDIRE / ss;	/* Rootdir size [sector] */
S			}
S			b_fat = b_vol + sz_rsv;						/* FAT base */
S			b_data = b_fat + sz_fat * n_fats + sz_dir;	/* Data base */
S
S			/* Align data base to erase block boundary (for flash memory media) */
S			n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;	/* Next nearest erase block from current data base */
S			if (fmt == FS_FAT32) {		/* FAT32: Move FAT base */
S				sz_rsv += n; b_fat += n;
S			} else {					/* FAT12/16: Expand FAT size */
S				sz_fat += n / n_fats;
S			}
S
S			/* Determine number of clusters and final check of validity of the FAT sub-type */
S			if (sz_vol < b_data + pau * 16 - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
S			n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;
S			if (fmt == FS_FAT32) {
S				if (n_clst <= MAX_FAT16) {	/* Too few clusters for FAT32 */
S					if (!au && (au = pau / 2) != 0) continue;	/* Adjust cluster size and retry */
S					return FR_MKFS_ABORTED;
S				}
S			}
S			if (fmt == FS_FAT16) {
S				if (n_clst > MAX_FAT16) {	/* Too many clusters for FAT16 */
S					if (!au && (pau * 2) <= 64) {
S						au = pau * 2; continue;		/* Adjust cluster size and retry */
S					}
S					if ((opt & FM_FAT32)) {
S						fmt = FS_FAT32; continue;	/* Switch type to FAT32 and retry */
S					}
S					if (!au && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
S					return FR_MKFS_ABORTED;
S				}
S				if  (n_clst <= MAX_FAT12) {	/* Too few clusters for FAT16 */
S					if (!au && (au = pau * 2) <= 128) continue;	/* Adjust cluster size and retry */
S					return FR_MKFS_ABORTED;
S				}
S			}
S			if (fmt == FS_FAT12 && n_clst > MAX_FAT12) return FR_MKFS_ABORTED;	/* Too many clusters for FAT12 */
S
S			/* Ok, it is the valid cluster configuration */
S			break;
S		} while (1);
S
S#if _USE_TRIM
S		tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;	/* Inform the device the volume area can be erased */
S		disk_ioctl(pdrv, CTRL_TRIM, tbl);
S#endif
S		/* Create FAT VBR */
S		mem_set(buf, 0, ss);
S		mem_cpy(buf + BS_JmpBoot, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code (x86), OEM name */
S		st_word(buf + BPB_BytsPerSec, ss);				/* Sector size [byte] */
S		buf[BPB_SecPerClus] = (BYTE)pau;				/* Cluster size [sector] */
S		st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);	/* Size of reserved area */
S		buf[BPB_NumFATs] = (BYTE)n_fats;				/* Number of FATs */
S		st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));	/* Number of root directory entries */
S		if (sz_vol < 0x10000) {
S			st_word(buf + BPB_TotSec16, (WORD)sz_vol);	/* Volume size in 16-bit LBA */
S		} else {
S			st_dword(buf + BPB_TotSec32, sz_vol);		/* Volume size in 32-bit LBA */
S		}
S		buf[BPB_Media] = 0xF8;							/* Media descriptor byte */
S		st_word(buf + BPB_SecPerTrk, 63);				/* Number of sectors per track (for int13) */
S		st_word(buf + BPB_NumHeads, 255);				/* Number of heads (for int13) */
S		st_dword(buf + BPB_HiddSec, b_vol);				/* Volume offset in the physical drive [sector] */
S		if (fmt == FS_FAT32) {
S			st_dword(buf + BS_VolID32, GET_FATTIME());	/* VSN */
S			st_dword(buf + BPB_FATSz32, sz_fat);		/* FAT size [sector] */
S			st_dword(buf + BPB_RootClus32, 2);			/* Root directory cluster # (2) */
S			st_word(buf + BPB_FSInfo32, 1);				/* Offset of FSINFO sector (VBR + 1) */
S			st_word(buf + BPB_BkBootSec32, 6);			/* Offset of backup VBR (VBR + 6) */
S			buf[BS_DrvNum32] = 0x80;					/* Drive number (for int13) */
S			buf[BS_BootSig32] = 0x29;					/* Extended boot signature */
S			mem_cpy(buf + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
S		} else {
S			st_dword(buf + BS_VolID, GET_FATTIME());	/* VSN */
S			st_word(buf + BPB_FATSz16, (WORD)sz_fat);	/* FAT size [sector] */
S			buf[BS_DrvNum] = 0x80;						/* Drive number (for int13) */
S			buf[BS_BootSig] = 0x29;						/* Extended boot signature */
S			mem_cpy(buf + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
S		}
S		st_word(buf + BS_55AA, 0xAA55);					/* Signature (offset is fixed here regardless of sector size) */
S		if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the VBR sector */
S
S		/* Create FSINFO record if needed */
S		if (fmt == FS_FAT32) {
S			disk_write(pdrv, buf, b_vol + 6, 1);		/* Write backup VBR (VBR + 6) */
S			mem_set(buf, 0, ss);
S			st_dword(buf + FSI_LeadSig, 0x41615252);
S			st_dword(buf + FSI_StrucSig, 0x61417272);
S			st_dword(buf + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
S			st_dword(buf + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
S			st_word(buf + BS_55AA, 0xAA55);
S			disk_write(pdrv, buf, b_vol + 7, 1);		/* Write backup FSINFO (VBR + 7) */
S			disk_write(pdrv, buf, b_vol + 1, 1);		/* Write original FSINFO (VBR + 1) */
S		}
S
S		/* Initialize FAT area */
S		mem_set(buf, 0, (UINT)szb_buf);
S		sect = b_fat;		/* FAT start sector */
S		for (i = 0; i < n_fats; i++) {			/* Initialize FATs each */
S			if (fmt == FS_FAT32) {
S				st_dword(buf + 0, 0xFFFFFFF8);	/* Entry 0 */
S				st_dword(buf + 4, 0xFFFFFFFF);	/* Entry 1 */
S				st_dword(buf + 8, 0x0FFFFFFF);	/* Entry 2 (root directory) */
S			} else {
S				st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* Entry 0 and 1 */
S			}
S			nsect = sz_fat;		/* Number of FAT sectors */
S			do {	/* Fill FAT sectors */
S				n = (nsect > sz_buf) ? sz_buf : nsect;
S				if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) return FR_DISK_ERR;
S				mem_set(buf, 0, ss);
S				sect += n; nsect -= n;
S			} while (nsect);
S		}
S
S		/* Initialize root directory (fill with zero) */
S		nsect = (fmt == FS_FAT32) ? pau : sz_dir;	/* Number of root directory sectors */
S		do {
S			n = (nsect > sz_buf) ? sz_buf : nsect;
S			if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) return FR_DISK_ERR;
S			sect += n; nsect -= n;
S		} while (nsect);
S	}
S
S	/* Determine system ID in the partition table */
S	if (_FS_EXFAT && fmt == FS_EXFAT) {
S		sys = 0x07;			/* HPFS/NTFS/exFAT */
S	} else {
S		if (fmt == FS_FAT32) {
S			sys = 0x0C;		/* FAT32X */
S		} else {
S			if (sz_vol >= 0x10000) {
S				sys = 0x06;	/* FAT12/16 (>=64KS) */
S			} else {
S				sys = (fmt == FS_FAT16) ? 0x04 : 0x01;	/* FAT16 (<64KS) : FAT12 (<64KS) */
S			}
S		}
S	}
S
S	if (_MULTI_PARTITION && part != 0) {
S		/* Update system ID in the partition table */
S		if (disk_read(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Read the MBR */
S		buf[MBR_Table + (part - 1) * SZ_PTE + PTE_System] = sys;		/* Set system type */
S		if (disk_write(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it back to the MBR */
S	} else {
S		if (!(opt & FM_SFD)) {
S			/* Create partition table in FDISK format */
S			mem_set(buf, 0, ss);
S			st_word(buf + BS_55AA, 0xAA55);		/* MBR signature */
S			pte = buf + MBR_Table;				/* Create partition table for single partition in the drive */
S			pte[PTE_Boot] = 0;					/* Boot indicator */
S			pte[PTE_StHead] = 1;				/* Start head */
S			pte[PTE_StSec] = 1;					/* Start sector */
S			pte[PTE_StCyl] = 0;					/* Start cylinder */
S			pte[PTE_System] = sys;				/* System type */
S			n = (b_vol + sz_vol) / (63 * 255);	/* (End CHS is incorrect) */
S			pte[PTE_EdHead] = 254;				/* End head */
S			pte[PTE_EdSec] = (BYTE)(n >> 2 | 63);	/* End sector */
S			pte[PTE_EdCyl] = (BYTE)n;			/* End cylinder */
S			st_dword(pte + PTE_StLba, b_vol);	/* Start offset in LBA */
S			st_dword(pte + PTE_SizLba, sz_vol);	/* Size in sectors */
S			if (disk_write(pdrv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;	/* Write it to the MBR */
S		}
S	}
S
S	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) return FR_DISK_ERR;
S
S	return FR_OK;
S}
S
S
S
S#if _MULTI_PARTITION
S/*-----------------------------------------------------------------------*/
S/* Create partition table on the physical drive                          */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_fdisk (
S	BYTE pdrv,			/* Physical drive number */
S	const DWORD* szt,	/* Pointer to the size table for each partitions */
S	void* work			/* Pointer to the working buffer */
S)
S{
S	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
S	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
S	DSTATUS stat;
S	DWORD sz_disk, sz_part, s_part;
S
S
S	stat = disk_initialize(pdrv);
S	if (stat & STA_NOINIT) return FR_NOT_READY;
S	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
S	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
S
S	/* Determine the CHS without any care of the drive geometry */
S	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
S	if (n == 256) n--;
S	e_hd = n - 1;
S	sz_cyl = 63 * n;
S	tot_cyl = sz_disk / sz_cyl;
S
S	/* Create partition table */
S	mem_set(buf, 0, _MAX_SS);
S	p = buf + MBR_Table; b_cyl = 0;
S	for (i = 0; i < 4; i++, p += SZ_PTE) {
S		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
S		if (!p_cyl) continue;
S		s_part = (DWORD)sz_cyl * b_cyl;
S		sz_part = (DWORD)sz_cyl * p_cyl;
S		if (i == 0) {	/* Exclude first track of cylinder 0 */
S			s_hd = 1;
S			s_part += 63; sz_part -= 63;
S		} else {
S			s_hd = 0;
S		}
S		e_cyl = b_cyl + p_cyl - 1;
S		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
S
S		/* Set partition table */
S		p[1] = s_hd;						/* Start head */
S		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
S		p[3] = (BYTE)b_cyl;					/* Start cylinder */
S		p[4] = 0x06;						/* System type (temporary setting) */
S		p[5] = e_hd;						/* End head */
S		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
S		p[7] = (BYTE)e_cyl;					/* End cylinder */
S		st_dword(p + 8, s_part);			/* Start sector in LBA */
S		st_dword(p + 12, sz_part);			/* Partition size */
S
S		/* Next partition */
S		b_cyl += p_cyl;
S	}
S	st_word(p, 0xAA55);
S
S	/* Write it to the MBR */
S	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
S}
S
S#endif /* _MULTI_PARTITION */
N#endif /* _USE_MKFS && !_FS_READONLY */
N
N
N
N
N#if _USE_STRFUNC
X#if 0
S/*-----------------------------------------------------------------------*/
S/* Get a string from the file                                            */
S/*-----------------------------------------------------------------------*/
S
STCHAR* f_gets (
S	TCHAR* buff,	/* Pointer to the string buffer to read */
S	int len,		/* Size of string buffer (characters) */
S	FIL* fp			/* Pointer to the file object */
S)
S{
S	int n = 0;
S	TCHAR c, *p = buff;
S	BYTE s[2];
S	UINT rc;
S
S
S	while (n < len - 1) {	/* Read characters until buffer gets filled */
S#if _LFN_UNICODE
S#if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
S		f_read(fp, s, 1, &rc);
S		if (rc != 1) break;
S		c = s[0];
S		if (c >= 0x80) {
S			if (c < 0xC0) continue;	/* Skip stray trailer */
S			if (c < 0xE0) {			/* Two-byte sequence */
S				f_read(fp, s, 1, &rc);
S				if (rc != 1) break;
S				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
S				if (c < 0x80) c = '?';
S			} else {
S				if (c < 0xF0) {		/* Three-byte sequence */
S					f_read(fp, s, 2, &rc);
S					if (rc != 2) break;
S					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
S					if (c < 0x800) c = '?';
S				} else {			/* Reject four-byte sequence */
S					c = '?';
S				}
S			}
S		}
S#elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
S		f_read(fp, s, 2, &rc);
S		if (rc != 2) break;
S		c = s[1] + (s[0] << 8);
S#elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
S		f_read(fp, s, 2, &rc);
S		if (rc != 2) break;
S		c = s[0] + (s[1] << 8);
S#else						/* Read a character in ANSI/OEM */
S		f_read(fp, s, 1, &rc);
S		if (rc != 1) break;
S		c = s[0];
S		if (IsDBCS1(c)) {
S			f_read(fp, s, 1, &rc);
S			if (rc != 1) break;
S			c = (c << 8) + s[0];
S		}
S		c = ff_convert(c, 1);	/* OEM -> Unicode */
S		if (!c) c = '?';
S#endif
S#else						/* Read a character without conversion */
S		f_read(fp, s, 1, &rc);
S		if (rc != 1) break;
S		c = s[0];
S#endif
S		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
S		*p++ = c;
S		n++;
S		if (c == '\n') break;		/* Break on EOL */
S	}
S	*p = 0;
S	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
S}
S
S
S
S
S#if !_FS_READONLY
S#include <stdarg.h>
S/*-----------------------------------------------------------------------*/
S/* Put a character to the file                                           */
S/*-----------------------------------------------------------------------*/
S
Stypedef struct {
S	FIL *fp;		/* Ptr to the writing file */
S	int idx, nchr;	/* Write index of buf[] (-1:error), number of chars written */
S	BYTE buf[64];	/* Write buffer */
S} putbuff;
S
S
Sstatic
Svoid putc_bfd (		/* Buffered write with code conversion */
S	putbuff* pb,
S	TCHAR c
S)
S{
S	UINT bw;
S	int i;
S
S
S	if (_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
S		putc_bfd(pb, '\r');
S	}
S
S	i = pb->idx;		/* Write index of pb->buf[] */
S	if (i < 0) return;
S
S#if _LFN_UNICODE
S#if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
S	if (c < 0x80) {				/* 7-bit */
S		pb->buf[i++] = (BYTE)c;
S	} else {
S		if (c < 0x800) {		/* 11-bit */
S			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
S		} else {				/* 16-bit */
S			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
S			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
S		}
S		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
S	}
S#elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
S	pb->buf[i++] = (BYTE)(c >> 8);
S	pb->buf[i++] = (BYTE)c;
S#elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
S	pb->buf[i++] = (BYTE)c;
S	pb->buf[i++] = (BYTE)(c >> 8);
S#else							/* Write a character in ANSI/OEM */
S	c = ff_convert(c, 0);	/* Unicode -> OEM */
S	if (!c) c = '?';
S	if (c >= 0x100)
S		pb->buf[i++] = (BYTE)(c >> 8);
S	pb->buf[i++] = (BYTE)c;
S#endif
S#else							/* Write a character without conversion */
S	pb->buf[i++] = (BYTE)c;
S#endif
S
S	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
S		f_write(pb->fp, pb->buf, (UINT)i, &bw);
S		i = (bw == (UINT)i) ? 0 : -1;
S	}
S	pb->idx = i;
S	pb->nchr++;
S}
S
S
Sstatic
Sint putc_flush (		/* Flush left characters in the buffer */
S	putbuff* pb
S)
S{
S	UINT nw;
S
S	if (   pb->idx >= 0	/* Flush buffered characters to the file */
S		&& f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK
S		&& (UINT)pb->idx == nw) return pb->nchr;
S	return EOF;
S}
S
S
Sstatic
Svoid putc_init (		/* Initialize write buffer */
S	putbuff* pb,
S	FIL* fp
S)
S{
S	pb->fp = fp;
S	pb->nchr = pb->idx = 0;
S}
S
S
S
Sint f_putc (
S	TCHAR c,	/* A character to be output */
S	FIL* fp		/* Pointer to the file object */
S)
S{
S	putbuff pb;
S
S
S	putc_init(&pb, fp);
S	putc_bfd(&pb, c);	/* Put the character */
S	return putc_flush(&pb);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Put a string to the file                                              */
S/*-----------------------------------------------------------------------*/
S
Sint f_puts (
S	const TCHAR* str,	/* Pointer to the string to be output */
S	FIL* fp				/* Pointer to the file object */
S)
S{
S	putbuff pb;
S
S
S	putc_init(&pb, fp);
S	while (*str) putc_bfd(&pb, *str++);		/* Put the string */
S	return putc_flush(&pb);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Put a formatted string to the file                                    */
S/*-----------------------------------------------------------------------*/
S
Sint f_printf (
S	FIL* fp,			/* Pointer to the file object */
S	const TCHAR* fmt,	/* Pointer to the format string */
S	...					/* Optional arguments... */
S)
S{
S	va_list arp;
S	putbuff pb;
S	BYTE f, r;
S	UINT i, j, w;
S	DWORD v;
S	TCHAR c, d, str[32], *p;
S
S
S	putc_init(&pb, fp);
S
S	va_start(arp, fmt);
S
S	for (;;) {
S		c = *fmt++;
S		if (c == 0) break;			/* End of string */
S		if (c != '%') {				/* Non escape character */
S			putc_bfd(&pb, c);
S			continue;
S		}
S		w = f = 0;
S		c = *fmt++;
S		if (c == '0') {				/* Flag: '0' padding */
S			f = 1; c = *fmt++;
S		} else {
S			if (c == '-') {			/* Flag: left justified */
S				f = 2; c = *fmt++;
S			}
S		}
S		while (IsDigit(c)) {		/* Precision */
S			w = w * 10 + c - '0';
S			c = *fmt++;
S		}
S		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
S			f |= 4; c = *fmt++;
S		}
S		if (!c) break;
S		d = c;
S		if (IsLower(d)) d -= 0x20;
S		switch (d) {				/* Type is... */
S		case 'S' :					/* String */
S			p = va_arg(arp, TCHAR*);
S			for (j = 0; p[j]; j++) ;
S			if (!(f & 2)) {
S				while (j++ < w) putc_bfd(&pb, ' ');
S			}
S			while (*p) putc_bfd(&pb, *p++);
S			while (j++ < w) putc_bfd(&pb, ' ');
S			continue;
S		case 'C' :					/* Character */
S			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
S		case 'B' :					/* Binary */
S			r = 2; break;
S		case 'O' :					/* Octal */
S			r = 8; break;
S		case 'D' :					/* Signed decimal */
S		case 'U' :					/* Unsigned decimal */
S			r = 10; break;
S		case 'X' :					/* Hexdecimal */
S			r = 16; break;
S		default:					/* Unknown type (pass-through) */
S			putc_bfd(&pb, c); continue;
S		}
S
S		/* Get an argument and put it in numeral */
S		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
S		if (d == 'D' && (v & 0x80000000)) {
S			v = 0 - v;
S			f |= 8;
S		}
S		i = 0;
S		do {
S			d = (TCHAR)(v % r); v /= r;
S			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
S			str[i++] = d + '0';
S		} while (v && i < sizeof str / sizeof str[0]);
S		if (f & 8) str[i++] = '-';
S		j = i; d = (f & 1) ? '0' : ' ';
S		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
S		do putc_bfd(&pb, str[--i]); while (i);
S		while (j++ < w) putc_bfd(&pb, d);
S	}
S
S	va_end(arp);
S
S	return putc_flush(&pb);
S}
S
S#endif /* !_FS_READONLY */
N#endif /* _USE_STRFUNC */
