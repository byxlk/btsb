; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ff.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ff.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\User\bsp -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\FatFS\src -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\ff.crf ..\FatFS\src\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2913   static
;;;2914   BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;2915   	FATFS* fs,	/* File system object */
;;;2916   	DWORD sect	/* Sector# (lba) to check if it is an FAT-VBR or not */
;;;2917   )
;;;2918   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2919   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
000006  2000              MOVS     r0,#0
000008  70e0              STRB     r0,[r4,#3]
00000a  1e40              SUBS     r0,r0,#1
00000c  62e0              STR      r0,[r4,#0x2c]
;;;2920   	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       move_window
000016  b108              CBZ      r0,|L1.28|
000018  2004              MOVS     r0,#4
                  |L1.26|
;;;2921   
;;;2922   	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
;;;2923   
;;;2924   	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
;;;2925   		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
;;;2926   		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
;;;2927   	}
;;;2928   #if _FS_EXFAT
;;;2929   	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
;;;2930   #endif
;;;2931   	return 2;
;;;2932   }
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  f204202e          ADD      r0,r4,#0x22e          ;2922
000020  f7fffffe          BL       ld_word
000024  f64a2155          MOV      r1,#0xaa55            ;2922
000028  4288              CMP      r0,r1                 ;2922
00002a  d001              BEQ      |L1.48|
00002c  2003              MOVS     r0,#3                 ;2922
00002e  e7f4              B        |L1.26|
                  |L1.48|
000030  f8940030          LDRB     r0,[r4,#0x30]         ;2924
000034  28e9              CMP      r0,#0xe9              ;2924
000036  d007              BEQ      |L1.72|
000038  f8940030          LDRB     r0,[r4,#0x30]         ;2924
00003c  28eb              CMP      r0,#0xeb              ;2924
00003e  d117              BNE      |L1.112|
000040  2032              MOVS     r0,#0x32              ;2924
000042  5d00              LDRB     r0,[r0,r4]            ;2924
000044  2890              CMP      r0,#0x90              ;2924
000046  d113              BNE      |L1.112|
                  |L1.72|
000048  f1040066          ADD      r0,r4,#0x66           ;2925
00004c  f7fffffe          BL       ld_dword
000050  f020407f          BIC      r0,r0,#0xff000000     ;2925
000054  4907              LDR      r1,|L1.116|
000056  4288              CMP      r0,r1                 ;2925
000058  d101              BNE      |L1.94|
00005a  2000              MOVS     r0,#0                 ;2925
00005c  e7dd              B        |L1.26|
                  |L1.94|
00005e  f1040082          ADD      r0,r4,#0x82           ;2926
000062  f7fffffe          BL       ld_dword
000066  4904              LDR      r1,|L1.120|
000068  4288              CMP      r0,r1                 ;2926
00006a  d101              BNE      |L1.112|
00006c  2000              MOVS     r0,#0                 ;2926
00006e  e7d4              B        |L1.26|
                  |L1.112|
000070  2002              MOVS     r0,#2                 ;2931
000072  e7d2              B        |L1.26|
;;;2933   
                          ENDP

                  |L1.116|
                          DCD      0x00544146
                  |L1.120|
                          DCD      0x33544146

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;713    static
;;;714    int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
000000  4602              MOV      r2,r0
;;;715    	while (*str && *str != chr) str++;
000002  e000              B        |L2.6|
                  |L2.4|
000004  1c52              ADDS     r2,r2,#1
                  |L2.6|
000006  7810              LDRB     r0,[r2,#0]
000008  b110              CBZ      r0,|L2.16|
00000a  7810              LDRB     r0,[r2,#0]
00000c  4288              CMP      r0,r1
00000e  d1f9              BNE      |L2.4|
                  |L2.16|
;;;716    	return *str;
000010  7810              LDRB     r0,[r2,#0]
;;;717    }
000012  4770              BX       lr
;;;718    
                          ENDP


                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;967    static
;;;968    DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
000000  4602              MOV      r2,r0
;;;969    	FATFS* fs,		/* File system object */
;;;970    	DWORD clst		/* Cluster# to be converted */
;;;971    )
;;;972    {
;;;973    	clst -= 2;
000002  1e89              SUBS     r1,r1,#2
;;;974    	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
000004  6950              LDR      r0,[r2,#0x14]
000006  1e80              SUBS     r0,r0,#2
000008  4288              CMP      r0,r1
00000a  d801              BHI      |L3.16|
00000c  2000              MOVS     r0,#0
                  |L3.14|
;;;975    	return clst * fs->csize + fs->database;
;;;976    }
00000e  4770              BX       lr
                  |L3.16|
000010  8953              LDRH     r3,[r2,#0xa]          ;975
000012  6a90              LDR      r0,[r2,#0x28]         ;975
000014  fb010003          MLA      r0,r1,r3,r0           ;975
000018  e7f9              B        |L3.14|
;;;977    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;1311   static
;;;1312   DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1313   	_FDID* obj,			/* Corresponding object */
;;;1314   	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
;;;1315   )
;;;1316   {
000004  4682              MOV      r10,r0
000006  4689              MOV      r9,r1
;;;1317   	DWORD cs, ncl, scl;
;;;1318   	FRESULT res;
;;;1319   	FATFS *fs = obj->fs;
000008  f8da4000          LDR      r4,[r10,#0]
;;;1320   
;;;1321   
;;;1322   	if (clst == 0) {	/* Create a new chain */
00000c  f1b90f00          CMP      r9,#0
000010  d106              BNE      |L4.32|
;;;1323   		scl = fs->last_clst;				/* Get suggested cluster to start from */
000012  68e7              LDR      r7,[r4,#0xc]
;;;1324   		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
000014  b117              CBZ      r7,|L4.28|
000016  6960              LDR      r0,[r4,#0x14]
000018  42b8              CMP      r0,r7
00001a  d815              BHI      |L4.72|
                  |L4.28|
00001c  2701              MOVS     r7,#1
00001e  e013              B        |L4.72|
                  |L4.32|
;;;1325   	}
;;;1326   	else {				/* Stretch current chain */
;;;1327   		cs = get_fat(obj, clst);			/* Check the cluster status */
000020  4649              MOV      r1,r9
000022  4650              MOV      r0,r10
000024  f7fffffe          BL       get_fat
000028  4606              MOV      r6,r0
;;;1328   		if (cs < 2) return 1;				/* Invalid value */
00002a  2e02              CMP      r6,#2
00002c  d202              BCS      |L4.52|
00002e  2001              MOVS     r0,#1
                  |L4.48|
;;;1329   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1330   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1331   		scl = clst;
;;;1332   	}
;;;1333   
;;;1334   #if _FS_EXFAT
;;;1335   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;1336   		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
;;;1337   		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
;;;1338   		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
;;;1339   		if (res == FR_INT_ERR) return 1;
;;;1340   		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
;;;1341   		if (clst == 0) {							/* Is it a new chain? */
;;;1342   			obj->stat = 2;							/* Set status 'contiguous chain' */
;;;1343   		} else {									/* This is a stretched chain */
;;;1344   			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
;;;1345   				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
;;;1346   				obj->stat = 3;						/* Change status 'just fragmented' */
;;;1347   			}
;;;1348   		}
;;;1349   	} else
;;;1350   #endif
;;;1351   	{	/* On the FAT12/16/32 volume */
;;;1352   		ncl = scl;	/* Start cluster */
;;;1353   		for (;;) {
;;;1354   			ncl++;							/* Next cluster */
;;;1355   			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
;;;1356   				ncl = 2;
;;;1357   				if (ncl > scl) return 0;	/* No free cluster */
;;;1358   			}
;;;1359   			cs = get_fat(obj, ncl);			/* Get the cluster status */
;;;1360   			if (cs == 0) break;				/* Found a free cluster */
;;;1361   			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
;;;1362   			if (ncl == scl) return 0;		/* No free cluster */
;;;1363   		}
;;;1364   	}
;;;1365   
;;;1366   	if (_FS_EXFAT && fs->fs_type == FS_EXFAT && obj->stat == 2) {	/* Is it a contiguous chain? */
;;;1367   		res = FR_OK;						/* FAT does not need to be written */
;;;1368   	} else {
;;;1369   		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
;;;1370   		if (res == FR_OK && clst) {
;;;1371   			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
;;;1372   		}
;;;1373   	}
;;;1374   
;;;1375   	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
;;;1376   		fs->last_clst = ncl;
;;;1377   		if (fs->free_clst < fs->n_fatent - 2) fs->free_clst--;
;;;1378   		fs->fsi_flag |= 1;
;;;1379   	} else {
;;;1380   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Create error status */
;;;1381   	}
;;;1382   
;;;1383   	return ncl;		/* Return new cluster number or error status */
;;;1384   }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L4.52|
000034  1c70              ADDS     r0,r6,#1              ;1329
000036  b908              CBNZ     r0,|L4.60|
000038  4630              MOV      r0,r6                 ;1329
00003a  e7f9              B        |L4.48|
                  |L4.60|
00003c  6960              LDR      r0,[r4,#0x14]         ;1330
00003e  42b0              CMP      r0,r6                 ;1330
000040  d901              BLS      |L4.70|
000042  4630              MOV      r0,r6                 ;1330
000044  e7f4              B        |L4.48|
                  |L4.70|
000046  464f              MOV      r7,r9                 ;1331
                  |L4.72|
000048  463d              MOV      r5,r7                 ;1352
00004a  bf00              NOP                            ;1353
                  |L4.76|
00004c  1c6d              ADDS     r5,r5,#1              ;1354
00004e  6960              LDR      r0,[r4,#0x14]         ;1355
000050  42a8              CMP      r0,r5                 ;1355
000052  d804              BHI      |L4.94|
000054  2502              MOVS     r5,#2                 ;1356
000056  42bd              CMP      r5,r7                 ;1357
000058  d901              BLS      |L4.94|
00005a  2000              MOVS     r0,#0                 ;1357
00005c  e7e8              B        |L4.48|
                  |L4.94|
00005e  4629              MOV      r1,r5                 ;1359
000060  4650              MOV      r0,r10                ;1359
000062  f7fffffe          BL       get_fat
000066  4606              MOV      r6,r0                 ;1359
000068  b906              CBNZ     r6,|L4.108|
00006a  e009              B        |L4.128|
                  |L4.108|
00006c  2e01              CMP      r6,#1                 ;1361
00006e  d001              BEQ      |L4.116|
000070  1c70              ADDS     r0,r6,#1              ;1361
000072  b908              CBNZ     r0,|L4.120|
                  |L4.116|
000074  4630              MOV      r0,r6                 ;1361
000076  e7db              B        |L4.48|
                  |L4.120|
000078  42bd              CMP      r5,r7                 ;1362
00007a  d1e7              BNE      |L4.76|
00007c  2000              MOVS     r0,#0                 ;1362
00007e  e7d7              B        |L4.48|
                  |L4.128|
000080  bf00              NOP                            ;1360
000082  bf00              NOP                            ;1366
000084  f04f32ff          MOV      r2,#0xffffffff        ;1369
000088  4629              MOV      r1,r5                 ;1369
00008a  4620              MOV      r0,r4                 ;1369
00008c  f7fffffe          BL       put_fat
000090  4680              MOV      r8,r0                 ;1369
000092  f1b80f00          CMP      r8,#0                 ;1370
000096  d108              BNE      |L4.170|
000098  f1b90f00          CMP      r9,#0                 ;1370
00009c  d005              BEQ      |L4.170|
00009e  462a              MOV      r2,r5                 ;1371
0000a0  4649              MOV      r1,r9                 ;1371
0000a2  4620              MOV      r0,r4                 ;1371
0000a4  f7fffffe          BL       put_fat
0000a8  4680              MOV      r8,r0                 ;1371
                  |L4.170|
0000aa  f1b80f00          CMP      r8,#0                 ;1375
0000ae  d10d              BNE      |L4.204|
0000b0  60e5              STR      r5,[r4,#0xc]          ;1376
0000b2  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;1377
0000b6  1e80              SUBS     r0,r0,#2              ;1377
0000b8  4281              CMP      r1,r0                 ;1377
0000ba  d202              BCS      |L4.194|
0000bc  6920              LDR      r0,[r4,#0x10]         ;1377
0000be  1e40              SUBS     r0,r0,#1              ;1377
0000c0  6120              STR      r0,[r4,#0x10]         ;1377
                  |L4.194|
0000c2  7920              LDRB     r0,[r4,#4]            ;1378
0000c4  f0400001          ORR      r0,r0,#1              ;1378
0000c8  7120              STRB     r0,[r4,#4]            ;1378
0000ca  e007              B        |L4.220|
                  |L4.204|
0000cc  f1b80f01          CMP      r8,#1                 ;1380
0000d0  d102              BNE      |L4.216|
0000d2  f04f30ff          MOV      r0,#0xffffffff        ;1380
0000d6  e000              B        |L4.218|
                  |L4.216|
0000d8  2001              MOVS     r0,#1                 ;1380
                  |L4.218|
0000da  4605              MOV      r5,r0                 ;1380
                  |L4.220|
0000dc  4628              MOV      r0,r5                 ;1383
0000de  e7a7              B        |L4.48|
;;;1385   
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;2569   static
;;;2570   FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
000000  e92d5ff3          PUSH     {r0,r1,r4-r12,lr}
;;;2571   	DIR* dp,			/* Pointer to the directory object */
;;;2572   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;2573   )
;;;2574   {
000004  468a              MOV      r10,r1
;;;2575   #if _USE_LFN != 0	/* LFN configuration */
;;;2576   	BYTE b, cf;
;;;2577   	WCHAR w, *lfn;
;;;2578   	UINT i, ni, si, di;
;;;2579   	const TCHAR *p;
;;;2580   
;;;2581   	/* Create LFN in Unicode */
;;;2582   	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
;;;2583   	for (;;) {
;;;2584   		w = p[si++];					/* Get a character */
;;;2585   		if (w < ' ') break;				/* Break if end of the path name */
;;;2586   		if (w == '/' || w == '\\') {	/* Break if a separator is found */
;;;2587   			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
;;;2588   			break;
;;;2589   		}
;;;2590   		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
;;;2591   #if !_LFN_UNICODE
;;;2592   		w &= 0xFF;
;;;2593   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;2594   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;2595   			w = (w << 8) + b;			/* Create a DBC */
;;;2596   			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;2597   		}
;;;2598   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;2599   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;2600   #endif
;;;2601   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
;;;2602   		lfn[di++] = w;					/* Store the Unicode character */
;;;2603   	}
;;;2604   	*path = &p[si];						/* Return pointer to the next segment */
;;;2605   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
;;;2606   #if _FS_RPATH != 0
;;;2607   	if ((di == 1 && lfn[di - 1] == '.') ||
;;;2608   		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
;;;2609   		lfn[di] = 0;
;;;2610   		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
;;;2611   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;2612   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;2613   		return FR_OK;
;;;2614   	}
;;;2615   #endif
;;;2616   	while (di) {						/* Snip off trailing spaces and dots if exist */
;;;2617   		w = lfn[di - 1];
;;;2618   		if (w != ' ' && w != '.') break;
;;;2619   		di--;
;;;2620   	}
;;;2621   	lfn[di] = 0;						/* LFN is created */
;;;2622   	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
;;;2623   
;;;2624   	/* Create SFN in directory form */
;;;2625   	mem_set(dp->fn, ' ', 11);
;;;2626   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;2627   	if (si) cf |= NS_LOSS | NS_LFN;
;;;2628   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;2629   
;;;2630   	i = b = 0; ni = 8;
;;;2631   	for (;;) {
;;;2632   		w = lfn[si++];					/* Get an LFN character */
;;;2633   		if (!w) break;					/* Break on end of the LFN */
;;;2634   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;2635   			cf |= NS_LOSS | NS_LFN; continue;
;;;2636   		}
;;;2637   
;;;2638   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;2639   			if (ni == 11) {				/* Long extension */
;;;2640   				cf |= NS_LOSS | NS_LFN; break;
;;;2641   			}
;;;2642   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;2643   			if (si > di) break;			/* No extension */
;;;2644   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;2645   			b <<= 2; continue;
;;;2646   		}
;;;2647   
;;;2648   		if (w >= 0x80) {				/* Non ASCII character */
;;;2649   #ifdef _EXCVT
;;;2650   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;2651   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;2652   #else
;;;2653   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;2654   #endif
;;;2655   			cf |= NS_LFN;				/* Force create LFN entry */
;;;2656   		}
;;;2657   
;;;2658   		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
;;;2659   			if (i >= ni - 1) {
;;;2660   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;2661   			}
;;;2662   			dp->fn[i++] = (BYTE)(w >> 8);
;;;2663   		} else {						/* SBC */
;;;2664   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;2665   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;2666   			} else {
;;;2667   				if (IsUpper(w)) {		/* ASCII large capital */
;;;2668   					b |= 2;
;;;2669   				} else {
;;;2670   					if (IsLower(w)) {	/* ASCII small capital */
;;;2671   						b |= 1; w -= 0x20;
;;;2672   					}
;;;2673   				}
;;;2674   			}
;;;2675   		}
;;;2676   		dp->fn[i++] = (BYTE)w;
;;;2677   	}
;;;2678   
;;;2679   	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;2680   
;;;2681   	if (ni == 8) b <<= 2;
;;;2682   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
;;;2683   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;2684   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;2685   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;2686   	}
;;;2687   
;;;2688   	dp->fn[NSFLAG] = cf;	/* SFN is created */
;;;2689   
;;;2690   	return FR_OK;
;;;2691   
;;;2692   
;;;2693   #else	/* _USE_LFN != 0 : Non-LFN configuration */
;;;2694   	BYTE c, d, *sfn;
;;;2695   	UINT ni, si, i;
;;;2696   	const char *p;
;;;2697   
;;;2698   	/* Create file name in directory form */
;;;2699   	p = *path; sfn = dp->fn;
000006  f8da9000          LDR      r9,[r10,#0]
00000a  9800              LDR      r0,[sp,#0]
00000c  f1000520          ADD      r5,r0,#0x20
;;;2700   	mem_set(sfn, ' ', 11);
000010  220b              MOVS     r2,#0xb
000012  2120              MOVS     r1,#0x20
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       mem_set
;;;2701   	si = i = 0; ni = 8;
00001a  2000              MOVS     r0,#0
00001c  4680              MOV      r8,r0
00001e  4607              MOV      r7,r0
000020  f04f0b08          MOV      r11,#8
;;;2702   #if _FS_RPATH != 0
;;;2703   	if (p[si] == '.') { /* Is this a dot entry? */
;;;2704   		for (;;) {
;;;2705   			c = (BYTE)p[si++];
;;;2706   			if (c != '.' || si >= 3) break;
;;;2707   			sfn[i++] = c;
;;;2708   		}
;;;2709   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;2710   		*path = p + si;								/* Return pointer to the next segment */
;;;2711   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path */
;;;2712   		return FR_OK;
;;;2713   	}
;;;2714   #endif
;;;2715   	for (;;) {
000024  bf00              NOP      
                  |L5.38|
;;;2716   		c = (BYTE)p[si++];
000026  4638              MOV      r0,r7
000028  1c7f              ADDS     r7,r7,#1
00002a  f8194000          LDRB     r4,[r9,r0]
;;;2717   		if (c <= ' ') break; 			/* Break if end of the path name */
00002e  2c20              CMP      r4,#0x20
000030  dc00              BGT      |L5.52|
000032  e055              B        |L5.224|
                  |L5.52|
;;;2718   		if (c == '/' || c == '\\') {	/* Break if a separator is found */
000034  2c2f              CMP      r4,#0x2f
000036  d001              BEQ      |L5.60|
000038  2c5c              CMP      r4,#0x5c
00003a  d10a              BNE      |L5.82|
                  |L5.60|
;;;2719   			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
00003c  e000              B        |L5.64|
                  |L5.62|
00003e  1c7f              ADDS     r7,r7,#1
                  |L5.64|
000040  f8190007          LDRB     r0,[r9,r7]
000044  282f              CMP      r0,#0x2f
000046  d0fa              BEQ      |L5.62|
000048  f8190007          LDRB     r0,[r9,r7]
00004c  285c              CMP      r0,#0x5c
00004e  d0f6              BEQ      |L5.62|
;;;2720   			break;
000050  e046              B        |L5.224|
                  |L5.82|
;;;2721   		}
;;;2722   		if (c == '.' || i >= ni) {		/* End of body or over size? */
000052  2c2e              CMP      r4,#0x2e
000054  d001              BEQ      |L5.90|
000056  45d8              CMP      r8,r11
000058  d30c              BCC      |L5.116|
                  |L5.90|
;;;2723   			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
00005a  f1bb0f0b          CMP      r11,#0xb
00005e  d001              BEQ      |L5.100|
000060  2c2e              CMP      r4,#0x2e
000062  d002              BEQ      |L5.106|
                  |L5.100|
000064  2006              MOVS     r0,#6
                  |L5.102|
;;;2724   			i = 8; ni = 11;				/* Goto extension */
;;;2725   			continue;
;;;2726   		}
;;;2727   		if (c >= 0x80) {				/* Extended character? */
;;;2728   #ifdef _EXCVT
;;;2729   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;;;2730   #else
;;;2731   #if !_DF1S
;;;2732   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII only cfg) */
;;;2733   #endif
;;;2734   #endif
;;;2735   		}
;;;2736   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
;;;2737   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;2738   			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
;;;2739   			sfn[i++] = c;
;;;2740   			sfn[i++] = d;
;;;2741   		} else {						/* SBC */
;;;2742   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
;;;2743   			if (IsLower(c)) c -= 0x20;	/* To upper */
;;;2744   			sfn[i++] = c;
;;;2745   		}
;;;2746   	}
;;;2747   	*path = p + si;						/* Return pointer to the next segment */
;;;2748   	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
;;;2749   
;;;2750   	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;2751   	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
;;;2752   
;;;2753   	return FR_OK;
;;;2754   #endif /* _USE_LFN != 0 */
;;;2755   }
000066  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.106|
00006a  f04f0808          MOV      r8,#8                 ;2724
00006e  f04f0b0b          MOV      r11,#0xb              ;2724
000072  e7d8              B        |L5.38|
                  |L5.116|
000074  2c81              CMP      r4,#0x81              ;2736
000076  db01              BLT      |L5.124|
000078  2c9f              CMP      r4,#0x9f              ;2736
00007a  dd03              BLE      |L5.132|
                  |L5.124|
00007c  2ce0              CMP      r4,#0xe0              ;2736
00007e  db1c              BLT      |L5.186|
000080  2cfc              CMP      r4,#0xfc              ;2736
000082  dc1a              BGT      |L5.186|
                  |L5.132|
000084  4638              MOV      r0,r7                 ;2737
000086  1c7f              ADDS     r7,r7,#1              ;2737
000088  f8196000          LDRB     r6,[r9,r0]            ;2737
00008c  2e40              CMP      r6,#0x40              ;2738
00008e  db01              BLT      |L5.148|
000090  2e7e              CMP      r6,#0x7e              ;2738
000092  dd03              BLE      |L5.156|
                  |L5.148|
000094  2e80              CMP      r6,#0x80              ;2738
000096  db05              BLT      |L5.164|
000098  2efc              CMP      r6,#0xfc              ;2738
00009a  dc03              BGT      |L5.164|
                  |L5.156|
00009c  f1ab0001          SUB      r0,r11,#1             ;2738
0000a0  4540              CMP      r0,r8                 ;2738
0000a2  d801              BHI      |L5.168|
                  |L5.164|
0000a4  2006              MOVS     r0,#6                 ;2738
0000a6  e7de              B        |L5.102|
                  |L5.168|
0000a8  4640              MOV      r0,r8                 ;2739
0000aa  f1080801          ADD      r8,r8,#1              ;2739
0000ae  542c              STRB     r4,[r5,r0]            ;2739
0000b0  4640              MOV      r0,r8                 ;2740
0000b2  f1080801          ADD      r8,r8,#1              ;2740
0000b6  542e              STRB     r6,[r5,r0]            ;2740
0000b8  e011              B        |L5.222|
                  |L5.186|
0000ba  4621              MOV      r1,r4                 ;2742
0000bc  a014              ADR      r0,|L5.272|
0000be  f7fffffe          BL       chk_chr
0000c2  b108              CBZ      r0,|L5.200|
0000c4  2006              MOVS     r0,#6                 ;2742
0000c6  e7ce              B        |L5.102|
                  |L5.200|
0000c8  2c61              CMP      r4,#0x61              ;2743
0000ca  db04              BLT      |L5.214|
0000cc  2c7a              CMP      r4,#0x7a              ;2743
0000ce  dc02              BGT      |L5.214|
0000d0  f1a40020          SUB      r0,r4,#0x20           ;2743
0000d4  b2c4              UXTB     r4,r0                 ;2743
                  |L5.214|
0000d6  4640              MOV      r0,r8                 ;2744
0000d8  f1080801          ADD      r8,r8,#1              ;2744
0000dc  542c              STRB     r4,[r5,r0]            ;2744
                  |L5.222|
0000de  e7a2              B        |L5.38|
                  |L5.224|
0000e0  bf00              NOP                            ;2717
0000e2  eb090007          ADD      r0,r9,r7              ;2747
0000e6  f8ca0000          STR      r0,[r10,#0]           ;2747
0000ea  f1b80f00          CMP      r8,#0                 ;2748
0000ee  d101              BNE      |L5.244|
0000f0  2006              MOVS     r0,#6                 ;2748
0000f2  e7b8              B        |L5.102|
                  |L5.244|
0000f4  7828              LDRB     r0,[r5,#0]            ;2750
0000f6  28e5              CMP      r0,#0xe5              ;2750
0000f8  d101              BNE      |L5.254|
0000fa  2005              MOVS     r0,#5                 ;2750
0000fc  7028              STRB     r0,[r5,#0]            ;2750
                  |L5.254|
0000fe  2c20              CMP      r4,#0x20              ;2751
000100  dc01              BGT      |L5.262|
000102  2004              MOVS     r0,#4                 ;2751
000104  e000              B        |L5.264|
                  |L5.262|
000106  2000              MOVS     r0,#0                 ;2751
                  |L5.264|
000108  72e8              STRB     r0,[r5,#0xb]          ;2751
00010a  2000              MOVS     r0,#0                 ;2753
00010c  e7ab              B        |L5.102|
;;;2756   
                          ENDP

00010e  0000              DCW      0x0000
                  |L5.272|
000110  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
000114  3a3b3c3d
000118  3e3f5b5d
00011c  7c7f00  
00011f  00                DCB      0

                          AREA ||i.dir_alloc||, CODE, READONLY, ALIGN=1

                  dir_alloc PROC
;;;1545   static
;;;1546   FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1547   	DIR* dp,		/* Pointer to the directory object */
;;;1548   	UINT nent		/* Number of contiguous entries to allocate */
;;;1549   )
;;;1550   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1551   	FRESULT res;
;;;1552   	UINT n;
;;;1553   	FATFS *fs = dp->obj.fs;
000008  f8d48000          LDR      r8,[r4,#0]
;;;1554   
;;;1555   
;;;1556   	res = dir_sdi(dp, 0);
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       dir_sdi
000014  4605              MOV      r5,r0
;;;1557   	if (res == FR_OK) {
000016  b9ed              CBNZ     r5,|L6.84|
;;;1558   		n = 0;
000018  2700              MOVS     r7,#0
;;;1559   		do {
00001a  bf00              NOP      
                  |L6.28|
;;;1560   			res = move_window(fs, dp->sect);
00001c  4640              MOV      r0,r8
00001e  69a1              LDR      r1,[r4,#0x18]
000020  f7fffffe          BL       move_window
000024  4605              MOV      r5,r0
;;;1561   			if (res != FR_OK) break;
000026  b105              CBZ      r5,|L6.42|
000028  e013              B        |L6.82|
                  |L6.42|
;;;1562   #if _FS_EXFAT
;;;1563   			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
;;;1564   #else
;;;1565   			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
00002a  69e0              LDR      r0,[r4,#0x1c]
00002c  7800              LDRB     r0,[r0,#0]
00002e  28e5              CMP      r0,#0xe5
000030  d002              BEQ      |L6.56|
000032  69e0              LDR      r0,[r4,#0x1c]
000034  7800              LDRB     r0,[r0,#0]
000036  b920              CBNZ     r0,|L6.66|
                  |L6.56|
;;;1566   #endif
;;;1567   				if (++n == nent) break;	/* A block of contiguous free entries is found */
000038  1c78              ADDS     r0,r7,#1
00003a  4607              MOV      r7,r0
00003c  42b0              CMP      r0,r6
00003e  d101              BNE      |L6.68|
000040  e007              B        |L6.82|
                  |L6.66|
;;;1568   			} else {
;;;1569   				n = 0;					/* Not a blank entry. Restart to search */
000042  2700              MOVS     r7,#0
                  |L6.68|
;;;1570   			}
;;;1571   			res = dir_next(dp, 1);
000044  2101              MOVS     r1,#1
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       dir_next
00004c  4605              MOV      r5,r0
;;;1572   		} while (res == FR_OK);	/* Next entry with table stretch enabled */
00004e  2d00              CMP      r5,#0
000050  d0e4              BEQ      |L6.28|
                  |L6.82|
000052  bf00              NOP                            ;1561
                  |L6.84|
;;;1573   	}
;;;1574   
;;;1575   	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
000054  2d04              CMP      r5,#4
000056  d100              BNE      |L6.90|
000058  2507              MOVS     r5,#7
                  |L6.90|
;;;1576   	return res;
00005a  4628              MOV      r0,r5
;;;1577   }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;1578   
                          ENDP


                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;2165   static
;;;2166   FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2167   	DIR* dp			/* Pointer to the directory object with the file name */
;;;2168   )
;;;2169   {
000004  4604              MOV      r4,r0
;;;2170   	FRESULT res;
;;;2171   	FATFS *fs = dp->obj.fs;
000006  6827              LDR      r7,[r4,#0]
;;;2172   	BYTE c;
;;;2173   #if _USE_LFN != 0
;;;2174   	BYTE a, ord, sum;
;;;2175   #endif
;;;2176   
;;;2177   	res = dir_sdi(dp, 0);			/* Rewind directory object */
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       dir_sdi
000010  4605              MOV      r5,r0
;;;2178   	if (res != FR_OK) return res;
000012  b115              CBZ      r5,|L7.26|
000014  4628              MOV      r0,r5
                  |L7.22|
;;;2179   #if _FS_EXFAT
;;;2180   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2181   		BYTE nc;
;;;2182   		UINT di, ni;
;;;2183   		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
;;;2184   
;;;2185   		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
;;;2186   			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip the comparison if hash value mismatched */
;;;2187   			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
;;;2188   				if ((di % SZDIRE) == 0) di += 2;
;;;2189   				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
;;;2190   			}
;;;2191   			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
;;;2192   		}
;;;2193   		return res;
;;;2194   	}
;;;2195   #endif
;;;2196   	/* On the FAT12/16/32 volume */
;;;2197   #if _USE_LFN != 0
;;;2198   	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;2199   #endif
;;;2200   	do {
;;;2201   		res = move_window(fs, dp->sect);
;;;2202   		if (res != FR_OK) break;
;;;2203   		c = dp->dir[DIR_Name];
;;;2204   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;;;2205   #if _USE_LFN != 0	/* LFN configuration */
;;;2206   		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
;;;2207   		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;2208   			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;2209   		} else {
;;;2210   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;2211   				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
;;;2212   					if (c & LLEF) {		/* Is it start of LFN sequence? */
;;;2213   						sum = dp->dir[LDIR_Chksum];
;;;2214   						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
;;;2215   						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
;;;2216   					}
;;;2217   					/* Check validity of the LFN entry and compare it with given name */
;;;2218   					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
;;;2219   				}
;;;2220   			} else {					/* An SFN entry is found */
;;;2221   				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
;;;2222   				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
;;;2223   				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
;;;2224   			}
;;;2225   		}
;;;2226   #else		/* Non LFN configuration */
;;;2227   		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
;;;2228   		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
;;;2229   #endif
;;;2230   		res = dir_next(dp, 0);	/* Next entry */
;;;2231   	} while (res == FR_OK);
;;;2232   
;;;2233   	return res;
;;;2234   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  bf00              NOP                            ;2200
                  |L7.28|
00001c  4638              MOV      r0,r7                 ;2201
00001e  69a1              LDR      r1,[r4,#0x18]         ;2201
000020  f7fffffe          BL       move_window
000024  4605              MOV      r5,r0                 ;2201
000026  b105              CBZ      r5,|L7.42|
000028  e01d              B        |L7.102|
                  |L7.42|
00002a  69e0              LDR      r0,[r4,#0x1c]         ;2203
00002c  7806              LDRB     r6,[r0,#0]            ;2203
00002e  b90e              CBNZ     r6,|L7.52|
000030  2504              MOVS     r5,#4                 ;2204
000032  e018              B        |L7.102|
                  |L7.52|
000034  69e0              LDR      r0,[r4,#0x1c]         ;2227
000036  7ac0              LDRB     r0,[r0,#0xb]          ;2227
000038  f000003f          AND      r0,r0,#0x3f           ;2227
00003c  71a0              STRB     r0,[r4,#6]            ;2227
00003e  69e0              LDR      r0,[r4,#0x1c]         ;2228
000040  7ac0              LDRB     r0,[r0,#0xb]          ;2228
000042  f0000008          AND      r0,r0,#8              ;2228
000046  b938              CBNZ     r0,|L7.88|
000048  220b              MOVS     r2,#0xb               ;2228
00004a  f1040120          ADD      r1,r4,#0x20           ;2228
00004e  69e0              LDR      r0,[r4,#0x1c]         ;2228
000050  f7fffffe          BL       mem_cmp
000054  b900              CBNZ     r0,|L7.88|
000056  e006              B        |L7.102|
                  |L7.88|
000058  2100              MOVS     r1,#0                 ;2230
00005a  4620              MOV      r0,r4                 ;2230
00005c  f7fffffe          BL       dir_next
000060  4605              MOV      r5,r0                 ;2230
000062  2d00              CMP      r5,#0                 ;2231
000064  d0da              BEQ      |L7.28|
                  |L7.102|
000066  bf00              NOP                            ;2202
000068  4628              MOV      r0,r5                 ;2233
00006a  e7d4              B        |L7.22|
;;;2235   
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1475   static
;;;1476   FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1477   	DIR* dp,		/* Pointer to the directory object */
;;;1478   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1479   )
;;;1480   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;1481   	DWORD ofs, clst;
;;;1482   	FATFS *fs = dp->obj.fs;
000008  6825              LDR      r5,[r4,#0]
;;;1483   #if !_FS_READONLY
;;;1484   	UINT n;
;;;1485   #endif
;;;1486   
;;;1487   	ofs = dp->dptr + SZDIRE;	/* Next entry */
00000a  6920              LDR      r0,[r4,#0x10]
00000c  f1000720          ADD      r7,r0,#0x20
;;;1488   	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
000010  69a0              LDR      r0,[r4,#0x18]
000012  b110              CBZ      r0,|L8.26|
000014  f5b71f00          CMP      r7,#0x200000
000018  d302              BCC      |L8.32|
                  |L8.26|
00001a  2004              MOVS     r0,#4
                  |L8.28|
;;;1489   
;;;1490   	if (ofs % SS(fs) == 0) {	/* Sector changed? */
;;;1491   		dp->sect++;				/* Next sector */
;;;1492   
;;;1493   		if (!dp->clust) {		/* Static table */
;;;1494   			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
;;;1495   				dp->sect = 0; return FR_NO_FILE;
;;;1496   			}
;;;1497   		}
;;;1498   		else {					/* Dynamic table */
;;;1499   			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
;;;1500   				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
;;;1501   				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
;;;1502   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
;;;1503   				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
;;;1504   #if !_FS_READONLY
;;;1505   					if (!stretch) {								/* If no stretch, report EOT */
;;;1506   						dp->sect = 0; return FR_NO_FILE;
;;;1507   					}
;;;1508   					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
;;;1509   					if (clst == 0) return FR_DENIED;			/* No free cluster */
;;;1510   					if (clst == 1) return FR_INT_ERR;			/* Internal error */
;;;1511   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1512   					/* Clean-up the stretched table */
;;;1513   					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
;;;1514   					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
;;;1515   					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
;;;1516   					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
;;;1517   						fs->wflag = 1;
;;;1518   						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
;;;1519   					}
;;;1520   					fs->winsect -= n;							/* Restore window offset */
;;;1521   #else
;;;1522   					if (!stretch) dp->sect = 0;					/* If no stretch, report EOT (this is to suppress warning) */
;;;1523   					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
;;;1524   #endif
;;;1525   				}
;;;1526   				dp->clust = clst;		/* Initialize data for new cluster */
;;;1527   				dp->sect = clust2sect(fs, clst);
;;;1528   			}
;;;1529   		}
;;;1530   	}
;;;1531   	dp->dptr = ofs;						/* Current entry */
;;;1532   	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
;;;1533   
;;;1534   	return FR_OK;
;;;1535   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L8.32|
000020  f3c70008          UBFX     r0,r7,#0,#9           ;1490
000024  2800              CMP      r0,#0                 ;1490
000026  d168              BNE      |L8.250|
000028  69a0              LDR      r0,[r4,#0x18]         ;1491
00002a  1c40              ADDS     r0,r0,#1              ;1491
00002c  61a0              STR      r0,[r4,#0x18]         ;1491
00002e  6960              LDR      r0,[r4,#0x14]         ;1493
000030  b938              CBNZ     r0,|L8.66|
000032  8928              LDRH     r0,[r5,#8]            ;1494
000034  ebb01f57          CMP      r0,r7,LSR #5          ;1494
000038  d85f              BHI      |L8.250|
00003a  2000              MOVS     r0,#0                 ;1495
00003c  61a0              STR      r0,[r4,#0x18]         ;1495
00003e  2004              MOVS     r0,#4                 ;1495
000040  e7ec              B        |L8.28|
                  |L8.66|
000042  8968              LDRH     r0,[r5,#0xa]          ;1499
000044  1e40              SUBS     r0,r0,#1              ;1499
000046  ea002057          AND      r0,r0,r7,LSR #9       ;1499
00004a  2800              CMP      r0,#0                 ;1499
00004c  d155              BNE      |L8.250|
00004e  4620              MOV      r0,r4                 ;1500
000050  6961              LDR      r1,[r4,#0x14]         ;1500
000052  f7fffffe          BL       get_fat
000056  4606              MOV      r6,r0                 ;1500
000058  2e01              CMP      r6,#1                 ;1501
00005a  d801              BHI      |L8.96|
00005c  2002              MOVS     r0,#2                 ;1501
00005e  e7dd              B        |L8.28|
                  |L8.96|
000060  1c70              ADDS     r0,r6,#1              ;1502
000062  b908              CBNZ     r0,|L8.104|
000064  2001              MOVS     r0,#1                 ;1502
000066  e7d9              B        |L8.28|
                  |L8.104|
000068  6968              LDR      r0,[r5,#0x14]         ;1503
00006a  42b0              CMP      r0,r6                 ;1503
00006c  d83f              BHI      |L8.238|
00006e  f1b90f00          CMP      r9,#0                 ;1505
000072  d103              BNE      |L8.124|
000074  2000              MOVS     r0,#0                 ;1506
000076  61a0              STR      r0,[r4,#0x18]         ;1506
000078  2004              MOVS     r0,#4                 ;1506
00007a  e7cf              B        |L8.28|
                  |L8.124|
00007c  4620              MOV      r0,r4                 ;1508
00007e  6961              LDR      r1,[r4,#0x14]         ;1508
000080  f7fffffe          BL       create_chain
000084  4606              MOV      r6,r0                 ;1508
000086  b90e              CBNZ     r6,|L8.140|
000088  2007              MOVS     r0,#7                 ;1509
00008a  e7c7              B        |L8.28|
                  |L8.140|
00008c  2e01              CMP      r6,#1                 ;1510
00008e  d101              BNE      |L8.148|
000090  2002              MOVS     r0,#2                 ;1510
000092  e7c3              B        |L8.28|
                  |L8.148|
000094  1c70              ADDS     r0,r6,#1              ;1511
000096  b908              CBNZ     r0,|L8.156|
000098  2001              MOVS     r0,#1                 ;1511
00009a  e7bf              B        |L8.28|
                  |L8.156|
00009c  4628              MOV      r0,r5                 ;1514
00009e  f7fffffe          BL       sync_window
0000a2  b108              CBZ      r0,|L8.168|
0000a4  2001              MOVS     r0,#1                 ;1514
0000a6  e7b9              B        |L8.28|
                  |L8.168|
0000a8  f44f7200          MOV      r2,#0x200             ;1515
0000ac  2100              MOVS     r1,#0                 ;1515
0000ae  f1050030          ADD      r0,r5,#0x30           ;1515
0000b2  f7fffffe          BL       mem_set
0000b6  f04f0800          MOV      r8,#0                 ;1516
0000ba  4631              MOV      r1,r6                 ;1516
0000bc  4628              MOV      r0,r5                 ;1516
0000be  f7fffffe          BL       clust2sect
0000c2  62e8              STR      r0,[r5,#0x2c]         ;1516
0000c4  e00c              B        |L8.224|
                  |L8.198|
0000c6  2001              MOVS     r0,#1                 ;1517
0000c8  70e8              STRB     r0,[r5,#3]            ;1517
0000ca  4628              MOV      r0,r5                 ;1518
0000cc  f7fffffe          BL       sync_window
0000d0  b108              CBZ      r0,|L8.214|
0000d2  2001              MOVS     r0,#1                 ;1518
0000d4  e7a2              B        |L8.28|
                  |L8.214|
0000d6  f1080801          ADD      r8,r8,#1              ;1516
0000da  6ae8              LDR      r0,[r5,#0x2c]         ;1516
0000dc  1c40              ADDS     r0,r0,#1              ;1516
0000de  62e8              STR      r0,[r5,#0x2c]         ;1516
                  |L8.224|
0000e0  8968              LDRH     r0,[r5,#0xa]          ;1516
0000e2  4540              CMP      r0,r8                 ;1516
0000e4  d8ef              BHI      |L8.198|
0000e6  6ae8              LDR      r0,[r5,#0x2c]         ;1520
0000e8  eba00008          SUB      r0,r0,r8              ;1520
0000ec  62e8              STR      r0,[r5,#0x2c]         ;1520
                  |L8.238|
0000ee  6166              STR      r6,[r4,#0x14]         ;1526
0000f0  4631              MOV      r1,r6                 ;1527
0000f2  4628              MOV      r0,r5                 ;1527
0000f4  f7fffffe          BL       clust2sect
0000f8  61a0              STR      r0,[r4,#0x18]         ;1527
                  |L8.250|
0000fa  6127              STR      r7,[r4,#0x10]         ;1531
0000fc  f3c70108          UBFX     r1,r7,#0,#9           ;1532
000100  f1050030          ADD      r0,r5,#0x30           ;1532
000104  4408              ADD      r0,r0,r1              ;1532
000106  61e0              STR      r0,[r4,#0x1c]         ;1532
000108  2000              MOVS     r0,#0                 ;1534
00010a  e787              B        |L8.28|
;;;1536   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;2088   static
;;;2089   FRESULT dir_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2090   	DIR* dp,		/* Pointer to the directory object */
;;;2091   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;2092   )
;;;2093   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;2094   	FRESULT res = FR_NO_FILE;
000008  2504              MOVS     r5,#4
;;;2095   	FATFS *fs = dp->obj.fs;
00000a  f8d49000          LDR      r9,[r4,#0]
;;;2096   	BYTE a, c;
;;;2097   #if _USE_LFN != 0
;;;2098   	BYTE ord = 0xFF, sum = 0xFF;
;;;2099   #endif
;;;2100   
;;;2101   	while (dp->sect) {
00000e  e027              B        |L9.96|
                  |L9.16|
;;;2102   		res = move_window(fs, dp->sect);
000010  4648              MOV      r0,r9
000012  69a1              LDR      r1,[r4,#0x18]
000014  f7fffffe          BL       move_window
000018  4605              MOV      r5,r0
;;;2103   		if (res != FR_OK) break;
00001a  b105              CBZ      r5,|L9.30|
00001c  e023              B        |L9.102|
                  |L9.30|
;;;2104   		c = dp->dir[DIR_Name];	/* Test for the entry type */
00001e  69e0              LDR      r0,[r4,#0x1c]
000020  7806              LDRB     r6,[r0,#0]
;;;2105   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of the directory */
000022  b90e              CBNZ     r6,|L9.40|
000024  2504              MOVS     r5,#4
000026  e01e              B        |L9.102|
                  |L9.40|
;;;2106   #if _FS_EXFAT
;;;2107   		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2108   			if (_USE_LABEL && vol) {
;;;2109   				if (c == 0x83) break;	/* Volume label entry? */
;;;2110   			} else {
;;;2111   				if (c == 0x85) {		/* Start of the file entry block? */
;;;2112   					dp->blk_ofs = dp->dptr;	/* Get location of the block */
;;;2113   					res = load_xdir(dp);	/* Load the entry block */
;;;2114   					if (res == FR_OK) {
;;;2115   						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
;;;2116   					}
;;;2117   					break;
;;;2118   				}
;;;2119   			}
;;;2120   		} else
;;;2121   #endif
;;;2122   		{	/* On the FAT12/16/32 volume */
;;;2123   			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
000028  69e0              LDR      r0,[r4,#0x1c]
00002a  7ac0              LDRB     r0,[r0,#0xb]
00002c  f000073f          AND      r7,r0,#0x3f
000030  71a7              STRB     r7,[r4,#6]
;;;2124   #if _USE_LFN != 0	/* LFN configuration */
;;;2125   			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
;;;2126   				ord = 0xFF;
;;;2127   			} else {
;;;2128   				if (a == AM_LFN) {			/* An LFN entry is found */
;;;2129   					if (c & LLEF) {			/* Is it start of an LFN sequence? */
;;;2130   						sum = dp->dir[LDIR_Chksum];
;;;2131   						c &= (BYTE)~LLEF; ord = c;
;;;2132   						dp->blk_ofs = dp->dptr;
;;;2133   					}
;;;2134   					/* Check LFN validity and capture it */
;;;2135   					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
;;;2136   				} else {					/* An SFN entry is found */
;;;2137   					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
;;;2138   						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
;;;2139   					}
;;;2140   					break;
;;;2141   				}
;;;2142   			}
;;;2143   #else		/* Non LFN configuration */
;;;2144   			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
000032  2ee5              CMP      r6,#0xe5
000034  d00d              BEQ      |L9.82|
000036  2e2e              CMP      r6,#0x2e
000038  d00b              BEQ      |L9.82|
00003a  2f0f              CMP      r7,#0xf
00003c  d009              BEQ      |L9.82|
00003e  f0270020          BIC      r0,r7,#0x20
000042  2808              CMP      r0,#8
000044  d101              BNE      |L9.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L9.76|
                  |L9.74|
00004a  2000              MOVS     r0,#0
                  |L9.76|
00004c  4540              CMP      r0,r8
00004e  d100              BNE      |L9.82|
;;;2145   				break;
000050  e009              B        |L9.102|
                  |L9.82|
;;;2146   			}
;;;2147   #endif
;;;2148   		}
;;;2149   		res = dir_next(dp, 0);		/* Next entry */
000052  2100              MOVS     r1,#0
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       dir_next
00005a  4605              MOV      r5,r0
;;;2150   		if (res != FR_OK) break;
00005c  b105              CBZ      r5,|L9.96|
00005e  e002              B        |L9.102|
                  |L9.96|
000060  69a0              LDR      r0,[r4,#0x18]         ;2101
000062  2800              CMP      r0,#0                 ;2101
000064  d1d4              BNE      |L9.16|
                  |L9.102|
000066  bf00              NOP                            ;2103
;;;2151   	}
;;;2152   
;;;2153   	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
000068  b10d              CBZ      r5,|L9.110|
00006a  2000              MOVS     r0,#0
00006c  61a0              STR      r0,[r4,#0x18]
                  |L9.110|
;;;2154   	return res;
00006e  4628              MOV      r0,r5
;;;2155   }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;2156   
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;2244   static
;;;2245   FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;2246   	DIR* dp				/* Target directory with object name to be created */
;;;2247   )
;;;2248   {
000002  4604              MOV      r4,r0
;;;2249   	FRESULT res;
;;;2250   	FATFS *fs = dp->obj.fs;
000004  6826              LDR      r6,[r4,#0]
;;;2251   #if _USE_LFN != 0	/* LFN configuration */
;;;2252   	UINT n, nlen, nent;
;;;2253   	BYTE sn[12], sum;
;;;2254   
;;;2255   
;;;2256   	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
;;;2257   	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
;;;2258   
;;;2259   #if _FS_EXFAT
;;;2260   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2261   		DIR dj;
;;;2262   
;;;2263   		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
;;;2264   		res = dir_alloc(dp, nent);		/* Allocate entries */
;;;2265   		if (res != FR_OK) return res;
;;;2266   		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);			/* Set block position */
;;;2267   
;;;2268   		if (dp->obj.sclust != 0 && (dp->obj.stat & 4)) {	/* Has the sub-directory been stretched? */
;;;2269   			dp->obj.stat &= 3;
;;;2270   			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase object size by cluster size */
;;;2271   			res = fill_fat_chain(&dp->obj);	/* Complement FAT chain if needed */
;;;2272   			if (res != FR_OK) return res;
;;;2273   			res = load_obj_dir(&dj, &dp->obj);
;;;2274   			if (res != FR_OK) return res;	/* Load the object status */
;;;2275   			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
;;;2276   			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
;;;2277   			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
;;;2278   			res = store_xdir(&dj);			/* Store the object status */
;;;2279   			if (res != FR_OK) return res;
;;;2280   		}
;;;2281   
;;;2282   		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
;;;2283   		return FR_OK;
;;;2284   	}
;;;2285   #endif
;;;2286   	/* On the FAT12/16/32 volume */
;;;2287   	mem_cpy(sn, dp->fn, 12);
;;;2288   	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;2289   		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
;;;2290   		for (n = 1; n < 100; n++) {
;;;2291   			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
;;;2292   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;2293   			if (res != FR_OK) break;
;;;2294   		}
;;;2295   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;2296   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;2297   		dp->fn[NSFLAG] = sn[NSFLAG];
;;;2298   	}
;;;2299   
;;;2300   	/* Create an SFN with/without LFNs. */
;;;2301   	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
;;;2302   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;2303   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;2304   		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
;;;2305   		if (res == FR_OK) {
;;;2306   			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
;;;2307   			do {					/* Store LFN entries in bottom first */
;;;2308   				res = move_window(fs, dp->sect);
;;;2309   				if (res != FR_OK) break;
;;;2310   				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
;;;2311   				fs->wflag = 1;
;;;2312   				res = dir_next(dp, 0);	/* Next entry */
;;;2313   			} while (res == FR_OK && --nent);
;;;2314   		}
;;;2315   	}
;;;2316   
;;;2317   #else	/* Non LFN configuration */
;;;2318   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dir_alloc
00000e  4605              MOV      r5,r0
;;;2319   
;;;2320   #endif
;;;2321   
;;;2322   	/* Set SFN entry */
;;;2323   	if (res == FR_OK) {
000010  b995              CBNZ     r5,|L10.56|
;;;2324   		res = move_window(fs, dp->sect);
000012  4630              MOV      r0,r6
000014  69a1              LDR      r1,[r4,#0x18]
000016  f7fffffe          BL       move_window
00001a  4605              MOV      r5,r0
;;;2325   		if (res == FR_OK) {
00001c  b965              CBNZ     r5,|L10.56|
;;;2326   			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
00001e  2220              MOVS     r2,#0x20
000020  2100              MOVS     r1,#0
000022  69e0              LDR      r0,[r4,#0x1c]
000024  f7fffffe          BL       mem_set
;;;2327   			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
000028  220b              MOVS     r2,#0xb
00002a  f1040120          ADD      r1,r4,#0x20
00002e  69e0              LDR      r0,[r4,#0x1c]
000030  f7fffffe          BL       mem_cpy
;;;2328   #if _USE_LFN != 0
;;;2329   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;2330   #endif
;;;2331   			fs->wflag = 1;
000034  2001              MOVS     r0,#1
000036  70f0              STRB     r0,[r6,#3]
                  |L10.56|
;;;2332   		}
;;;2333   	}
;;;2334   
;;;2335   	return res;
000038  4628              MOV      r0,r5
;;;2336   }
00003a  bd70              POP      {r4-r6,pc}
;;;2337   
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;2347   static
;;;2348   FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;2349   	DIR* dp				/* Directory object pointing the entry to be removed */
;;;2350   )
;;;2351   {
000002  4604              MOV      r4,r0
;;;2352   	FRESULT res;
;;;2353   	FATFS *fs = dp->obj.fs;
000004  6826              LDR      r6,[r4,#0]
;;;2354   #if _USE_LFN != 0	/* LFN configuration */
;;;2355   	DWORD last = dp->dptr;
;;;2356   
;;;2357   	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
;;;2358   	if (res == FR_OK) {
;;;2359   		do {
;;;2360   			res = move_window(fs, dp->sect);
;;;2361   			if (res != FR_OK) break;
;;;2362   			/* Mark an entry 'deleted' */
;;;2363   			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2364   				dp->dir[XDIR_Type] &= 0x7F;
;;;2365   			} else {									/* On the FAT12/16/32 volume */
;;;2366   				dp->dir[DIR_Name] = DDEM;
;;;2367   			}
;;;2368   			fs->wflag = 1;
;;;2369   			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
;;;2370   			res = dir_next(dp, 0);	/* Next entry */
;;;2371   		} while (res == FR_OK);
;;;2372   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;2373   	}
;;;2374   #else			/* Non LFN configuration */
;;;2375   
;;;2376   	res = move_window(fs, dp->sect);
000006  4630              MOV      r0,r6
000008  69a1              LDR      r1,[r4,#0x18]
00000a  f7fffffe          BL       move_window
00000e  4605              MOV      r5,r0
;;;2377   	if (res == FR_OK) {
000010  b925              CBNZ     r5,|L11.28|
;;;2378   		dp->dir[DIR_Name] = DDEM;
000012  20e5              MOVS     r0,#0xe5
000014  69e1              LDR      r1,[r4,#0x1c]
000016  7008              STRB     r0,[r1,#0]
;;;2379   		fs->wflag = 1;
000018  2001              MOVS     r0,#1
00001a  70f0              STRB     r0,[r6,#3]
                  |L11.28|
;;;2380   	}
;;;2381   #endif
;;;2382   
;;;2383   	return res;
00001c  4628              MOV      r0,r5
;;;2384   }
00001e  bd70              POP      {r4-r6,pc}
;;;2385   
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1426   static
;;;1427   FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1428   	DIR* dp,		/* Pointer to directory object */
;;;1429   	DWORD ofs		/* Offset of directory table */
;;;1430   )
;;;1431   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1432   	DWORD csz, clst;
;;;1433   	FATFS *fs = dp->obj.fs;
000008  6826              LDR      r6,[r4,#0]
;;;1434   
;;;1435   
;;;1436   	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
00000a  f5b51f00          CMP      r5,#0x200000
00000e  d202              BCS      |L12.22|
000010  f005001f          AND      r0,r5,#0x1f
000014  b110              CBZ      r0,|L12.28|
                  |L12.22|
;;;1437   		return FR_INT_ERR;
000016  2002              MOVS     r0,#2
                  |L12.24|
;;;1438   	}
;;;1439   	dp->dptr = ofs;				/* Set current offset */
;;;1440   	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
;;;1441   	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
;;;1442   		clst = fs->dirbase;
;;;1443   		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
;;;1444   	}
;;;1445   
;;;1446   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1447   		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
;;;1448   		dp->sect = fs->dirbase;
;;;1449   
;;;1450   	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
;;;1451   		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
;;;1452   		while (ofs >= csz) {				/* Follow cluster chain */
;;;1453   			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
;;;1454   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1455   			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
;;;1456   			ofs -= csz;
;;;1457   		}
;;;1458   		dp->sect = clust2sect(fs, clst);
;;;1459   	}
;;;1460   	dp->clust = clst;					/* Current cluster# */
;;;1461   	if (!dp->sect) return FR_INT_ERR;
;;;1462   	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
;;;1463   	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
;;;1464   
;;;1465   	return FR_OK;
;;;1466   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L12.28|
00001c  6125              STR      r5,[r4,#0x10]         ;1439
00001e  68a7              LDR      r7,[r4,#8]            ;1440
000020  b91f              CBNZ     r7,|L12.42|
000022  7830              LDRB     r0,[r6,#0]            ;1441
000024  2803              CMP      r0,#3                 ;1441
000026  db00              BLT      |L12.42|
000028  6a77              LDR      r7,[r6,#0x24]         ;1442
                  |L12.42|
00002a  b947              CBNZ     r7,|L12.62|
00002c  8930              LDRH     r0,[r6,#8]            ;1447
00002e  ebb01f55          CMP      r0,r5,LSR #5          ;1447
000032  d801              BHI      |L12.56|
000034  2002              MOVS     r0,#2                 ;1447
000036  e7ef              B        |L12.24|
                  |L12.56|
000038  6a70              LDR      r0,[r6,#0x24]         ;1448
00003a  61a0              STR      r0,[r4,#0x18]         ;1448
00003c  e01c              B        |L12.120|
                  |L12.62|
00003e  8970              LDRH     r0,[r6,#0xa]          ;1451
000040  ea4f2840          LSL      r8,r0,#9              ;1451
000044  e011              B        |L12.106|
                  |L12.70|
000046  4639              MOV      r1,r7                 ;1453
000048  4620              MOV      r0,r4                 ;1453
00004a  f7fffffe          BL       get_fat
00004e  4607              MOV      r7,r0                 ;1453
000050  1c78              ADDS     r0,r7,#1              ;1454
000052  b908              CBNZ     r0,|L12.88|
000054  2001              MOVS     r0,#1                 ;1454
000056  e7df              B        |L12.24|
                  |L12.88|
000058  2f02              CMP      r7,#2                 ;1455
00005a  d302              BCC      |L12.98|
00005c  6970              LDR      r0,[r6,#0x14]         ;1455
00005e  42b8              CMP      r0,r7                 ;1455
000060  d801              BHI      |L12.102|
                  |L12.98|
000062  2002              MOVS     r0,#2                 ;1455
000064  e7d8              B        |L12.24|
                  |L12.102|
000066  eba50508          SUB      r5,r5,r8              ;1456
                  |L12.106|
00006a  4545              CMP      r5,r8                 ;1452
00006c  d2eb              BCS      |L12.70|
00006e  4639              MOV      r1,r7                 ;1458
000070  4630              MOV      r0,r6                 ;1458
000072  f7fffffe          BL       clust2sect
000076  61a0              STR      r0,[r4,#0x18]         ;1458
                  |L12.120|
000078  6167              STR      r7,[r4,#0x14]         ;1460
00007a  69a0              LDR      r0,[r4,#0x18]         ;1461
00007c  b908              CBNZ     r0,|L12.130|
00007e  2002              MOVS     r0,#2                 ;1461
000080  e7ca              B        |L12.24|
                  |L12.130|
000082  69a0              LDR      r0,[r4,#0x18]         ;1462
000084  eb002055          ADD      r0,r0,r5,LSR #9       ;1462
000088  61a0              STR      r0,[r4,#0x18]         ;1462
00008a  f3c50108          UBFX     r1,r5,#0,#9           ;1463
00008e  f1060030          ADD      r0,r6,#0x30           ;1463
000092  4408              ADD      r0,r0,r1              ;1463
000094  61e0              STR      r0,[r4,#0x1c]         ;1463
000096  2000              MOVS     r0,#0                 ;1465
000098  e7be              B        |L12.24|
;;;1467   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;3744   
;;;3745   FRESULT f_close (
000000  b538              PUSH     {r3-r5,lr}
;;;3746   	FIL* fp		/* Pointer to the file object to be closed */
;;;3747   )
;;;3748   {
000002  4605              MOV      r5,r0
;;;3749   	FRESULT res;
;;;3750   	FATFS *fs;
;;;3751   
;;;3752   #if !_FS_READONLY
;;;3753   	res = f_sync(fp);					/* Flush cached data */
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       f_sync
00000a  4604              MOV      r4,r0
;;;3754   	if (res == FR_OK)
00000c  b93c              CBNZ     r4,|L13.30|
;;;3755   #endif
;;;3756   	{
;;;3757   		res = validate(&fp->obj, &fs);	/* Lock volume */
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       validate
000016  4604              MOV      r4,r0
;;;3758   		if (res == FR_OK) {
000018  b90c              CBNZ     r4,|L13.30|
;;;3759   #if _FS_LOCK != 0
;;;3760   			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
;;;3761   			if (res == FR_OK)
;;;3762   #endif
;;;3763   			{
;;;3764   				fp->obj.fs = 0;			/* Invalidate file object */
00001a  2000              MOVS     r0,#0
00001c  6028              STR      r0,[r5,#0]
                  |L13.30|
;;;3765   			}
;;;3766   #if _FS_REENTRANT
;;;3767   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3768   #endif
;;;3769   		}
;;;3770   	}
;;;3771   	return res;
00001e  4620              MOV      r0,r4
;;;3772   }
000020  bd38              POP      {r3-r5,pc}
;;;3773   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;4156   
;;;4157   FRESULT f_closedir (
000000  b538              PUSH     {r3-r5,lr}
;;;4158   	DIR *dp		/* Pointer to the directory object to be closed */
;;;4159   )
;;;4160   {
000002  4604              MOV      r4,r0
;;;4161   	FRESULT res;
;;;4162   	FATFS *fs;
;;;4163   
;;;4164   
;;;4165   	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4605              MOV      r5,r0
;;;4166   	if (res == FR_OK) {
00000e  b90d              CBNZ     r5,|L14.20|
;;;4167   #if _FS_LOCK != 0
;;;4168   		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
;;;4169   			res = dec_lock(dp->obj.lockid);
;;;4170   		}
;;;4171   		if (res == FR_OK)
;;;4172   #endif
;;;4173   		{
;;;4174   			dp->obj.fs = 0;			/* Invalidate directory object */
000010  2000              MOVS     r0,#0
000012  6020              STR      r0,[r4,#0]
                  |L14.20|
;;;4175   		}
;;;4176   #if _FS_REENTRANT
;;;4177   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;4178   #endif
;;;4179   	}
;;;4180   	return res;
000014  4628              MOV      r0,r5
;;;4181   }
000016  bd38              POP      {r3-r5,pc}
;;;4182   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;4312   
;;;4313   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;4314   	const TCHAR* path,	/* Path name of the logical drive number */
;;;4315   	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;;;4316   	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;;;4317   )
;;;4318   {
000004  b086              SUB      sp,sp,#0x18
000006  4689              MOV      r9,r1
;;;4319   	FRESULT res;
;;;4320   	FATFS *fs;
;;;4321   	DWORD nfree, clst, sect, stat;
;;;4322   	UINT i;
;;;4323   	BYTE *p;
;;;4324   	_FDID obj;
;;;4325   
;;;4326   
;;;4327   	/* Get logical drive */
;;;4328   	res = find_volume(&path, &fs, 0);
000008  2200              MOVS     r2,#0
00000a  a905              ADD      r1,sp,#0x14
00000c  a806              ADD      r0,sp,#0x18
00000e  f7fffffe          BL       find_volume
000012  4682              MOV      r10,r0
;;;4329   	if (res == FR_OK) {
000014  f1ba0f00          CMP      r10,#0
000018  d16c              BNE      |L15.244|
;;;4330   		*fatfs = fs;				/* Return ptr to the fs object */
00001a  9905              LDR      r1,[sp,#0x14]
00001c  9808              LDR      r0,[sp,#0x20]
00001e  6001              STR      r1,[r0,#0]
;;;4331   		/* If free_clst is valid, return it without full cluster scan */
;;;4332   		if (fs->free_clst <= fs->n_fatent - 2) {
000020  9805              LDR      r0,[sp,#0x14]
000022  e9d01004          LDRD     r1,r0,[r0,#0x10]
000026  1e80              SUBS     r0,r0,#2
000028  4281              CMP      r1,r0
00002a  d804              BHI      |L15.54|
;;;4333   			*nclst = fs->free_clst;
00002c  9805              LDR      r0,[sp,#0x14]
00002e  6900              LDR      r0,[r0,#0x10]
000030  f8c90000          STR      r0,[r9,#0]
000034  e05e              B        |L15.244|
                  |L15.54|
;;;4334   		} else {
;;;4335   			/* Get number of free clusters */
;;;4336   			nfree = 0;
000036  2400              MOVS     r4,#0
;;;4337   			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
000038  9805              LDR      r0,[sp,#0x14]
00003a  7800              LDRB     r0,[r0,#0]
00003c  2801              CMP      r0,#1
00003e  d11b              BNE      |L15.120|
;;;4338   				clst = 2; obj.fs = fs;
000040  2502              MOVS     r5,#2
000042  9805              LDR      r0,[sp,#0x14]
000044  9001              STR      r0,[sp,#4]
;;;4339   				do {
000046  bf00              NOP      
                  |L15.72|
;;;4340   					stat = get_fat(&obj, clst);
000048  4629              MOV      r1,r5
00004a  a801              ADD      r0,sp,#4
00004c  f7fffffe          BL       get_fat
000050  4606              MOV      r6,r0
;;;4341   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
000052  1c70              ADDS     r0,r6,#1
000054  b910              CBNZ     r0,|L15.92|
000056  f04f0a01          MOV      r10,#1
00005a  e00c              B        |L15.118|
                  |L15.92|
;;;4342   					if (stat == 1) { res = FR_INT_ERR; break; }
00005c  2e01              CMP      r6,#1
00005e  d102              BNE      |L15.102|
000060  f04f0a02          MOV      r10,#2
000064  e007              B        |L15.118|
                  |L15.102|
;;;4343   					if (stat == 0) nfree++;
000066  b906              CBNZ     r6,|L15.106|
000068  1c64              ADDS     r4,r4,#1
                  |L15.106|
;;;4344   				} while (++clst < fs->n_fatent);
00006a  1c68              ADDS     r0,r5,#1
00006c  4605              MOV      r5,r0
00006e  9905              LDR      r1,[sp,#0x14]
000070  6949              LDR      r1,[r1,#0x14]
000072  4288              CMP      r0,r1
000074  d3e8              BCC      |L15.72|
                  |L15.118|
000076  e033              B        |L15.224|
                  |L15.120|
;;;4345   			} else {
;;;4346   #if _FS_EXFAT
;;;4347   				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan bitmap table */
;;;4348   					BYTE bm;
;;;4349   					UINT b;
;;;4350   
;;;4351   					clst = fs->n_fatent - 2;
;;;4352   					sect = fs->database;
;;;4353   					i = 0;
;;;4354   					do {
;;;4355   						if (i == 0 && (res = move_window(fs, sect++)) != FR_OK) break;
;;;4356   						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
;;;4357   							if (!(bm & 1)) nfree++;
;;;4358   							bm >>= 1;
;;;4359   						}
;;;4360   						i = (i + 1) % SS(fs);
;;;4361   					} while (clst);
;;;4362   				} else
;;;4363   #endif
;;;4364   				{	/* FAT16/32: Sector alighed FAT entries */
;;;4365   					clst = fs->n_fatent; sect = fs->fatbase;
000078  9805              LDR      r0,[sp,#0x14]
00007a  6945              LDR      r5,[r0,#0x14]
00007c  9805              LDR      r0,[sp,#0x14]
00007e  f8d0b020          LDR      r11,[r0,#0x20]
;;;4366   					i = 0; p = 0;
000082  2700              MOVS     r7,#0
000084  46b8              MOV      r8,r7
;;;4367   					do {
000086  bf00              NOP      
                  |L15.136|
;;;4368   						if (i == 0) {
000088  b97f              CBNZ     r7,|L15.170|
;;;4369   							res = move_window(fs, sect++);
00008a  4659              MOV      r1,r11
00008c  f10b0b01          ADD      r11,r11,#1
000090  9805              LDR      r0,[sp,#0x14]
000092  f7fffffe          BL       move_window
000096  4682              MOV      r10,r0
;;;4370   							if (res != FR_OK) break;
000098  f1ba0f00          CMP      r10,#0
00009c  d000              BEQ      |L15.160|
00009e  e01e              B        |L15.222|
                  |L15.160|
;;;4371   							p = fs->win;
0000a0  9805              LDR      r0,[sp,#0x14]
0000a2  f1000830          ADD      r8,r0,#0x30
;;;4372   							i = SS(fs);
0000a6  f44f7700          MOV      r7,#0x200
                  |L15.170|
;;;4373   						}
;;;4374   						if (fs->fs_type == FS_FAT16) {
0000aa  9805              LDR      r0,[sp,#0x14]
0000ac  7800              LDRB     r0,[r0,#0]
0000ae  2802              CMP      r0,#2
0000b0  d108              BNE      |L15.196|
;;;4375   							if (ld_word(p) == 0) nfree++;
0000b2  4640              MOV      r0,r8
0000b4  f7fffffe          BL       ld_word
0000b8  b900              CBNZ     r0,|L15.188|
0000ba  1c64              ADDS     r4,r4,#1
                  |L15.188|
;;;4376   							p += 2; i -= 2;
0000bc  f1080802          ADD      r8,r8,#2
0000c0  1ebf              SUBS     r7,r7,#2
0000c2  e009              B        |L15.216|
                  |L15.196|
;;;4377   						} else {
;;;4378   							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
0000c4  4640              MOV      r0,r8
0000c6  f7fffffe          BL       ld_dword
0000ca  f0204070          BIC      r0,r0,#0xf0000000
0000ce  b900              CBNZ     r0,|L15.210|
0000d0  1c64              ADDS     r4,r4,#1
                  |L15.210|
;;;4379   							p += 4; i -= 4;
0000d2  f1080804          ADD      r8,r8,#4
0000d6  1f3f              SUBS     r7,r7,#4
                  |L15.216|
;;;4380   						}
;;;4381   					} while (--clst);
0000d8  1e68              SUBS     r0,r5,#1
0000da  1e05              SUBS     r5,r0,#0
0000dc  d1d4              BNE      |L15.136|
                  |L15.222|
0000de  bf00              NOP                            ;4370
                  |L15.224|
;;;4382   				}
;;;4383   			}
;;;4384   			*nclst = nfree;			/* Return the free clusters */
0000e0  f8c94000          STR      r4,[r9,#0]
;;;4385   			fs->free_clst = nfree;	/* Now free_clst is valid */
0000e4  9805              LDR      r0,[sp,#0x14]
0000e6  6104              STR      r4,[r0,#0x10]
;;;4386   			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
0000e8  9805              LDR      r0,[sp,#0x14]
0000ea  7900              LDRB     r0,[r0,#4]
0000ec  f0400001          ORR      r0,r0,#1
0000f0  9905              LDR      r1,[sp,#0x14]
0000f2  7108              STRB     r0,[r1,#4]
                  |L15.244|
;;;4387   		}
;;;4388   	}
;;;4389   
;;;4390   	LEAVE_FF(fs, res);
0000f4  4650              MOV      r0,r10
;;;4391   }
0000f6  b009              ADD      sp,sp,#0x24
0000f8  e8bd8ff0          POP      {r4-r11,pc}
;;;4392   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;3932   
;;;3933   FRESULT f_lseek (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3934   	FIL* fp,		/* Pointer to the file object */
;;;3935   	FSIZE_t ofs		/* File pointer from top of file */
;;;3936   )
;;;3937   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;3938   	FRESULT res;
;;;3939   	FATFS *fs;
;;;3940   	DWORD clst, bcs, nsect;
;;;3941   	FSIZE_t ifptr;
;;;3942   #if _USE_FASTSEEK
;;;3943   	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;3944   #endif
;;;3945   
;;;3946   	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
000008  4669              MOV      r1,sp
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       validate
000010  4682              MOV      r10,r0
;;;3947   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
000012  f1ba0f00          CMP      r10,#0
000016  d103              BNE      |L16.32|
000018  7c60              LDRB     r0,[r4,#0x11]
00001a  f1b00a00          SUBS     r10,r0,#0
00001e  d002              BEQ      |L16.38|
                  |L16.32|
000020  4650              MOV      r0,r10
                  |L16.34|
;;;3948   #if _USE_FASTSEEK
;;;3949   	if (fp->cltbl) {	/* Fast seek */
;;;3950   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;3951   			tbl = fp->cltbl;
;;;3952   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;3953   			cl = fp->obj.sclust;		/* Origin of the chain */
;;;3954   			if (cl) {
;;;3955   				do {
;;;3956   					/* Get a fragment */
;;;3957   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;3958   					do {
;;;3959   						pcl = cl; ncl++;
;;;3960   						cl = get_fat(&fp->obj, cl);
;;;3961   						if (cl <= 1) ABORT(fs, FR_INT_ERR);
;;;3962   						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;3963   					} while (cl == pcl + 1);
;;;3964   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;3965   						*tbl++ = ncl; *tbl++ = tcl;
;;;3966   					}
;;;3967   				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
;;;3968   			}
;;;3969   			*fp->cltbl = ulen;	/* Number of items used */
;;;3970   			if (ulen <= tlen) {
;;;3971   				*tbl = 0;		/* Terminate table */
;;;3972   			} else {
;;;3973   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;3974   			}
;;;3975   		} else {						/* Fast seek */
;;;3976   			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
;;;3977   			fp->fptr = ofs;				/* Set file pointer */
;;;3978   			if (ofs) {
;;;3979   				fp->clust = clmt_clust(fp, ofs - 1);
;;;3980   				dsc = clust2sect(fs, fp->clust);
;;;3981   				if (!dsc) ABORT(fs, FR_INT_ERR);
;;;3982   				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
;;;3983   				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
;;;3984   #if !_FS_TINY
;;;3985   #if !_FS_READONLY
;;;3986   					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
;;;3987   						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3988   						fp->flag &= (BYTE)~FA_DIRTY;
;;;3989   					}
;;;3990   #endif
;;;3991   					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
;;;3992   #endif
;;;3993   					fp->sect = dsc;
;;;3994   				}
;;;3995   			}
;;;3996   		}
;;;3997   	} else
;;;3998   #endif
;;;3999   
;;;4000   	/* Normal Seek */
;;;4001   	{
;;;4002   #if _FS_EXFAT
;;;4003   		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
;;;4004   #endif
;;;4005   		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
;;;4006   			ofs = fp->obj.objsize;
;;;4007   		}
;;;4008   		ifptr = fp->fptr;
;;;4009   		fp->fptr = nsect = 0;
;;;4010   		if (ofs) {
;;;4011   			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
;;;4012   			if (ifptr > 0 &&
;;;4013   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;4014   				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
;;;4015   				ofs -= fp->fptr;
;;;4016   				clst = fp->clust;
;;;4017   			} else {									/* When seek to back cluster, */
;;;4018   				clst = fp->obj.sclust;					/* start from the first cluster */
;;;4019   #if !_FS_READONLY
;;;4020   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;4021   					clst = create_chain(&fp->obj, 0);
;;;4022   					if (clst == 1) ABORT(fs, FR_INT_ERR);
;;;4023   					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;4024   					fp->obj.sclust = clst;
;;;4025   				}
;;;4026   #endif
;;;4027   				fp->clust = clst;
;;;4028   			}
;;;4029   			if (clst != 0) {
;;;4030   				while (ofs > bcs) {						/* Cluster following loop */
;;;4031   					ofs -= bcs; fp->fptr += bcs;
;;;4032   #if !_FS_READONLY
;;;4033   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;4034   						if (_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
;;;4035   							fp->obj.objsize = fp->fptr;
;;;4036   							fp->flag |= FA_MODIFIED;
;;;4037   						}
;;;4038   						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
;;;4039   						if (clst == 0) {				/* Clip file size in case of disk full */
;;;4040   							ofs = 0; break;
;;;4041   						}
;;;4042   					} else
;;;4043   #endif
;;;4044   					{
;;;4045   						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
;;;4046   					}
;;;4047   					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;4048   					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
;;;4049   					fp->clust = clst;
;;;4050   				}
;;;4051   				fp->fptr += ofs;
;;;4052   				if (ofs % SS(fs)) {
;;;4053   					nsect = clust2sect(fs, clst);	/* Current sector */
;;;4054   					if (!nsect) ABORT(fs, FR_INT_ERR);
;;;4055   					nsect += (DWORD)(ofs / SS(fs));
;;;4056   				}
;;;4057   			}
;;;4058   		}
;;;4059   		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
;;;4060   			fp->obj.objsize = fp->fptr;
;;;4061   			fp->flag |= FA_MODIFIED;
;;;4062   		}
;;;4063   		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
;;;4064   #if !_FS_TINY
;;;4065   #if !_FS_READONLY
;;;4066   			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
;;;4067   				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;4068   				fp->flag &= (BYTE)~FA_DIRTY;
;;;4069   			}
;;;4070   #endif
;;;4071   			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
;;;4072   #endif
;;;4073   			fp->sect = nsect;
;;;4074   		}
;;;4075   	}
;;;4076   
;;;4077   	LEAVE_FF(fs, res);
;;;4078   }
000022  e8bd8ff8          POP      {r3-r11,pc}
                  |L16.38|
000026  68e0              LDR      r0,[r4,#0xc]          ;4005
000028  42b0              CMP      r0,r6                 ;4005
00002a  d204              BCS      |L16.54|
00002c  7c20              LDRB     r0,[r4,#0x10]         ;4005
00002e  f0000002          AND      r0,r0,#2              ;4005
000032  b900              CBNZ     r0,|L16.54|
000034  68e6              LDR      r6,[r4,#0xc]          ;4006
                  |L16.54|
000036  f8d49014          LDR      r9,[r4,#0x14]         ;4008
00003a  f04f0800          MOV      r8,#0                 ;4009
00003e  f8c48014          STR      r8,[r4,#0x14]         ;4009
000042  2e00              CMP      r6,#0                 ;4010
000044  d068              BEQ      |L16.280|
000046  9800              LDR      r0,[sp,#0]            ;4011
000048  8940              LDRH     r0,[r0,#0xa]          ;4011
00004a  0247              LSLS     r7,r0,#9              ;4011
00004c  f1b90f00          CMP      r9,#0                 ;4012
000050  d011              BEQ      |L16.118|
000052  1e70              SUBS     r0,r6,#1              ;4013
000054  fbb0f1f7          UDIV     r1,r0,r7              ;4013
000058  f1a90001          SUB      r0,r9,#1              ;4013
00005c  fbb0f0f7          UDIV     r0,r0,r7              ;4013
000060  4281              CMP      r1,r0                 ;4013
000062  d308              BCC      |L16.118|
000064  f1a90001          SUB      r0,r9,#1              ;4014
000068  1e79              SUBS     r1,r7,#1              ;4014
00006a  4388              BICS     r0,r0,r1              ;4014
00006c  6160              STR      r0,[r4,#0x14]         ;4014
00006e  6960              LDR      r0,[r4,#0x14]         ;4015
000070  1a36              SUBS     r6,r6,r0              ;4015
000072  69a5              LDR      r5,[r4,#0x18]         ;4016
000074  e012              B        |L16.156|
                  |L16.118|
000076  68a5              LDR      r5,[r4,#8]            ;4018
000078  b97d              CBNZ     r5,|L16.154|
00007a  2100              MOVS     r1,#0                 ;4021
00007c  4620              MOV      r0,r4                 ;4021
00007e  f7fffffe          BL       create_chain
000082  4605              MOV      r5,r0                 ;4021
000084  2d01              CMP      r5,#1                 ;4022
000086  d102              BNE      |L16.142|
000088  2002              MOVS     r0,#2                 ;4022
00008a  7460              STRB     r0,[r4,#0x11]         ;4022
00008c  e7c9              B        |L16.34|
                  |L16.142|
00008e  1c68              ADDS     r0,r5,#1              ;4023
000090  b910              CBNZ     r0,|L16.152|
000092  2001              MOVS     r0,#1                 ;4023
000094  7460              STRB     r0,[r4,#0x11]         ;4023
000096  e7c4              B        |L16.34|
                  |L16.152|
000098  60a5              STR      r5,[r4,#8]            ;4024
                  |L16.154|
00009a  61a5              STR      r5,[r4,#0x18]         ;4027
                  |L16.156|
00009c  2d00              CMP      r5,#0                 ;4029
00009e  d03b              BEQ      |L16.280|
0000a0  e024              B        |L16.236|
                  |L16.162|
0000a2  1bf6              SUBS     r6,r6,r7              ;4031
0000a4  6960              LDR      r0,[r4,#0x14]         ;4031
0000a6  4438              ADD      r0,r0,r7              ;4031
0000a8  6160              STR      r0,[r4,#0x14]         ;4031
0000aa  7c20              LDRB     r0,[r4,#0x10]         ;4033
0000ac  f0000002          AND      r0,r0,#2              ;4033
0000b0  b140              CBZ      r0,|L16.196|
0000b2  bf00              NOP                            ;4034
0000b4  4629              MOV      r1,r5                 ;4038
0000b6  4620              MOV      r0,r4                 ;4038
0000b8  f7fffffe          BL       create_chain
0000bc  4605              MOV      r5,r0                 ;4038
0000be  b935              CBNZ     r5,|L16.206|
0000c0  2600              MOVS     r6,#0                 ;4040
0000c2  e015              B        |L16.240|
                  |L16.196|
0000c4  4629              MOV      r1,r5                 ;4045
0000c6  4620              MOV      r0,r4                 ;4045
0000c8  f7fffffe          BL       get_fat
0000cc  4605              MOV      r5,r0                 ;4045
                  |L16.206|
0000ce  1c68              ADDS     r0,r5,#1              ;4047
0000d0  b910              CBNZ     r0,|L16.216|
0000d2  2001              MOVS     r0,#1                 ;4047
0000d4  7460              STRB     r0,[r4,#0x11]         ;4047
0000d6  e7a4              B        |L16.34|
                  |L16.216|
0000d8  2d01              CMP      r5,#1                 ;4048
0000da  d903              BLS      |L16.228|
0000dc  9800              LDR      r0,[sp,#0]            ;4048
0000de  6940              LDR      r0,[r0,#0x14]         ;4048
0000e0  42a8              CMP      r0,r5                 ;4048
0000e2  d802              BHI      |L16.234|
                  |L16.228|
0000e4  2002              MOVS     r0,#2                 ;4048
0000e6  7460              STRB     r0,[r4,#0x11]         ;4048
0000e8  e79b              B        |L16.34|
                  |L16.234|
0000ea  61a5              STR      r5,[r4,#0x18]         ;4049
                  |L16.236|
0000ec  42be              CMP      r6,r7                 ;4030
0000ee  d8d8              BHI      |L16.162|
                  |L16.240|
0000f0  bf00              NOP                            ;4040
0000f2  6960              LDR      r0,[r4,#0x14]         ;4051
0000f4  4430              ADD      r0,r0,r6              ;4051
0000f6  6160              STR      r0,[r4,#0x14]         ;4051
0000f8  f3c60008          UBFX     r0,r6,#0,#9           ;4052
0000fc  b160              CBZ      r0,|L16.280|
0000fe  4629              MOV      r1,r5                 ;4053
000100  9800              LDR      r0,[sp,#0]            ;4053
000102  f7fffffe          BL       clust2sect
000106  4680              MOV      r8,r0                 ;4053
000108  f1b80f00          CMP      r8,#0                 ;4054
00010c  d102              BNE      |L16.276|
00010e  2002              MOVS     r0,#2                 ;4054
000110  7460              STRB     r0,[r4,#0x11]         ;4054
000112  e786              B        |L16.34|
                  |L16.276|
000114  eb082856          ADD      r8,r8,r6,LSR #9       ;4055
                  |L16.280|
000118  68e1              LDR      r1,[r4,#0xc]          ;4059
00011a  6960              LDR      r0,[r4,#0x14]         ;4059
00011c  4288              CMP      r0,r1                 ;4059
00011e  d905              BLS      |L16.300|
000120  6960              LDR      r0,[r4,#0x14]         ;4060
000122  60e0              STR      r0,[r4,#0xc]          ;4060
000124  7c20              LDRB     r0,[r4,#0x10]         ;4061
000126  f0400040          ORR      r0,r0,#0x40           ;4061
00012a  7420              STRB     r0,[r4,#0x10]         ;4061
                  |L16.300|
00012c  8aa0              LDRH     r0,[r4,#0x14]         ;4063
00012e  f3c00008          UBFX     r0,r0,#0,#9           ;4063
000132  b320              CBZ      r0,|L16.382|
000134  69e0              LDR      r0,[r4,#0x1c]         ;4063
000136  4540              CMP      r0,r8                 ;4063
000138  d021              BEQ      |L16.382|
00013a  7c20              LDRB     r0,[r4,#0x10]         ;4066
00013c  f0000080          AND      r0,r0,#0x80           ;4066
000140  b178              CBZ      r0,|L16.354|
000142  69e2              LDR      r2,[r4,#0x1c]         ;4067
000144  9900              LDR      r1,[sp,#0]            ;4067
000146  7848              LDRB     r0,[r1,#1]            ;4067
000148  2301              MOVS     r3,#1                 ;4067
00014a  f1040128          ADD      r1,r4,#0x28           ;4067
00014e  f7fffffe          BL       disk_write
000152  b110              CBZ      r0,|L16.346|
000154  2001              MOVS     r0,#1                 ;4067
000156  7460              STRB     r0,[r4,#0x11]         ;4067
000158  e763              B        |L16.34|
                  |L16.346|
00015a  7c20              LDRB     r0,[r4,#0x10]         ;4068
00015c  f000007f          AND      r0,r0,#0x7f           ;4068
000160  7420              STRB     r0,[r4,#0x10]         ;4068
                  |L16.354|
000162  9900              LDR      r1,[sp,#0]            ;4071
000164  7848              LDRB     r0,[r1,#1]            ;4071
000166  2301              MOVS     r3,#1                 ;4071
000168  4642              MOV      r2,r8                 ;4071
00016a  f1040128          ADD      r1,r4,#0x28           ;4071
00016e  f7fffffe          BL       disk_read
000172  b110              CBZ      r0,|L16.378|
000174  2001              MOVS     r0,#1                 ;4071
000176  7460              STRB     r0,[r4,#0x11]         ;4071
000178  e753              B        |L16.34|
                  |L16.378|
00017a  f8c4801c          STR      r8,[r4,#0x1c]         ;4073
                  |L16.382|
00017e  4650              MOV      r0,r10                ;4077
000180  e74f              B        |L16.34|
;;;4079   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;4544   
;;;4545   FRESULT f_mkdir (
000000  e92d47f1          PUSH     {r0,r4-r10,lr}
;;;4546   	const TCHAR* path		/* Pointer to the directory path */
;;;4547   )
;;;4548   {
000004  b08d              SUB      sp,sp,#0x34
;;;4549   	FRESULT res;
;;;4550   	DIR dj;
;;;4551   	FATFS *fs;
;;;4552   	BYTE *dir;
;;;4553   	UINT n;
;;;4554   	DWORD dsc, dcl, pcl, tm;
;;;4555   	DEF_NAMBUF
;;;4556   
;;;4557   
;;;4558   	/* Get logical drive */
;;;4559   	res = find_volume(&path, &fs, FA_WRITE);
000006  2202              MOVS     r2,#2
000008  a901              ADD      r1,sp,#4
00000a  a80d              ADD      r0,sp,#0x34
00000c  f7fffffe          BL       find_volume
000010  4605              MOV      r5,r0
;;;4560   	dj.obj.fs = fs;
000012  9801              LDR      r0,[sp,#4]
000014  9002              STR      r0,[sp,#8]
;;;4561   	if (res == FR_OK) {
000016  2d00              CMP      r5,#0
                  |L17.24|
000018  d171              BNE      |L17.254|
;;;4562   		INIT_NAMBUF(fs);
;;;4563   		res = follow_path(&dj, path);			/* Follow the file path */
00001a  a802              ADD      r0,sp,#8
00001c  990d              LDR      r1,[sp,#0x34]
00001e  f7fffffe          BL       follow_path
000022  4605              MOV      r5,r0
;;;4564   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
000024  b905              CBNZ     r5,|L17.40|
000026  2508              MOVS     r5,#8
                  |L17.40|
;;;4565   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
000028  bf00              NOP      
;;;4566   			res = FR_INVALID_NAME;
;;;4567   		}
;;;4568   		if (res == FR_NO_FILE) {				/* Can create a new directory */
00002a  2d04              CMP      r5,#4
00002c  d1f4              BNE      |L17.24|
;;;4569   			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
00002e  2100              MOVS     r1,#0
000030  a802              ADD      r0,sp,#8
000032  f7fffffe          BL       create_chain
000036  4606              MOV      r6,r0
;;;4570   			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
000038  9801              LDR      r0,[sp,#4]
00003a  8940              LDRH     r0,[r0,#0xa]
00003c  0240              LSLS     r0,r0,#9
00003e  9005              STR      r0,[sp,#0x14]
;;;4571   			res = FR_OK;
000040  2500              MOVS     r5,#0
;;;4572   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000042  b906              CBNZ     r6,|L17.70|
000044  2507              MOVS     r5,#7
                  |L17.70|
;;;4573   			if (dcl == 1) res = FR_INT_ERR;
000046  2e01              CMP      r6,#1
000048  d100              BNE      |L17.76|
00004a  2502              MOVS     r5,#2
                  |L17.76|
;;;4574   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
00004c  1c70              ADDS     r0,r6,#1
00004e  b900              CBNZ     r0,|L17.82|
000050  2501              MOVS     r5,#1
                  |L17.82|
;;;4575   			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
000052  b91d              CBNZ     r5,|L17.92|
000054  9801              LDR      r0,[sp,#4]
000056  f7fffffe          BL       sync_window
00005a  4605              MOV      r5,r0
                  |L17.92|
;;;4576   			tm = GET_FATTIME();
00005c  f7fffffe          BL       get_fattime
000060  4682              MOV      r10,r0
;;;4577   			if (res == FR_OK) {					/* Initialize the new directory table */
000062  2d00              CMP      r5,#0
000064  d156              BNE      |L17.276|
;;;4578   				dsc = clust2sect(fs, dcl);
000066  4631              MOV      r1,r6
000068  9801              LDR      r0,[sp,#4]
00006a  f7fffffe          BL       clust2sect
00006e  4680              MOV      r8,r0
;;;4579   				dir = fs->win;
000070  9801              LDR      r0,[sp,#4]
000072  f1000430          ADD      r4,r0,#0x30
;;;4580   				mem_set(dir, 0, SS(fs));
000076  f44f7200          MOV      r2,#0x200
00007a  2100              MOVS     r1,#0
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       mem_set
;;;4581   				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
;;;4582   					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
000082  220b              MOVS     r2,#0xb
000084  2120              MOVS     r1,#0x20
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       mem_set
;;;4583   					dir[DIR_Name] = '.';
00008c  202e              MOVS     r0,#0x2e
00008e  7020              STRB     r0,[r4,#0]
;;;4584   					dir[DIR_Attr] = AM_DIR;
000090  2010              MOVS     r0,#0x10
000092  72e0              STRB     r0,[r4,#0xb]
;;;4585   					st_dword(dir + DIR_ModTime, tm);
000094  4651              MOV      r1,r10
000096  f1040016          ADD      r0,r4,#0x16
00009a  f7fffffe          BL       st_dword
;;;4586   					st_clust(fs, dir, dcl);
00009e  4632              MOV      r2,r6
0000a0  4621              MOV      r1,r4
0000a2  9801              LDR      r0,[sp,#4]
0000a4  f7fffffe          BL       st_clust
;;;4587   					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
0000a8  2220              MOVS     r2,#0x20
0000aa  4621              MOV      r1,r4
0000ac  f1040020          ADD      r0,r4,#0x20
0000b0  f7fffffe          BL       mem_cpy
;;;4588   					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
0000b4  202e              MOVS     r0,#0x2e
0000b6  f8840021          STRB     r0,[r4,#0x21]
0000ba  f8dd9010          LDR      r9,[sp,#0x10]
;;;4589   					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
0000be  9801              LDR      r0,[sp,#4]
0000c0  7800              LDRB     r0,[r0,#0]
0000c2  2803              CMP      r0,#3
0000c4  d104              BNE      |L17.208|
0000c6  9801              LDR      r0,[sp,#4]
0000c8  6a40              LDR      r0,[r0,#0x24]
0000ca  4548              CMP      r0,r9
0000cc  d100              BNE      |L17.208|
0000ce  46a9              MOV      r9,r5
                  |L17.208|
;;;4590   					st_clust(fs, dir + SZDIRE, pcl);
0000d0  464a              MOV      r2,r9
0000d2  f1040120          ADD      r1,r4,#0x20
0000d6  9801              LDR      r0,[sp,#4]
0000d8  f7fffffe          BL       st_clust
;;;4591   				}
;;;4592   				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
0000dc  9801              LDR      r0,[sp,#4]
0000de  8947              LDRH     r7,[r0,#0xa]
0000e0  e015              B        |L17.270|
                  |L17.226|
;;;4593   					fs->winsect = dsc++;
0000e2  9801              LDR      r0,[sp,#4]
0000e4  f8c0802c          STR      r8,[r0,#0x2c]
0000e8  f1080801          ADD      r8,r8,#1
;;;4594   					fs->wflag = 1;
0000ec  2001              MOVS     r0,#1
0000ee  9901              LDR      r1,[sp,#4]
0000f0  70c8              STRB     r0,[r1,#3]
;;;4595   					res = sync_window(fs);
0000f2  9801              LDR      r0,[sp,#4]
0000f4  f7fffffe          BL       sync_window
0000f8  4605              MOV      r5,r0
;;;4596   					if (res != FR_OK) break;
0000fa  b10d              CBZ      r5,|L17.256|
0000fc  e009              B        |L17.274|
                  |L17.254|
0000fe  e02a              B        |L17.342|
                  |L17.256|
;;;4597   					mem_set(dir, 0, SS(fs));
000100  f44f7200          MOV      r2,#0x200
000104  2100              MOVS     r1,#0
000106  4620              MOV      r0,r4
000108  f7fffffe          BL       mem_set
00010c  1e7f              SUBS     r7,r7,#1              ;4592
                  |L17.270|
00010e  2f00              CMP      r7,#0                 ;4592
000110  d1e7              BNE      |L17.226|
                  |L17.274|
000112  bf00              NOP                            ;4596
                  |L17.276|
;;;4598   				}
;;;4599   			}
;;;4600   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
000114  b91d              CBNZ     r5,|L17.286|
000116  a802              ADD      r0,sp,#8
000118  f7fffffe          BL       dir_register
00011c  4605              MOV      r5,r0
                  |L17.286|
;;;4601   			if (res == FR_OK) {
00011e  b9ad              CBNZ     r5,|L17.332|
;;;4602   #if _FS_EXFAT
;;;4603   				if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
;;;4604   					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
;;;4605   					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
;;;4606   					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
;;;4607   					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
;;;4608   					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag (contiguous) */
;;;4609   					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
;;;4610   					res = store_xdir(&dj);
;;;4611   				} else
;;;4612   #endif
;;;4613   				{
;;;4614   					dir = dj.dir;
000120  9c09              LDR      r4,[sp,#0x24]
;;;4615   					st_dword(dir + DIR_ModTime, tm);	/* Created time */
000122  4651              MOV      r1,r10
000124  f1040016          ADD      r0,r4,#0x16
000128  f7fffffe          BL       st_dword
;;;4616   					st_clust(fs, dir, dcl);				/* Table start cluster */
00012c  4632              MOV      r2,r6
00012e  4621              MOV      r1,r4
000130  9801              LDR      r0,[sp,#4]
000132  f7fffffe          BL       st_clust
;;;4617   					dir[DIR_Attr] = AM_DIR;				/* Attribute */
000136  2010              MOVS     r0,#0x10
000138  72e0              STRB     r0,[r4,#0xb]
;;;4618   					fs->wflag = 1;
00013a  2001              MOVS     r0,#1
00013c  9901              LDR      r1,[sp,#4]
00013e  70c8              STRB     r0,[r1,#3]
;;;4619   				}
;;;4620   				if (res == FR_OK) res = sync_fs(fs);
000140  b94d              CBNZ     r5,|L17.342|
000142  9801              LDR      r0,[sp,#4]
000144  f7fffffe          BL       sync_fs
000148  4605              MOV      r5,r0
00014a  e004              B        |L17.342|
                  |L17.332|
;;;4621   			} else {
;;;4622   				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
00014c  2200              MOVS     r2,#0
00014e  4631              MOV      r1,r6
000150  a802              ADD      r0,sp,#8
000152  f7fffffe          BL       remove_chain
                  |L17.342|
;;;4623   			}
;;;4624   		}
;;;4625   		FREE_NAMBUF();
;;;4626   	}
;;;4627   
;;;4628   	LEAVE_FF(fs, res);
000156  4628              MOV      r0,r5
;;;4629   }
000158  b00e              ADD      sp,sp,#0x38
00015a  e8bd87f0          POP      {r4-r10,pc}
;;;4630   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;3196   
;;;3197   FRESULT f_mount (
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;3198   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;3199   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;3200   	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
;;;3201   )
;;;3202   {
000002  b082              SUB      sp,sp,#8
000004  4616              MOV      r6,r2
;;;3203   	FATFS *cfs;
;;;3204   	int vol;
;;;3205   	FRESULT res;
;;;3206   	const TCHAR *rp = path;
000006  9803              LDR      r0,[sp,#0xc]
000008  9001              STR      r0,[sp,#4]
;;;3207   
;;;3208   
;;;3209   	/* Get logical drive number */
;;;3210   	vol = get_ldnumber(&rp);
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       get_ldnumber
000010  4605              MOV      r5,r0
;;;3211   	if (vol < 0) return FR_INVALID_DRIVE;
000012  2d00              CMP      r5,#0
000014  da02              BGE      |L18.28|
000016  200b              MOVS     r0,#0xb
                  |L18.24|
;;;3212   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;3213   
;;;3214   	if (cfs) {
;;;3215   #if _FS_LOCK != 0
;;;3216   		clear_lock(cfs);
;;;3217   #endif
;;;3218   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;3219   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;3220   #endif
;;;3221   		cfs->fs_type = 0;				/* Clear old fs object */
;;;3222   	}
;;;3223   
;;;3224   	if (fs) {
;;;3225   		fs->fs_type = 0;				/* Clear new fs object */
;;;3226   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;3227   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;3228   #endif
;;;3229   	}
;;;3230   	FatFs[vol] = fs;					/* Register new fs object */
;;;3231   
;;;3232   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;3233   
;;;3234   	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
;;;3235   	LEAVE_FF(fs, res);
;;;3236   }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L18.28|
00001c  480e              LDR      r0,|L18.88|
00001e  f8504025          LDR      r4,[r0,r5,LSL #2]     ;3212
000022  b10c              CBZ      r4,|L18.40|
000024  2000              MOVS     r0,#0                 ;3221
000026  7020              STRB     r0,[r4,#0]            ;3221
                  |L18.40|
000028  9802              LDR      r0,[sp,#8]            ;3224
00002a  b110              CBZ      r0,|L18.50|
00002c  2000              MOVS     r0,#0                 ;3225
00002e  9902              LDR      r1,[sp,#8]            ;3225
000030  7008              STRB     r0,[r1,#0]            ;3225
                  |L18.50|
000032  4909              LDR      r1,|L18.88|
000034  9802              LDR      r0,[sp,#8]            ;3230
000036  f8410025          STR      r0,[r1,r5,LSL #2]     ;3230
00003a  9802              LDR      r0,[sp,#8]            ;3232
00003c  b108              CBZ      r0,|L18.66|
00003e  2e01              CMP      r6,#1                 ;3232
000040  d001              BEQ      |L18.70|
                  |L18.66|
000042  2000              MOVS     r0,#0                 ;3232
000044  e7e8              B        |L18.24|
                  |L18.70|
000046  2200              MOVS     r2,#0                 ;3234
000048  a902              ADD      r1,sp,#8              ;3234
00004a  a803              ADD      r0,sp,#0xc            ;3234
00004c  f7fffffe          BL       find_volume
000050  4607              MOV      r7,r0                 ;3234
000052  4638              MOV      r0,r7                 ;3235
000054  e7e0              B        |L18.24|
;;;3237   
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      FatFs

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;3244   
;;;3245   FRESULT f_open (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3246   	FIL* fp,			/* Pointer to the blank file object */
;;;3247   	const TCHAR* path,	/* Pointer to the file name */
;;;3248   	BYTE mode			/* Access mode and file open mode flags */
;;;3249   )
;;;3250   {
000004  b08e              SUB      sp,sp,#0x38
000006  4604              MOV      r4,r0
000008  4616              MOV      r6,r2
;;;3251   	FRESULT res;
;;;3252   	DIR dj;
;;;3253   	FATFS *fs;
;;;3254   #if !_FS_READONLY
;;;3255   	DWORD dw, cl, bcs, clst, sc;
;;;3256   	FSIZE_t ofs;
;;;3257   #endif
;;;3258   	DEF_NAMBUF
;;;3259   
;;;3260   
;;;3261   	if (!fp) return FR_INVALID_OBJECT;
00000a  b91c              CBNZ     r4,|L19.20|
00000c  2009              MOVS     r0,#9
                  |L19.14|
;;;3262   
;;;3263   	/* Get logical drive */
;;;3264   	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
;;;3265   	res = find_volume(&path, &fs, mode);
;;;3266   	if (res == FR_OK) {
;;;3267   		dj.obj.fs = fs;
;;;3268   		INIT_NAMBUF(fs);
;;;3269   		res = follow_path(&dj, path);	/* Follow the file path */
;;;3270   #if !_FS_READONLY	/* R/W configuration */
;;;3271   		if (res == FR_OK) {
;;;3272   			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
;;;3273   				res = FR_INVALID_NAME;
;;;3274   			}
;;;3275   #if _FS_LOCK != 0
;;;3276   			else {
;;;3277   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;3278   			}
;;;3279   #endif
;;;3280   		}
;;;3281   		/* Create or Open a file */
;;;3282   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;3283   			if (res != FR_OK) {					/* No file, create new */
;;;3284   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;3285   #if _FS_LOCK != 0
;;;3286   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;3287   #else
;;;3288   					res = dir_register(&dj);
;;;3289   #endif
;;;3290   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;3291   			}
;;;3292   			else {								/* Any object is already existing */
;;;3293   				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;3294   					res = FR_DENIED;
;;;3295   				} else {
;;;3296   					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
;;;3297   				}
;;;3298   			}
;;;3299   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;3300   				dw = GET_FATTIME();
;;;3301   #if _FS_EXFAT
;;;3302   				if (fs->fs_type == FS_EXFAT) {
;;;3303   					/* Get current allocation info */
;;;3304   					fp->obj.fs = fs;
;;;3305   					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
;;;3306   					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;3307   					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;3308   					/* Initialize directory entry block */
;;;3309   					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
;;;3310   					fs->dirbuf[XDIR_CrtTime10] = 0;
;;;3311   					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
;;;3312   					fs->dirbuf[XDIR_ModTime10] = 0;
;;;3313   					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
;;;3314   					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
;;;3315   					st_qword(fs->dirbuf + XDIR_FileSize, 0);
;;;3316   					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
;;;3317   					fs->dirbuf[XDIR_GenFlags] = 1;
;;;3318   					res = store_xdir(&dj);
;;;3319   					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
;;;3320   						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
;;;3321   						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
;;;3322   					}
;;;3323   				} else
;;;3324   #endif
;;;3325   				{
;;;3326   					/* Clean directory info */
;;;3327   					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
;;;3328   					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
;;;3329   					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
;;;3330   					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
;;;3331   					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
;;;3332   					st_dword(dj.dir + DIR_FileSize, 0);
;;;3333   					fs->wflag = 1;
;;;3334   
;;;3335   					if (cl) {							/* Remove the cluster chain if exist */
;;;3336   						dw = fs->winsect;
;;;3337   						res = remove_chain(&dj.obj, cl, 0);
;;;3338   						if (res == FR_OK) {
;;;3339   							res = move_window(fs, dw);
;;;3340   							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
;;;3341   						}
;;;3342   					}
;;;3343   				}
;;;3344   			}
;;;3345   		}
;;;3346   		else {	/* Open an existing file */
;;;3347   			if (res == FR_OK) {					/* Following succeeded */
;;;3348   				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
;;;3349   					res = FR_NO_FILE;
;;;3350   				} else {
;;;3351   					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
;;;3352   						res = FR_DENIED;
;;;3353   					}
;;;3354   				}
;;;3355   			}
;;;3356   		}
;;;3357   		if (res == FR_OK) {
;;;3358   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;3359   				mode |= FA_MODIFIED;
;;;3360   			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
;;;3361   			fp->dir_ptr = dj.dir;
;;;3362   #if _FS_LOCK != 0
;;;3363   			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;3364   			if (!fp->obj.lockid) res = FR_INT_ERR;
;;;3365   #endif
;;;3366   		}
;;;3367   #else		/* R/O configuration */
;;;3368   		if (res == FR_OK) {
;;;3369   			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
;;;3370   				res = FR_INVALID_NAME;
;;;3371   			} else {
;;;3372   				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
;;;3373   					res = FR_NO_FILE;
;;;3374   				}
;;;3375   			}
;;;3376   		}
;;;3377   #endif
;;;3378   
;;;3379   		if (res == FR_OK) {
;;;3380   #if _FS_EXFAT
;;;3381   			if (fs->fs_type == FS_EXFAT) {
;;;3382   				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Get allocation info */
;;;3383   				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;3384   				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;3385   				fp->obj.c_scl = dj.obj.sclust;
;;;3386   				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
;;;3387   				fp->obj.c_ofs = dj.blk_ofs;
;;;3388   			} else
;;;3389   #endif
;;;3390   			{
;;;3391   				fp->obj.sclust = ld_clust(fs, dj.dir);				/* Get allocation info */
;;;3392   				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
;;;3393   			}
;;;3394   #if _USE_FASTSEEK
;;;3395   			fp->cltbl = 0;			/* Disable fast seek mode */
;;;3396   #endif
;;;3397   			fp->obj.fs = fs;	 	/* Validate the file object */
;;;3398   			fp->obj.id = fs->id;
;;;3399   			fp->flag = mode;		/* Set file access mode */
;;;3400   			fp->err = 0;			/* Clear error flag */
;;;3401   			fp->sect = 0;			/* Invalidate current data sector */
;;;3402   			fp->fptr = 0;			/* Set file pointer top of the file */
;;;3403   #if !_FS_READONLY
;;;3404   #if !_FS_TINY
;;;3405   			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
;;;3406   #endif
;;;3407   			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
;;;3408   				fp->fptr = fp->obj.objsize;			/* Offset to seek */
;;;3409   				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
;;;3410   				clst = fp->obj.sclust;				/* Follow the cluster chain */
;;;3411   				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
;;;3412   					clst = get_fat(&fp->obj, clst);
;;;3413   					if (clst <= 1) res = FR_INT_ERR;
;;;3414   					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;3415   				}
;;;3416   				fp->clust = clst;
;;;3417   				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
;;;3418   					if ((sc = clust2sect(fs, clst)) == 0) {
;;;3419   						res = FR_INT_ERR;
;;;3420   					} else {
;;;3421   						fp->sect = sc + (DWORD)(ofs / SS(fs));
;;;3422   #if !_FS_TINY
;;;3423   						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
;;;3424   #endif
;;;3425   					}
;;;3426   				}
;;;3427   			}
;;;3428   #endif
;;;3429   		}
;;;3430   
;;;3431   		FREE_NAMBUF();
;;;3432   	}
;;;3433   
;;;3434   	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
;;;3435   
;;;3436   	LEAVE_FF(fs, res);
;;;3437   }
00000e  b011              ADD      sp,sp,#0x44
000010  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.20|
000014  f006063f          AND      r6,r6,#0x3f           ;3264
000018  4632              MOV      r2,r6                 ;3265
00001a  a902              ADD      r1,sp,#8              ;3265
00001c  a80f              ADD      r0,sp,#0x3c           ;3265
00001e  f7fffffe          BL       find_volume
000022  4605              MOV      r5,r0                 ;3265
000024  2d00              CMP      r5,#0                 ;3266
000026  d170              BNE      |L19.266|
000028  9802              LDR      r0,[sp,#8]            ;3267
00002a  9003              STR      r0,[sp,#0xc]          ;3267
00002c  a803              ADD      r0,sp,#0xc            ;3269
00002e  990f              LDR      r1,[sp,#0x3c]         ;3269
000030  f7fffffe          BL       follow_path
000034  4605              MOV      r5,r0                 ;3269
000036  b92d              CBNZ     r5,|L19.68|
000038  f89d0037          LDRB     r0,[sp,#0x37]         ;3272
00003c  f0000080          AND      r0,r0,#0x80           ;3272
000040  b100              CBZ      r0,|L19.68|
000042  2506              MOVS     r5,#6                 ;3273
                  |L19.68|
000044  f006001c          AND      r0,r6,#0x1c           ;3282
000048  2800              CMP      r0,#0                 ;3282
00004a  d056              BEQ      |L19.250|
00004c  b145              CBZ      r5,|L19.96|
00004e  2d04              CMP      r5,#4                 ;3284
000050  d103              BNE      |L19.90|
000052  a803              ADD      r0,sp,#0xc            ;3288
000054  f7fffffe          BL       dir_register
000058  4605              MOV      r5,r0                 ;3288
                  |L19.90|
00005a  f0460608          ORR      r6,r6,#8              ;3290
00005e  e00a              B        |L19.118|
                  |L19.96|
000060  f89d0012          LDRB     r0,[sp,#0x12]         ;3293
000064  f0000011          AND      r0,r0,#0x11           ;3293
000068  b108              CBZ      r0,|L19.110|
00006a  2507              MOVS     r5,#7                 ;3294
00006c  e003              B        |L19.118|
                  |L19.110|
00006e  f0060004          AND      r0,r6,#4              ;3296
000072  b100              CBZ      r0,|L19.118|
000074  2508              MOVS     r5,#8                 ;3296
                  |L19.118|
000076  2d00              CMP      r5,#0                 ;3299
000078  d151              BNE      |L19.286|
00007a  f0060008          AND      r0,r6,#8              ;3299
00007e  2800              CMP      r0,#0                 ;3299
000080  d04d              BEQ      |L19.286|
000082  f7fffffe          BL       get_fattime
000086  9001              STR      r0,[sp,#4]            ;3300
000088  990a              LDR      r1,[sp,#0x28]         ;3327
00008a  f101000e          ADD      r0,r1,#0xe            ;3327
00008e  9901              LDR      r1,[sp,#4]            ;3327
000090  f7fffffe          BL       st_dword
000094  990a              LDR      r1,[sp,#0x28]         ;3328
000096  f1010016          ADD      r0,r1,#0x16           ;3328
00009a  9901              LDR      r1,[sp,#4]            ;3328
00009c  f7fffffe          BL       st_dword
0000a0  2020              MOVS     r0,#0x20              ;3329
0000a2  990a              LDR      r1,[sp,#0x28]         ;3329
0000a4  72c8              STRB     r0,[r1,#0xb]          ;3329
0000a6  990a              LDR      r1,[sp,#0x28]         ;3330
0000a8  9802              LDR      r0,[sp,#8]            ;3330
0000aa  f7fffffe          BL       ld_clust
0000ae  4681              MOV      r9,r0                 ;3330
0000b0  2200              MOVS     r2,#0                 ;3331
0000b2  990a              LDR      r1,[sp,#0x28]         ;3331
0000b4  9802              LDR      r0,[sp,#8]            ;3331
0000b6  f7fffffe          BL       st_clust
0000ba  990a              LDR      r1,[sp,#0x28]         ;3332
0000bc  f101001c          ADD      r0,r1,#0x1c           ;3332
0000c0  2100              MOVS     r1,#0                 ;3332
0000c2  f7fffffe          BL       st_dword
0000c6  2001              MOVS     r0,#1                 ;3333
0000c8  9902              LDR      r1,[sp,#8]            ;3333
0000ca  70c8              STRB     r0,[r1,#3]            ;3333
0000cc  f1b90f00          CMP      r9,#0                 ;3335
0000d0  d025              BEQ      |L19.286|
0000d2  9802              LDR      r0,[sp,#8]            ;3336
0000d4  6ac0              LDR      r0,[r0,#0x2c]         ;3336
0000d6  9001              STR      r0,[sp,#4]            ;3336
0000d8  2200              MOVS     r2,#0                 ;3337
0000da  4649              MOV      r1,r9                 ;3337
0000dc  a803              ADD      r0,sp,#0xc            ;3337
0000de  f7fffffe          BL       remove_chain
0000e2  4605              MOV      r5,r0                 ;3337
0000e4  b9dd              CBNZ     r5,|L19.286|
0000e6  e9dd1001          LDRD     r1,r0,[sp,#4]         ;3339
0000ea  f7fffffe          BL       move_window
0000ee  4605              MOV      r5,r0                 ;3339
0000f0  f1a90001          SUB      r0,r9,#1              ;3340
0000f4  9902              LDR      r1,[sp,#8]            ;3340
0000f6  60c8              STR      r0,[r1,#0xc]          ;3340
0000f8  e011              B        |L19.286|
                  |L19.250|
0000fa  b985              CBNZ     r5,|L19.286|
0000fc  f89d0012          LDRB     r0,[sp,#0x12]         ;3348
000100  f0000010          AND      r0,r0,#0x10           ;3348
000104  b110              CBZ      r0,|L19.268|
000106  2504              MOVS     r5,#4                 ;3349
000108  e009              B        |L19.286|
                  |L19.266|
00010a  e05d              B        |L19.456|
                  |L19.268|
00010c  f0060002          AND      r0,r6,#2              ;3351
000110  b128              CBZ      r0,|L19.286|
000112  f89d0012          LDRB     r0,[sp,#0x12]         ;3351
000116  f0000001          AND      r0,r0,#1              ;3351
00011a  b100              CBZ      r0,|L19.286|
00011c  2507              MOVS     r5,#7                 ;3352
                  |L19.286|
00011e  b94d              CBNZ     r5,|L19.308|
000120  f0060008          AND      r0,r6,#8              ;3358
000124  b108              CBZ      r0,|L19.298|
000126  f0460640          ORR      r6,r6,#0x40           ;3359
                  |L19.298|
00012a  9802              LDR      r0,[sp,#8]            ;3360
00012c  6ac0              LDR      r0,[r0,#0x2c]         ;3360
00012e  6220              STR      r0,[r4,#0x20]         ;3360
000130  980a              LDR      r0,[sp,#0x28]         ;3361
000132  6260              STR      r0,[r4,#0x24]         ;3361
                  |L19.308|
000134  2d00              CMP      r5,#0                 ;3379
000136  d155              BNE      |L19.484|
000138  990a              LDR      r1,[sp,#0x28]         ;3391
00013a  9802              LDR      r0,[sp,#8]            ;3391
00013c  f7fffffe          BL       ld_clust
000140  60a0              STR      r0,[r4,#8]            ;3391
000142  990a              LDR      r1,[sp,#0x28]         ;3392
000144  f101001c          ADD      r0,r1,#0x1c           ;3392
000148  f7fffffe          BL       ld_dword
00014c  60e0              STR      r0,[r4,#0xc]          ;3392
00014e  9802              LDR      r0,[sp,#8]            ;3397
000150  6020              STR      r0,[r4,#0]            ;3397
000152  9802              LDR      r0,[sp,#8]            ;3398
000154  88c0              LDRH     r0,[r0,#6]            ;3398
000156  80a0              STRH     r0,[r4,#4]            ;3398
000158  7426              STRB     r6,[r4,#0x10]         ;3399
00015a  2000              MOVS     r0,#0                 ;3400
00015c  7460              STRB     r0,[r4,#0x11]         ;3400
00015e  61e0              STR      r0,[r4,#0x1c]         ;3401
000160  6160              STR      r0,[r4,#0x14]         ;3402
000162  f44f7200          MOV      r2,#0x200             ;3405
000166  2100              MOVS     r1,#0                 ;3405
000168  f1040028          ADD      r0,r4,#0x28           ;3405
00016c  f7fffffe          BL       mem_set
000170  f0060020          AND      r0,r6,#0x20           ;3407
000174  b340              CBZ      r0,|L19.456|
000176  68e0              LDR      r0,[r4,#0xc]          ;3407
000178  b330              CBZ      r0,|L19.456|
00017a  68e0              LDR      r0,[r4,#0xc]          ;3408
00017c  6160              STR      r0,[r4,#0x14]         ;3408
00017e  9802              LDR      r0,[sp,#8]            ;3409
000180  8940              LDRH     r0,[r0,#0xa]          ;3409
000182  ea4f2a40          LSL      r10,r0,#9             ;3409
000186  68a7              LDR      r7,[r4,#8]            ;3410
000188  f8d4800c          LDR      r8,[r4,#0xc]          ;3411
00018c  e00c              B        |L19.424|
                  |L19.398|
00018e  4639              MOV      r1,r7                 ;3412
000190  4620              MOV      r0,r4                 ;3412
000192  f7fffffe          BL       get_fat
000196  4607              MOV      r7,r0                 ;3412
000198  2f01              CMP      r7,#1                 ;3413
00019a  d800              BHI      |L19.414|
00019c  2502              MOVS     r5,#2                 ;3413
                  |L19.414|
00019e  1c78              ADDS     r0,r7,#1              ;3414
0001a0  b900              CBNZ     r0,|L19.420|
0001a2  2501              MOVS     r5,#1                 ;3414
                  |L19.420|
0001a4  eba8080a          SUB      r8,r8,r10             ;3411
                  |L19.424|
0001a8  b90d              CBNZ     r5,|L19.430|
0001aa  45d0              CMP      r8,r10                ;3411
0001ac  d8ef              BHI      |L19.398|
                  |L19.430|
0001ae  61a7              STR      r7,[r4,#0x18]         ;3416
0001b0  b955              CBNZ     r5,|L19.456|
0001b2  f3c80008          UBFX     r0,r8,#0,#9           ;3417
0001b6  b138              CBZ      r0,|L19.456|
0001b8  4639              MOV      r1,r7                 ;3418
0001ba  9802              LDR      r0,[sp,#8]            ;3418
0001bc  f7fffffe          BL       clust2sect
0001c0  f1b00b00          SUBS     r11,r0,#0             ;3418
0001c4  d101              BNE      |L19.458|
0001c6  2502              MOVS     r5,#2                 ;3419
                  |L19.456|
0001c8  e00c              B        |L19.484|
                  |L19.458|
0001ca  eb0b2058          ADD      r0,r11,r8,LSR #9      ;3421
0001ce  61e0              STR      r0,[r4,#0x1c]         ;3421
0001d0  69e2              LDR      r2,[r4,#0x1c]         ;3423
0001d2  9902              LDR      r1,[sp,#8]            ;3423
0001d4  7848              LDRB     r0,[r1,#1]            ;3423
0001d6  2301              MOVS     r3,#1                 ;3423
0001d8  f1040128          ADD      r1,r4,#0x28           ;3423
0001dc  f7fffffe          BL       disk_read
0001e0  b100              CBZ      r0,|L19.484|
0001e2  2501              MOVS     r5,#1                 ;3423
                  |L19.484|
0001e4  b10d              CBZ      r5,|L19.490|
0001e6  2000              MOVS     r0,#0                 ;3434
0001e8  6020              STR      r0,[r4,#0]            ;3434
                  |L19.490|
0001ea  4628              MOV      r0,r5                 ;3436
0001ec  e70f              B        |L19.14|
;;;3438   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;4086   
;;;4087   FRESULT f_opendir (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;4088   	DIR* dp,			/* Pointer to directory object to create */
;;;4089   	const TCHAR* path	/* Pointer to the directory path */
;;;4090   )
;;;4091   {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
;;;4092   	FRESULT res;
;;;4093   	FATFS *fs;
;;;4094   	_FDID *obj;
;;;4095   	DEF_NAMBUF
;;;4096   
;;;4097   
;;;4098   	if (!dp) return FR_INVALID_OBJECT;
000006  b916              CBNZ     r6,|L20.14|
000008  2009              MOVS     r0,#9
                  |L20.10|
;;;4099   
;;;4100   	/* Get logical drive */
;;;4101   	obj = &dp->obj;
;;;4102   	res = find_volume(&path, &fs, 0);
;;;4103   	if (res == FR_OK) {
;;;4104   		obj->fs = fs;
;;;4105   		INIT_NAMBUF(fs);
;;;4106   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;4107   		if (res == FR_OK) {						/* Follow completed */
;;;4108   			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
;;;4109   				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
;;;4110   #if _FS_EXFAT
;;;4111   					if (fs->fs_type == FS_EXFAT) {
;;;4112   						obj->c_scl = obj->sclust;	/* Save containing directory inforamation */
;;;4113   						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
;;;4114   						obj->c_ofs = dp->blk_ofs;
;;;4115   						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object location and status */
;;;4116   						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;4117   						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;4118   					} else
;;;4119   #endif
;;;4120   					{
;;;4121   						obj->sclust = ld_clust(fs, dp->dir);	/* Get object location */
;;;4122   					}
;;;4123   				} else {						/* This object is a file */
;;;4124   					res = FR_NO_PATH;
;;;4125   				}
;;;4126   			}
;;;4127   			if (res == FR_OK) {
;;;4128   				obj->id = fs->id;
;;;4129   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;4130   #if _FS_LOCK != 0
;;;4131   				if (res == FR_OK) {
;;;4132   					if (obj->sclust) {
;;;4133   						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;4134   						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
;;;4135   					} else {
;;;4136   						obj->lockid = 0;	/* Root directory need not to be locked */
;;;4137   					}
;;;4138   				}
;;;4139   #endif
;;;4140   			}
;;;4141   		}
;;;4142   		FREE_NAMBUF();
;;;4143   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;4144   	}
;;;4145   	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
;;;4146   
;;;4147   	LEAVE_FF(fs, res);
;;;4148   }
00000a  b004              ADD      sp,sp,#0x10
00000c  bd70              POP      {r4-r6,pc}
                  |L20.14|
00000e  4635              MOV      r5,r6                 ;4101
000010  2200              MOVS     r2,#0                 ;4102
000012  a901              ADD      r1,sp,#4              ;4102
000014  a803              ADD      r0,sp,#0xc            ;4102
000016  f7fffffe          BL       find_volume
00001a  4604              MOV      r4,r0                 ;4102
00001c  bb1c              CBNZ     r4,|L20.102|
00001e  9801              LDR      r0,[sp,#4]            ;4104
000020  6028              STR      r0,[r5,#0]            ;4104
000022  4630              MOV      r0,r6                 ;4106
000024  9903              LDR      r1,[sp,#0xc]          ;4106
000026  f7fffffe          BL       follow_path
00002a  4604              MOV      r4,r0                 ;4106
00002c  b9c4              CBNZ     r4,|L20.96|
00002e  202b              MOVS     r0,#0x2b              ;4108
000030  5d80              LDRB     r0,[r0,r6]            ;4108
000032  f0000080          AND      r0,r0,#0x80           ;4108
000036  b950              CBNZ     r0,|L20.78|
000038  79a8              LDRB     r0,[r5,#6]            ;4109
00003a  f0000010          AND      r0,r0,#0x10           ;4109
00003e  b128              CBZ      r0,|L20.76|
000040  69f1              LDR      r1,[r6,#0x1c]         ;4121
000042  9801              LDR      r0,[sp,#4]            ;4121
000044  f7fffffe          BL       ld_clust
000048  60a8              STR      r0,[r5,#8]            ;4121
00004a  e000              B        |L20.78|
                  |L20.76|
00004c  2405              MOVS     r4,#5                 ;4124
                  |L20.78|
00004e  b93c              CBNZ     r4,|L20.96|
000050  9801              LDR      r0,[sp,#4]            ;4128
000052  88c0              LDRH     r0,[r0,#6]            ;4128
000054  80a8              STRH     r0,[r5,#4]            ;4128
000056  2100              MOVS     r1,#0                 ;4129
000058  4630              MOV      r0,r6                 ;4129
00005a  f7fffffe          BL       dir_sdi
00005e  4604              MOV      r4,r0                 ;4129
                  |L20.96|
000060  2c04              CMP      r4,#4                 ;4143
000062  d100              BNE      |L20.102|
000064  2405              MOVS     r4,#5                 ;4143
                  |L20.102|
000066  b10c              CBZ      r4,|L20.108|
000068  2000              MOVS     r0,#0                 ;4145
00006a  6028              STR      r0,[r5,#0]            ;4145
                  |L20.108|
00006c  4620              MOV      r0,r4                 ;4147
00006e  e7cc              B        |L20.10|
;;;4149   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;3445   
;;;3446   FRESULT f_read (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3447   	FIL* fp, 	/* Pointer to the file object */
;;;3448   	void* buff,	/* Pointer to data buffer */
;;;3449   	UINT btr,	/* Number of bytes to read */
;;;3450   	UINT* br	/* Pointer to number of bytes read */
;;;3451   )
;;;3452   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
;;;3453   	FRESULT res;
;;;3454   	FATFS *fs;
;;;3455   	DWORD clst, sect;
;;;3456   	FSIZE_t remain;
;;;3457   	UINT rcnt, cc, csect;
;;;3458   	BYTE *rbuff = (BYTE*)buff;
00000c  f8ddb018          LDR      r11,[sp,#0x18]
;;;3459   
;;;3460   
;;;3461   	*br = 0;	/* Clear read byte counter */
000010  2000              MOVS     r0,#0
000012  f8ca0000          STR      r0,[r10,#0]
;;;3462   	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
000016  a903              ADD      r1,sp,#0xc
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       validate
00001e  9004              STR      r0,[sp,#0x10]
;;;3463   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
000020  9804              LDR      r0,[sp,#0x10]
000022  b910              CBNZ     r0,|L21.42|
000024  7c60              LDRB     r0,[r4,#0x11]
000026  9004              STR      r0,[sp,#0x10]
000028  b118              CBZ      r0,|L21.50|
                  |L21.42|
00002a  9804              LDR      r0,[sp,#0x10]
                  |L21.44|
;;;3464   	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
;;;3465   	remain = fp->obj.objsize - fp->fptr;
;;;3466   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;3467   
;;;3468   	for ( ;  btr;								/* Repeat until all data read */
;;;3469   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;3470   		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
;;;3471   			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
;;;3472   			if (csect == 0) {					/* On the cluster boundary? */
;;;3473   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;3474   					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
;;;3475   				} else {						/* Middle or end of the file */
;;;3476   #if _USE_FASTSEEK
;;;3477   					if (fp->cltbl) {
;;;3478   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;3479   					} else
;;;3480   #endif
;;;3481   					{
;;;3482   						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
;;;3483   					}
;;;3484   				}
;;;3485   				if (clst < 2) ABORT(fs, FR_INT_ERR);
;;;3486   				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;3487   				fp->clust = clst;				/* Update current cluster */
;;;3488   			}
;;;3489   			sect = clust2sect(fs, fp->clust);	/* Get current sector */
;;;3490   			if (!sect) ABORT(fs, FR_INT_ERR);
;;;3491   			sect += csect;
;;;3492   			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
;;;3493   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;3494   				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
;;;3495   					cc = fs->csize - csect;
;;;3496   				}
;;;3497   				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3498   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;3499   #if _FS_TINY
;;;3500   				if (fs->wflag && fs->winsect - sect < cc) {
;;;3501   					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
;;;3502   				}
;;;3503   #else
;;;3504   				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
;;;3505   					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
;;;3506   				}
;;;3507   #endif
;;;3508   #endif
;;;3509   				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
;;;3510   				continue;
;;;3511   			}
;;;3512   #if !_FS_TINY
;;;3513   			if (fp->sect != sect) {			/* Load data sector if not in cache */
;;;3514   #if !_FS_READONLY
;;;3515   				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
;;;3516   					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3517   					fp->flag &= (BYTE)~FA_DIRTY;
;;;3518   				}
;;;3519   #endif
;;;3520   				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
;;;3521   			}
;;;3522   #endif
;;;3523   			fp->sect = sect;
;;;3524   		}
;;;3525   		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
;;;3526   		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
;;;3527   #if _FS_TINY
;;;3528   		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
;;;3529   		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
;;;3530   #else
;;;3531   		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
;;;3532   #endif
;;;3533   	}
;;;3534   
;;;3535   	LEAVE_FF(fs, FR_OK);
;;;3536   }
00002c  b009              ADD      sp,sp,#0x24
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.50|
000032  7c20              LDRB     r0,[r4,#0x10]         ;3464
000034  f0000001          AND      r0,r0,#1              ;3464
000038  b908              CBNZ     r0,|L21.62|
00003a  2007              MOVS     r0,#7                 ;3464
00003c  e7f6              B        |L21.44|
                  |L21.62|
00003e  6961              LDR      r1,[r4,#0x14]         ;3465
000040  68e0              LDR      r0,[r4,#0xc]          ;3465
000042  1a40              SUBS     r0,r0,r1              ;3465
000044  9001              STR      r0,[sp,#4]            ;3465
000046  9801              LDR      r0,[sp,#4]            ;3466
000048  4285              CMP      r5,r0                 ;3466
00004a  d900              BLS      |L21.78|
00004c  9d01              LDR      r5,[sp,#4]            ;3466
                  |L21.78|
00004e  e0a0              B        |L21.402|
                  |L21.80|
000050  8aa0              LDRH     r0,[r4,#0x14]         ;3470
000052  f3c00008          UBFX     r0,r0,#0,#9           ;3470
000056  2800              CMP      r0,#0                 ;3470
000058  d17e              BNE      |L21.344|
00005a  9803              LDR      r0,[sp,#0xc]          ;3471
00005c  8940              LDRH     r0,[r0,#0xa]          ;3471
00005e  1e40              SUBS     r0,r0,#1              ;3471
000060  6961              LDR      r1,[r4,#0x14]         ;3471
000062  ea002951          AND      r9,r0,r1,LSR #9       ;3471
000066  f1b90f00          CMP      r9,#0                 ;3472
00006a  d117              BNE      |L21.156|
00006c  6960              LDR      r0,[r4,#0x14]         ;3473
00006e  b910              CBNZ     r0,|L21.118|
000070  68a0              LDR      r0,[r4,#8]            ;3474
000072  9002              STR      r0,[sp,#8]            ;3474
000074  e004              B        |L21.128|
                  |L21.118|
000076  4620              MOV      r0,r4                 ;3482
000078  69a1              LDR      r1,[r4,#0x18]         ;3482
00007a  f7fffffe          BL       get_fat
00007e  9002              STR      r0,[sp,#8]            ;3482
                  |L21.128|
000080  9802              LDR      r0,[sp,#8]            ;3485
000082  2802              CMP      r0,#2                 ;3485
000084  d202              BCS      |L21.140|
000086  2002              MOVS     r0,#2                 ;3485
000088  7460              STRB     r0,[r4,#0x11]         ;3485
00008a  e7cf              B        |L21.44|
                  |L21.140|
00008c  9802              LDR      r0,[sp,#8]            ;3486
00008e  1c40              ADDS     r0,r0,#1              ;3486
000090  b910              CBNZ     r0,|L21.152|
000092  2001              MOVS     r0,#1                 ;3486
000094  7460              STRB     r0,[r4,#0x11]         ;3486
000096  e7c9              B        |L21.44|
                  |L21.152|
000098  9802              LDR      r0,[sp,#8]            ;3487
00009a  61a0              STR      r0,[r4,#0x18]         ;3487
                  |L21.156|
00009c  69a1              LDR      r1,[r4,#0x18]         ;3489
00009e  9803              LDR      r0,[sp,#0xc]          ;3489
0000a0  f7fffffe          BL       clust2sect
0000a4  4606              MOV      r6,r0                 ;3489
0000a6  b916              CBNZ     r6,|L21.174|
0000a8  2002              MOVS     r0,#2                 ;3490
0000aa  7460              STRB     r0,[r4,#0x11]         ;3490
0000ac  e7be              B        |L21.44|
                  |L21.174|
0000ae  444e              ADD      r6,r6,r9              ;3491
0000b0  ea4f2855          LSR      r8,r5,#9              ;3492
0000b4  f1b80f00          CMP      r8,#0                 ;3493
0000b8  d029              BEQ      |L21.270|
0000ba  eb090008          ADD      r0,r9,r8              ;3494
0000be  9903              LDR      r1,[sp,#0xc]          ;3494
0000c0  8949              LDRH     r1,[r1,#0xa]          ;3494
0000c2  4288              CMP      r0,r1                 ;3494
0000c4  d903              BLS      |L21.206|
0000c6  9803              LDR      r0,[sp,#0xc]          ;3495
0000c8  8940              LDRH     r0,[r0,#0xa]          ;3495
0000ca  eba00809          SUB      r8,r0,r9              ;3495
                  |L21.206|
0000ce  9903              LDR      r1,[sp,#0xc]          ;3497
0000d0  7848              LDRB     r0,[r1,#1]            ;3497
0000d2  4643              MOV      r3,r8                 ;3497
0000d4  4632              MOV      r2,r6                 ;3497
0000d6  4659              MOV      r1,r11                ;3497
0000d8  f7fffffe          BL       disk_read
0000dc  b110              CBZ      r0,|L21.228|
0000de  2001              MOVS     r0,#1                 ;3497
0000e0  7460              STRB     r0,[r4,#0x11]         ;3497
0000e2  e7a3              B        |L21.44|
                  |L21.228|
0000e4  7c20              LDRB     r0,[r4,#0x10]         ;3504
0000e6  f0000080          AND      r0,r0,#0x80           ;3504
0000ea  b168              CBZ      r0,|L21.264|
0000ec  69e0              LDR      r0,[r4,#0x1c]         ;3504
0000ee  1b80              SUBS     r0,r0,r6              ;3504
0000f0  4540              CMP      r0,r8                 ;3504
0000f2  d209              BCS      |L21.264|
0000f4  69e1              LDR      r1,[r4,#0x1c]         ;3505
0000f6  1b89              SUBS     r1,r1,r6              ;3505
0000f8  eb0b2041          ADD      r0,r11,r1,LSL #9      ;3505
0000fc  f44f7200          MOV      r2,#0x200             ;3505
000100  f1040128          ADD      r1,r4,#0x28           ;3505
000104  f7fffffe          BL       mem_cpy
                  |L21.264|
000108  ea4f2748          LSL      r7,r8,#9              ;3509
00010c  e037              B        |L21.382|
                  |L21.270|
00010e  69e0              LDR      r0,[r4,#0x1c]         ;3513
000110  42b0              CMP      r0,r6                 ;3513
000112  d020              BEQ      |L21.342|
000114  7c20              LDRB     r0,[r4,#0x10]         ;3515
000116  f0000080          AND      r0,r0,#0x80           ;3515
00011a  b178              CBZ      r0,|L21.316|
00011c  69e2              LDR      r2,[r4,#0x1c]         ;3516
00011e  9903              LDR      r1,[sp,#0xc]          ;3516
000120  7848              LDRB     r0,[r1,#1]            ;3516
000122  2301              MOVS     r3,#1                 ;3516
000124  f1040128          ADD      r1,r4,#0x28           ;3516
000128  f7fffffe          BL       disk_write
00012c  b110              CBZ      r0,|L21.308|
00012e  2001              MOVS     r0,#1                 ;3516
000130  7460              STRB     r0,[r4,#0x11]         ;3516
000132  e77b              B        |L21.44|
                  |L21.308|
000134  7c20              LDRB     r0,[r4,#0x10]         ;3517
000136  f000007f          AND      r0,r0,#0x7f           ;3517
00013a  7420              STRB     r0,[r4,#0x10]         ;3517
                  |L21.316|
00013c  9903              LDR      r1,[sp,#0xc]          ;3520
00013e  7848              LDRB     r0,[r1,#1]            ;3520
000140  2301              MOVS     r3,#1                 ;3520
000142  4632              MOV      r2,r6                 ;3520
000144  f1040128          ADD      r1,r4,#0x28           ;3520
000148  f7fffffe          BL       disk_read
00014c  b118              CBZ      r0,|L21.342|
00014e  2001              MOVS     r0,#1                 ;3520
000150  7460              STRB     r0,[r4,#0x11]         ;3520
000152  e76b              B        |L21.44|
000154  e000              B        |L21.344|
                  |L21.342|
000156  61e6              STR      r6,[r4,#0x1c]         ;3523
                  |L21.344|
000158  8aa0              LDRH     r0,[r4,#0x14]         ;3525
00015a  f3c00008          UBFX     r0,r0,#0,#9           ;3525
00015e  f5c07700          RSB      r7,r0,#0x200          ;3525
000162  42af              CMP      r7,r5                 ;3526
000164  d900              BLS      |L21.360|
000166  462f              MOV      r7,r5                 ;3526
                  |L21.360|
000168  8aa0              LDRH     r0,[r4,#0x14]         ;3531
00016a  f3c00208          UBFX     r2,r0,#0,#9           ;3531
00016e  f1040028          ADD      r0,r4,#0x28           ;3531
000172  1811              ADDS     r1,r2,r0              ;3531
000174  463a              MOV      r2,r7                 ;3531
000176  4658              MOV      r0,r11                ;3531
000178  f7fffffe          BL       mem_cpy
00017c  bf00              NOP                            ;3510
                  |L21.382|
00017e  44bb              ADD      r11,r11,r7            ;3469
000180  6960              LDR      r0,[r4,#0x14]         ;3469
000182  4438              ADD      r0,r0,r7              ;3469
000184  6160              STR      r0,[r4,#0x14]         ;3469
000186  f8da0000          LDR      r0,[r10,#0]           ;3469
00018a  4438              ADD      r0,r0,r7              ;3469
00018c  f8ca0000          STR      r0,[r10,#0]           ;3469
000190  1bed              SUBS     r5,r5,r7              ;3469
                  |L21.402|
000192  2d00              CMP      r5,#0                 ;3468
000194  f47faf5c          BNE      |L21.80|
000198  2000              MOVS     r0,#0                 ;3535
00019a  e747              B        |L21.44|
;;;3537   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;4189   
;;;4190   FRESULT f_readdir (
000000  b5f8              PUSH     {r3-r7,lr}
;;;4191   	DIR* dp,			/* Pointer to the open directory object */
;;;4192   	FILINFO* fno		/* Pointer to file information to return */
;;;4193   )
;;;4194   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4195   	FRESULT res;
;;;4196   	FATFS *fs;
;;;4197   	DEF_NAMBUF
;;;4198   
;;;4199   
;;;4200   	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
000006  4669              MOV      r1,sp
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       validate
00000e  4604              MOV      r4,r0
;;;4201   	if (res == FR_OK) {
000010  b9dc              CBNZ     r4,|L22.74|
;;;4202   		if (!fno) {
000012  b92d              CBNZ     r5,|L22.32|
;;;4203   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
000014  2100              MOVS     r1,#0
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       dir_sdi
00001c  4604              MOV      r4,r0
00001e  e014              B        |L22.74|
                  |L22.32|
;;;4204   		} else {
;;;4205   			INIT_NAMBUF(fs);
;;;4206   			res = dir_read(dp, 0);			/* Read an item */
000020  2100              MOVS     r1,#0
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       dir_read
000028  4604              MOV      r4,r0
;;;4207   			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
00002a  2c04              CMP      r4,#4
00002c  d100              BNE      |L22.48|
00002e  2400              MOVS     r4,#0
                  |L22.48|
;;;4208   			if (res == FR_OK) {				/* A valid entry is found */
000030  b95c              CBNZ     r4,|L22.74|
;;;4209   				get_fileinfo(dp, fno);		/* Get the object information */
000032  4629              MOV      r1,r5
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       get_fileinfo
;;;4210   				res = dir_next(dp, 0);		/* Increment index for next */
00003a  2100              MOVS     r1,#0
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       dir_next
000042  4604              MOV      r4,r0
;;;4211   				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
000044  2c04              CMP      r4,#4
000046  d100              BNE      |L22.74|
000048  2400              MOVS     r4,#0
                  |L22.74|
;;;4212   			}
;;;4213   			FREE_NAMBUF();
;;;4214   		}
;;;4215   	}
;;;4216   	LEAVE_FF(fs, res);
00004a  4620              MOV      r0,r4
;;;4217   }
00004c  bdf8              POP      {r3-r7,pc}
;;;4218   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;4637   
;;;4638   FRESULT f_rename (
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;4639   	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
;;;4640   	const TCHAR* path_new	/* Pointer to the new name */
;;;4641   )
;;;4642   {
000002  b09d              SUB      sp,sp,#0x74
;;;4643   	FRESULT res;
;;;4644   	DIR djo, djn;
;;;4645   	FATFS *fs;
;;;4646   	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
;;;4647   	DWORD dw;
;;;4648   	DEF_NAMBUF
;;;4649   
;;;4650   
;;;4651   	get_ldnumber(&path_new);						/* Ignore drive number of new name */
000004  a81e              ADD      r0,sp,#0x78
000006  f7fffffe          BL       get_ldnumber
;;;4652   	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
00000a  2202              MOVS     r2,#2
00000c  a906              ADD      r1,sp,#0x18
00000e  a81d              ADD      r0,sp,#0x74
000010  f7fffffe          BL       find_volume
000014  4604              MOV      r4,r0
;;;4653   	if (res == FR_OK) {
000016  2c00              CMP      r4,#0
000018  d177              BNE      |L23.266|
;;;4654   		djo.obj.fs = fs;
00001a  9806              LDR      r0,[sp,#0x18]
00001c  9012              STR      r0,[sp,#0x48]
;;;4655   		INIT_NAMBUF(fs);
;;;4656   		res = follow_path(&djo, path_old);		/* Check old object */
00001e  a812              ADD      r0,sp,#0x48
000020  991d              LDR      r1,[sp,#0x74]
000022  f7fffffe          BL       follow_path
000026  4604              MOV      r4,r0
;;;4657   		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
000028  b92c              CBNZ     r4,|L23.54|
00002a  f89d0073          LDRB     r0,[sp,#0x73]
00002e  f00000a0          AND      r0,r0,#0xa0
000032  b100              CBZ      r0,|L23.54|
000034  2406              MOVS     r4,#6
                  |L23.54|
;;;4658   #if _FS_LOCK != 0
;;;4659   		if (res == FR_OK) res = chk_lock(&djo, 2);
;;;4660   #endif
;;;4661   		if (res == FR_OK) {						/* Object to be renamed is found */
000036  2c00              CMP      r4,#0
000038  d167              BNE      |L23.266|
;;;4662   #if _FS_EXFAT
;;;4663   			if (fs->fs_type == FS_EXFAT) {	/* At exFAT */
;;;4664   				BYTE nf, nn;
;;;4665   				WORD nh;
;;;4666   
;;;4667   				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
;;;4668   				mem_cpy(&djn, &djo, sizeof djo);
;;;4669   				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
;;;4670   				if (res == FR_OK) {						/* Is new name already in use by any other object? */
;;;4671   					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
;;;4672   				}
;;;4673   				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
;;;4674   					res = dir_register(&djn);			/* Register the new entry */
;;;4675   					if (res == FR_OK) {
;;;4676   						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
;;;4677   						nh = ld_word(fs->dirbuf + XDIR_NameHash);
;;;4678   						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);
;;;4679   						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
;;;4680   						st_word(fs->dirbuf + XDIR_NameHash, nh);
;;;4681   /* Start of critical section where any interruption can cause a cross-link */
;;;4682   						res = store_xdir(&djn);
;;;4683   					}
;;;4684   				}
;;;4685   			} else
;;;4686   #endif
;;;4687   			{	/* At FAT12/FAT16/FAT32 */
;;;4688   				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
00003a  9819              LDR      r0,[sp,#0x64]
00003c  f100010b          ADD      r1,r0,#0xb
000040  2215              MOVS     r2,#0x15
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       mem_cpy
;;;4689   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
000048  222c              MOVS     r2,#0x2c
00004a  a912              ADD      r1,sp,#0x48
00004c  a807              ADD      r0,sp,#0x1c
00004e  f7fffffe          BL       mem_cpy
;;;4690   				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
000052  a807              ADD      r0,sp,#0x1c
000054  991e              LDR      r1,[sp,#0x78]
000056  f7fffffe          BL       follow_path
00005a  4604              MOV      r4,r0
;;;4691   				if (res == FR_OK) {						/* Is new name already in use by any other object? */
00005c  b95c              CBNZ     r4,|L23.118|
;;;4692   					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
00005e  9914              LDR      r1,[sp,#0x50]
000060  9809              LDR      r0,[sp,#0x24]
000062  4288              CMP      r0,r1
000064  d105              BNE      |L23.114|
000066  9916              LDR      r1,[sp,#0x58]
000068  980b              LDR      r0,[sp,#0x2c]
00006a  4288              CMP      r0,r1
00006c  d101              BNE      |L23.114|
00006e  2004              MOVS     r0,#4
000070  e000              B        |L23.116|
                  |L23.114|
000072  2008              MOVS     r0,#8
                  |L23.116|
000074  4604              MOV      r4,r0
                  |L23.118|
;;;4693   				}
;;;4694   				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
000076  2c04              CMP      r4,#4
000078  d13d              BNE      |L23.246|
;;;4695   					res = dir_register(&djn);			/* Register the new entry */
00007a  a807              ADD      r0,sp,#0x1c
00007c  f7fffffe          BL       dir_register
000080  4604              MOV      r4,r0
;;;4696   					if (res == FR_OK) {
000082  bb1c              CBNZ     r4,|L23.204|
;;;4697   						dir = djn.dir;					/* Copy information about object except name */
000084  9d0e              LDR      r5,[sp,#0x38]
;;;4698   						mem_cpy(dir + 13, buf + 2, 19);
000086  2213              MOVS     r2,#0x13
000088  f10d0102          ADD      r1,sp,#2
00008c  f105000d          ADD      r0,r5,#0xd
000090  f7fffffe          BL       mem_cpy
;;;4699   						dir[DIR_Attr] = buf[0] | AM_ARC;
000094  f89d0000          LDRB     r0,[sp,#0]
000098  f0400020          ORR      r0,r0,#0x20
00009c  72e8              STRB     r0,[r5,#0xb]
;;;4700   						fs->wflag = 1;
00009e  2001              MOVS     r0,#1
0000a0  9906              LDR      r1,[sp,#0x18]
0000a2  70c8              STRB     r0,[r1,#3]
;;;4701   						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
0000a4  7ae8              LDRB     r0,[r5,#0xb]
0000a6  f0000010          AND      r0,r0,#0x10
0000aa  b178              CBZ      r0,|L23.204|
0000ac  9909              LDR      r1,[sp,#0x24]
0000ae  9814              LDR      r0,[sp,#0x50]
0000b0  4288              CMP      r0,r1
0000b2  d020              BEQ      |L23.246|
;;;4702   							dw = clust2sect(fs, ld_clust(fs, dir));
0000b4  4629              MOV      r1,r5
0000b6  9806              LDR      r0,[sp,#0x18]
0000b8  f7fffffe          BL       ld_clust
0000bc  4607              MOV      r7,r0
0000be  4639              MOV      r1,r7
0000c0  9806              LDR      r0,[sp,#0x18]
0000c2  f7fffffe          BL       clust2sect
0000c6  4606              MOV      r6,r0
;;;4703   							if (!dw) {
0000c8  b90e              CBNZ     r6,|L23.206|
;;;4704   								res = FR_INT_ERR;
0000ca  2402              MOVS     r4,#2
                  |L23.204|
0000cc  e013              B        |L23.246|
                  |L23.206|
;;;4705   							} else {
;;;4706   /* Start of critical section where any interruption can cause a cross-link */
;;;4707   								res = move_window(fs, dw);
0000ce  4631              MOV      r1,r6
0000d0  9806              LDR      r0,[sp,#0x18]
0000d2  f7fffffe          BL       move_window
0000d6  4604              MOV      r4,r0
;;;4708   								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
0000d8  9806              LDR      r0,[sp,#0x18]
0000da  f1000550          ADD      r5,r0,#0x50
;;;4709   								if (res == FR_OK && dir[1] == '.') {
0000de  b954              CBNZ     r4,|L23.246|
0000e0  7868              LDRB     r0,[r5,#1]
0000e2  282e              CMP      r0,#0x2e
0000e4  d107              BNE      |L23.246|
;;;4710   									st_clust(fs, dir, djn.obj.sclust);
0000e6  4629              MOV      r1,r5
0000e8  9a09              LDR      r2,[sp,#0x24]
0000ea  9806              LDR      r0,[sp,#0x18]
0000ec  f7fffffe          BL       st_clust
;;;4711   									fs->wflag = 1;
0000f0  2001              MOVS     r0,#1
0000f2  9906              LDR      r1,[sp,#0x18]
0000f4  70c8              STRB     r0,[r1,#3]
                  |L23.246|
;;;4712   								}
;;;4713   							}
;;;4714   						}
;;;4715   					}
;;;4716   				}
;;;4717   			}
;;;4718   			if (res == FR_OK) {
0000f6  b944              CBNZ     r4,|L23.266|
;;;4719   				res = dir_remove(&djo);		/* Remove old entry */
0000f8  a812              ADD      r0,sp,#0x48
0000fa  f7fffffe          BL       dir_remove
0000fe  4604              MOV      r4,r0
;;;4720   				if (res == FR_OK) {
000100  b91c              CBNZ     r4,|L23.266|
;;;4721   					res = sync_fs(fs);
000102  9806              LDR      r0,[sp,#0x18]
000104  f7fffffe          BL       sync_fs
000108  4604              MOV      r4,r0
                  |L23.266|
;;;4722   				}
;;;4723   			}
;;;4724   /* End of critical section */
;;;4725   		}
;;;4726   		FREE_NAMBUF();
;;;4727   	}
;;;4728   
;;;4729   	LEAVE_FF(fs, res);
00010a  4620              MOV      r0,r4
;;;4730   }
00010c  b01f              ADD      sp,sp,#0x7c
00010e  bdf0              POP      {r4-r7,pc}
;;;4731   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;4277   
;;;4278   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;4279   	const TCHAR* path,	/* Pointer to the file path */
;;;4280   	FILINFO* fno		/* Pointer to file information to return */
;;;4281   )
;;;4282   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;4283   	FRESULT res;
;;;4284   	DIR dj;
;;;4285   	DEF_NAMBUF
;;;4286   
;;;4287   
;;;4288   	/* Get logical drive */
;;;4289   	res = find_volume(&path, &dj.obj.fs, 0);
000006  2200              MOVS     r2,#0
000008  4669              MOV      r1,sp
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       find_volume
000010  4604              MOV      r4,r0
;;;4290   	if (res == FR_OK) {
000012  b98c              CBNZ     r4,|L24.56|
;;;4291   		INIT_NAMBUF(dj.obj.fs);
;;;4292   		res = follow_path(&dj, path);	/* Follow the file path */
000014  4668              MOV      r0,sp
000016  990b              LDR      r1,[sp,#0x2c]
000018  f7fffffe          BL       follow_path
00001c  4604              MOV      r4,r0
;;;4293   		if (res == FR_OK) {				/* Follow completed */
00001e  b95c              CBNZ     r4,|L24.56|
;;;4294   			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
000020  f89d002b          LDRB     r0,[sp,#0x2b]
000024  f0000080          AND      r0,r0,#0x80
000028  b108              CBZ      r0,|L24.46|
;;;4295   				res = FR_INVALID_NAME;
00002a  2406              MOVS     r4,#6
00002c  e004              B        |L24.56|
                  |L24.46|
;;;4296   			} else {							/* Found an object */
;;;4297   				if (fno) get_fileinfo(&dj, fno);
00002e  b11d              CBZ      r5,|L24.56|
000030  4629              MOV      r1,r5
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       get_fileinfo
                  |L24.56|
;;;4298   			}
;;;4299   		}
;;;4300   		FREE_NAMBUF();
;;;4301   	}
;;;4302   
;;;4303   	LEAVE_FF(dj.obj.fs, res);
000038  4620              MOV      r0,r4
;;;4304   }
00003a  b00d              ADD      sp,sp,#0x34
00003c  bd30              POP      {r4,r5,pc}
;;;4305   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;3666   
;;;3667   FRESULT f_sync (
000000  b5f8              PUSH     {r3-r7,lr}
;;;3668   	FIL* fp		/* Pointer to the file object */
;;;3669   )
;;;3670   {
000002  4604              MOV      r4,r0
;;;3671   	FRESULT res;
;;;3672   	FATFS *fs;
;;;3673   	DWORD tm;
;;;3674   	BYTE *dir;
;;;3675   	DEF_NAMBUF
;;;3676   
;;;3677   
;;;3678   	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4606              MOV      r6,r0
;;;3679   	if (res == FR_OK) {
00000e  2e00              CMP      r6,#0
000010  d144              BNE      |L25.156|
;;;3680   		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
000012  7c20              LDRB     r0,[r4,#0x10]
000014  f0000040          AND      r0,r0,#0x40
000018  2800              CMP      r0,#0
00001a  d03f              BEQ      |L25.156|
;;;3681   #if !_FS_TINY
;;;3682   			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
00001c  7c20              LDRB     r0,[r4,#0x10]
00001e  f0000080          AND      r0,r0,#0x80
000022  b170              CBZ      r0,|L25.66|
;;;3683   				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
000024  69e2              LDR      r2,[r4,#0x1c]
000026  9900              LDR      r1,[sp,#0]
000028  7848              LDRB     r0,[r1,#1]
00002a  2301              MOVS     r3,#1
00002c  f1040128          ADD      r1,r4,#0x28
000030  f7fffffe          BL       disk_write
000034  b108              CBZ      r0,|L25.58|
000036  2001              MOVS     r0,#1
                  |L25.56|
;;;3684   				fp->flag &= (BYTE)~FA_DIRTY;
;;;3685   			}
;;;3686   #endif
;;;3687   			/* Update the directory entry */
;;;3688   			tm = GET_FATTIME();				/* Modified time */
;;;3689   #if _FS_EXFAT
;;;3690   			if (fs->fs_type == FS_EXFAT) {
;;;3691   				res = fill_fat_chain(&fp->obj);	/* Create FAT chain if needed */
;;;3692   				if (res == FR_OK) {
;;;3693   					DIR dj;
;;;3694   
;;;3695   					INIT_NAMBUF(fs);
;;;3696   					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
;;;3697   					if (res == FR_OK) {
;;;3698   						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive bit */
;;;3699   						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation info */
;;;3700   						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
;;;3701   						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
;;;3702   						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
;;;3703   						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
;;;3704   						fs->dirbuf[XDIR_ModTime10] = 0;
;;;3705   						st_dword(fs->dirbuf + XDIR_AccTime, 0);
;;;3706   						res = store_xdir(&dj);	/* Restore it to the directory */
;;;3707   						if (res == FR_OK) {
;;;3708   							res = sync_fs(fs);
;;;3709   							fp->flag &= (BYTE)~FA_MODIFIED;
;;;3710   						}
;;;3711   					}
;;;3712   					FREE_NAMBUF();
;;;3713   				}
;;;3714   			} else
;;;3715   #endif
;;;3716   			{
;;;3717   				res = move_window(fs, fp->dir_sect);
;;;3718   				if (res == FR_OK) {
;;;3719   					dir = fp->dir_ptr;
;;;3720   					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
;;;3721   					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
;;;3722   					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
;;;3723   					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
;;;3724   					st_word(dir + DIR_LstAccDate, 0);
;;;3725   					fs->wflag = 1;
;;;3726   					res = sync_fs(fs);					/* Restore it to the directory */
;;;3727   					fp->flag &= (BYTE)~FA_MODIFIED;
;;;3728   				}
;;;3729   			}
;;;3730   		}
;;;3731   	}
;;;3732   
;;;3733   	LEAVE_FF(fs, res);
;;;3734   }
000038  bdf8              POP      {r3-r7,pc}
                  |L25.58|
00003a  7c20              LDRB     r0,[r4,#0x10]         ;3684
00003c  f000007f          AND      r0,r0,#0x7f           ;3684
000040  7420              STRB     r0,[r4,#0x10]         ;3684
                  |L25.66|
000042  f7fffffe          BL       get_fattime
000046  4607              MOV      r7,r0                 ;3688
000048  6a21              LDR      r1,[r4,#0x20]         ;3717
00004a  9800              LDR      r0,[sp,#0]            ;3717
00004c  f7fffffe          BL       move_window
000050  4606              MOV      r6,r0                 ;3717
000052  bb1e              CBNZ     r6,|L25.156|
000054  6a65              LDR      r5,[r4,#0x24]         ;3719
000056  7ae8              LDRB     r0,[r5,#0xb]          ;3720
000058  f0400020          ORR      r0,r0,#0x20           ;3720
00005c  72e8              STRB     r0,[r5,#0xb]          ;3720
00005e  4629              MOV      r1,r5                 ;3721
000060  68a2              LDR      r2,[r4,#8]            ;3721
000062  6820              LDR      r0,[r4,#0]            ;3721
000064  f7fffffe          BL       st_clust
000068  f105001c          ADD      r0,r5,#0x1c           ;3722
00006c  68e1              LDR      r1,[r4,#0xc]          ;3722
00006e  f7fffffe          BL       st_dword
000072  4639              MOV      r1,r7                 ;3723
000074  f1050016          ADD      r0,r5,#0x16           ;3723
000078  f7fffffe          BL       st_dword
00007c  2100              MOVS     r1,#0                 ;3724
00007e  f1050012          ADD      r0,r5,#0x12           ;3724
000082  f7fffffe          BL       st_word
000086  2001              MOVS     r0,#1                 ;3725
000088  9900              LDR      r1,[sp,#0]            ;3725
00008a  70c8              STRB     r0,[r1,#3]            ;3725
00008c  9800              LDR      r0,[sp,#0]            ;3726
00008e  f7fffffe          BL       sync_fs
000092  4606              MOV      r6,r0                 ;3726
000094  7c20              LDRB     r0,[r4,#0x10]         ;3727
000096  f00000bf          AND      r0,r0,#0xbf           ;3727
00009a  7420              STRB     r0,[r4,#0x10]         ;3727
                  |L25.156|
00009c  4630              MOV      r0,r6                 ;3733
00009e  e7cb              B        |L25.56|
;;;3735   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;4399   
;;;4400   FRESULT f_truncate (
000000  b5f8              PUSH     {r3-r7,lr}
;;;4401   	FIL* fp		/* Pointer to the file object */
;;;4402   )
;;;4403   {
000002  4604              MOV      r4,r0
;;;4404   	FRESULT res;
;;;4405   	FATFS *fs;
;;;4406   	DWORD ncl;
;;;4407   
;;;4408   
;;;4409   	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
000004  4669              MOV      r1,sp
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
00000c  4605              MOV      r5,r0
;;;4410   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
00000e  b915              CBNZ     r5,|L26.22|
000010  7c60              LDRB     r0,[r4,#0x11]
000012  1e05              SUBS     r5,r0,#0
000014  d001              BEQ      |L26.26|
                  |L26.22|
000016  4628              MOV      r0,r5
                  |L26.24|
;;;4411   	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
;;;4412   
;;;4413   	if (fp->obj.objsize > fp->fptr) {
;;;4414   		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
;;;4415   			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
;;;4416   			fp->obj.sclust = 0;
;;;4417   		} else {				/* When truncate a part of the file, remove remaining clusters */
;;;4418   			ncl = get_fat(&fp->obj, fp->clust);
;;;4419   			res = FR_OK;
;;;4420   			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
;;;4421   			if (ncl == 1) res = FR_INT_ERR;
;;;4422   			if (res == FR_OK && ncl < fs->n_fatent) {
;;;4423   				res = remove_chain(&fp->obj, ncl, fp->clust);
;;;4424   			}
;;;4425   		}
;;;4426   		fp->obj.objsize = fp->fptr;	/* Set file size to current R/W point */
;;;4427   		fp->flag |= FA_MODIFIED;
;;;4428   #if !_FS_TINY
;;;4429   		if (res == FR_OK && (fp->flag & FA_DIRTY)) {
;;;4430   			if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
;;;4431   				res = FR_DISK_ERR;
;;;4432   			} else {
;;;4433   				fp->flag &= (BYTE)~FA_DIRTY;
;;;4434   			}
;;;4435   		}
;;;4436   #endif
;;;4437   		if (res != FR_OK) ABORT(fs, res);
;;;4438   	}
;;;4439   
;;;4440   	LEAVE_FF(fs, res);
;;;4441   }
000018  bdf8              POP      {r3-r7,pc}
                  |L26.26|
00001a  7c20              LDRB     r0,[r4,#0x10]         ;4411
00001c  f0000002          AND      r0,r0,#2              ;4411
000020  b908              CBNZ     r0,|L26.38|
000022  2007              MOVS     r0,#7                 ;4411
000024  e7f8              B        |L26.24|
                  |L26.38|
000026  6961              LDR      r1,[r4,#0x14]         ;4413
000028  68e0              LDR      r0,[r4,#0xc]          ;4413
00002a  4288              CMP      r0,r1                 ;4413
00002c  d93f              BLS      |L26.174|
00002e  6960              LDR      r0,[r4,#0x14]         ;4414
000030  b940              CBNZ     r0,|L26.68|
000032  2200              MOVS     r2,#0                 ;4415
000034  4620              MOV      r0,r4                 ;4415
000036  68a1              LDR      r1,[r4,#8]            ;4415
000038  f7fffffe          BL       remove_chain
00003c  4605              MOV      r5,r0                 ;4415
00003e  2000              MOVS     r0,#0                 ;4416
000040  60a0              STR      r0,[r4,#8]            ;4416
000042  e016              B        |L26.114|
                  |L26.68|
000044  4620              MOV      r0,r4                 ;4418
000046  69a1              LDR      r1,[r4,#0x18]         ;4418
000048  f7fffffe          BL       get_fat
00004c  4606              MOV      r6,r0                 ;4418
00004e  2500              MOVS     r5,#0                 ;4419
000050  1c70              ADDS     r0,r6,#1              ;4420
000052  b900              CBNZ     r0,|L26.86|
000054  2501              MOVS     r5,#1                 ;4420
                  |L26.86|
000056  2e01              CMP      r6,#1                 ;4421
000058  d100              BNE      |L26.92|
00005a  2502              MOVS     r5,#2                 ;4421
                  |L26.92|
00005c  b94d              CBNZ     r5,|L26.114|
00005e  9800              LDR      r0,[sp,#0]            ;4422
000060  6940              LDR      r0,[r0,#0x14]         ;4422
000062  42b0              CMP      r0,r6                 ;4422
000064  d905              BLS      |L26.114|
000066  4631              MOV      r1,r6                 ;4423
000068  4620              MOV      r0,r4                 ;4423
00006a  69a2              LDR      r2,[r4,#0x18]         ;4423
00006c  f7fffffe          BL       remove_chain
000070  4605              MOV      r5,r0                 ;4423
                  |L26.114|
000072  6960              LDR      r0,[r4,#0x14]         ;4426
000074  60e0              STR      r0,[r4,#0xc]          ;4426
000076  7c20              LDRB     r0,[r4,#0x10]         ;4427
000078  f0400040          ORR      r0,r0,#0x40           ;4427
00007c  7420              STRB     r0,[r4,#0x10]         ;4427
00007e  b995              CBNZ     r5,|L26.166|
000080  7c20              LDRB     r0,[r4,#0x10]         ;4429
000082  f0000080          AND      r0,r0,#0x80           ;4429
000086  b170              CBZ      r0,|L26.166|
000088  69e2              LDR      r2,[r4,#0x1c]         ;4430
00008a  9900              LDR      r1,[sp,#0]            ;4430
00008c  7848              LDRB     r0,[r1,#1]            ;4430
00008e  2301              MOVS     r3,#1                 ;4430
000090  f1040128          ADD      r1,r4,#0x28           ;4430
000094  f7fffffe          BL       disk_write
000098  b108              CBZ      r0,|L26.158|
00009a  2501              MOVS     r5,#1                 ;4431
00009c  e003              B        |L26.166|
                  |L26.158|
00009e  7c20              LDRB     r0,[r4,#0x10]         ;4433
0000a0  f000007f          AND      r0,r0,#0x7f           ;4433
0000a4  7420              STRB     r0,[r4,#0x10]         ;4433
                  |L26.166|
0000a6  b115              CBZ      r5,|L26.174|
0000a8  7465              STRB     r5,[r4,#0x11]         ;4437
0000aa  4628              MOV      r0,r5                 ;4437
0000ac  e7b4              B        |L26.24|
                  |L26.174|
0000ae  4628              MOV      r0,r5                 ;4440
0000b0  e7b2              B        |L26.24|
;;;4442   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;4449   
;;;4450   FRESULT f_unlink (
000000  b531              PUSH     {r0,r4,r5,lr}
;;;4451   	const TCHAR* path		/* Pointer to the file or directory path */
;;;4452   )
;;;4453   {
000002  b098              SUB      sp,sp,#0x60
;;;4454   	FRESULT res;
;;;4455   	DIR dj, sdj;
;;;4456   	DWORD dclst = 0;
000004  2500              MOVS     r5,#0
;;;4457   	FATFS *fs;
;;;4458   #if _FS_EXFAT
;;;4459   	_FDID obj;
;;;4460   #endif
;;;4461   	DEF_NAMBUF
;;;4462   
;;;4463   
;;;4464   	/* Get logical drive */
;;;4465   	res = find_volume(&path, &fs, FA_WRITE);
000006  2202              MOVS     r2,#2
000008  a901              ADD      r1,sp,#4
00000a  a818              ADD      r0,sp,#0x60
00000c  f7fffffe          BL       find_volume
000010  4604              MOV      r4,r0
;;;4466   	dj.obj.fs = fs;
000012  9801              LDR      r0,[sp,#4]
000014  900d              STR      r0,[sp,#0x34]
;;;4467   	if (res == FR_OK) {
000016  2c00              CMP      r4,#0
000018  d144              BNE      |L27.164|
;;;4468   		INIT_NAMBUF(fs);
;;;4469   		res = follow_path(&dj, path);		/* Follow the file path */
00001a  a80d              ADD      r0,sp,#0x34
00001c  9918              LDR      r1,[sp,#0x60]
00001e  f7fffffe          BL       follow_path
000022  4604              MOV      r4,r0
;;;4470   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
000024  bf00              NOP      
;;;4471   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;4472   		}
;;;4473   #if _FS_LOCK != 0
;;;4474   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
;;;4475   #endif
;;;4476   		if (res == FR_OK) {					/* The object is accessible */
000026  2c00              CMP      r4,#0
000028  d13c              BNE      |L27.164|
;;;4477   			if (dj.fn[NSFLAG] & NS_NONAME) {
00002a  f89d005f          LDRB     r0,[sp,#0x5f]
00002e  f0000080          AND      r0,r0,#0x80
000032  b108              CBZ      r0,|L27.56|
;;;4478   				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
000034  2406              MOVS     r4,#6
000036  e005              B        |L27.68|
                  |L27.56|
;;;4479   			} else {
;;;4480   				if (dj.obj.attr & AM_RDO) {
000038  f89d003a          LDRB     r0,[sp,#0x3a]
00003c  f0000001          AND      r0,r0,#1
000040  b100              CBZ      r0,|L27.68|
;;;4481   					res = FR_DENIED;		/* Cannot remove R/O object */
000042  2407              MOVS     r4,#7
                  |L27.68|
;;;4482   				}
;;;4483   			}
;;;4484   			if (res == FR_OK) {
000044  b9e4              CBNZ     r4,|L27.128|
;;;4485   #if _FS_EXFAT
;;;4486   				obj.fs = fs;
;;;4487   				if (fs->fs_type == FS_EXFAT) {
;;;4488   					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
;;;4489   					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;4490   					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;4491   				} else
;;;4492   #endif
;;;4493   				{
;;;4494   					dclst = ld_clust(fs, dj.dir);
000046  9914              LDR      r1,[sp,#0x50]
000048  9801              LDR      r0,[sp,#4]
00004a  f7fffffe          BL       ld_clust
00004e  4605              MOV      r5,r0
;;;4495   				}
;;;4496   				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory ? */
000050  f89d003a          LDRB     r0,[sp,#0x3a]
000054  f0000010          AND      r0,r0,#0x10
000058  b190              CBZ      r0,|L27.128|
;;;4497   #if _FS_RPATH != 0
;;;4498   					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
;;;4499   						res = FR_DENIED;
;;;4500   					} else
;;;4501   #endif
;;;4502   					{
;;;4503   						sdj.obj.fs = fs;						/* Open the sub-directory */
00005a  9801              LDR      r0,[sp,#4]
00005c  9002              STR      r0,[sp,#8]
;;;4504   						sdj.obj.sclust = dclst;
00005e  9504              STR      r5,[sp,#0x10]
;;;4505   #if _FS_EXFAT
;;;4506   						if (fs->fs_type == FS_EXFAT) {
;;;4507   							sdj.obj.objsize = obj.objsize;
;;;4508   							sdj.obj.stat = obj.stat;
;;;4509   						}
;;;4510   #endif
;;;4511   						res = dir_sdi(&sdj, 0);
000060  2100              MOVS     r1,#0
000062  a802              ADD      r0,sp,#8
000064  f7fffffe          BL       dir_sdi
000068  4604              MOV      r4,r0
;;;4512   						if (res == FR_OK) {
00006a  b94c              CBNZ     r4,|L27.128|
;;;4513   							res = dir_read(&sdj, 0);			/* Read an item */
00006c  2100              MOVS     r1,#0
00006e  a802              ADD      r0,sp,#8
000070  f7fffffe          BL       dir_read
000074  4604              MOV      r4,r0
;;;4514   							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
000076  b904              CBNZ     r4,|L27.122|
000078  2407              MOVS     r4,#7
                  |L27.122|
;;;4515   							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
00007a  2c04              CMP      r4,#4
00007c  d100              BNE      |L27.128|
00007e  2400              MOVS     r4,#0
                  |L27.128|
;;;4516   						}
;;;4517   					}
;;;4518   				}
;;;4519   			}
;;;4520   			if (res == FR_OK) {
000080  b984              CBNZ     r4,|L27.164|
;;;4521   				res = dir_remove(&dj);			/* Remove the directory entry */
000082  a80d              ADD      r0,sp,#0x34
000084  f7fffffe          BL       dir_remove
000088  4604              MOV      r4,r0
;;;4522   				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
00008a  b934              CBNZ     r4,|L27.154|
00008c  b12d              CBZ      r5,|L27.154|
;;;4523   #if _FS_EXFAT
;;;4524   					res = remove_chain(&obj, dclst, 0);
;;;4525   #else
;;;4526   					res = remove_chain(&dj.obj, dclst, 0);
00008e  2200              MOVS     r2,#0
000090  4629              MOV      r1,r5
000092  a80d              ADD      r0,sp,#0x34
000094  f7fffffe          BL       remove_chain
000098  4604              MOV      r4,r0
                  |L27.154|
;;;4527   #endif
;;;4528   				}
;;;4529   				if (res == FR_OK) res = sync_fs(fs);
00009a  b91c              CBNZ     r4,|L27.164|
00009c  9801              LDR      r0,[sp,#4]
00009e  f7fffffe          BL       sync_fs
0000a2  4604              MOV      r4,r0
                  |L27.164|
;;;4530   			}
;;;4531   		}
;;;4532   		FREE_NAMBUF();
;;;4533   	}
;;;4534   
;;;4535   	LEAVE_FF(fs, res);
0000a4  4620              MOV      r0,r4
;;;4536   }
0000a6  b019              ADD      sp,sp,#0x64
0000a8  bd30              POP      {r4,r5,pc}
;;;4537   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;3545   
;;;3546   FRESULT f_write (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3547   	FIL* fp,			/* Pointer to the file object */
;;;3548   	const void* buff,	/* Pointer to the data to be written */
;;;3549   	UINT btw,			/* Number of bytes to write */
;;;3550   	UINT* bw			/* Pointer to number of bytes written */
;;;3551   )
;;;3552   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  469b              MOV      r11,r3
;;;3553   	FRESULT res;
;;;3554   	FATFS *fs;
;;;3555   	DWORD clst, sect;
;;;3556   	UINT wcnt, cc, csect;
;;;3557   	const BYTE *wbuff = (const BYTE*)buff;
00000c  9804              LDR      r0,[sp,#0x10]
00000e  9000              STR      r0,[sp,#0]
;;;3558   
;;;3559   
;;;3560   	*bw = 0;	/* Clear write byte counter */
000010  2000              MOVS     r0,#0
000012  f8cb0000          STR      r0,[r11,#0]
;;;3561   	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
000016  a901              ADD      r1,sp,#4
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       validate
00001e  9002              STR      r0,[sp,#8]
;;;3562   	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
000020  9802              LDR      r0,[sp,#8]
000022  b910              CBNZ     r0,|L28.42|
000024  7c60              LDRB     r0,[r4,#0x11]
000026  9002              STR      r0,[sp,#8]
000028  b118              CBZ      r0,|L28.50|
                  |L28.42|
00002a  9802              LDR      r0,[sp,#8]
                  |L28.44|
;;;3563   	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
;;;3564   
;;;3565   	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
;;;3566   	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
;;;3567   		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
;;;3568   	}
;;;3569   
;;;3570   	for ( ;  btw;							/* Repeat until all data written */
;;;3571   		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
;;;3572   		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
;;;3573   			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
;;;3574   			if (csect == 0) {				/* On the cluster boundary? */
;;;3575   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;3576   					clst = fp->obj.sclust;	/* Follow from the origin */
;;;3577   					if (clst == 0) {		/* If no cluster is allocated, */
;;;3578   						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
;;;3579   					}
;;;3580   				} else {					/* On the middle or end of the file */
;;;3581   #if _USE_FASTSEEK
;;;3582   					if (fp->cltbl) {
;;;3583   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;3584   					} else
;;;3585   #endif
;;;3586   					{
;;;3587   						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;3588   					}
;;;3589   				}
;;;3590   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;3591   				if (clst == 1) ABORT(fs, FR_INT_ERR);
;;;3592   				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
;;;3593   				fp->clust = clst;			/* Update current cluster */
;;;3594   				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
;;;3595   			}
;;;3596   #if _FS_TINY
;;;3597   			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
;;;3598   #else
;;;3599   			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
;;;3600   				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3601   				fp->flag &= (BYTE)~FA_DIRTY;
;;;3602   			}
;;;3603   #endif
;;;3604   			sect = clust2sect(fs, fp->clust);	/* Get current sector */
;;;3605   			if (!sect) ABORT(fs, FR_INT_ERR);
;;;3606   			sect += csect;
;;;3607   			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
;;;3608   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;3609   				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
;;;3610   					cc = fs->csize - csect;
;;;3611   				}
;;;3612   				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
;;;3613   #if _FS_MINIMIZE <= 2
;;;3614   #if _FS_TINY
;;;3615   				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;3616   					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
;;;3617   					fs->wflag = 0;
;;;3618   				}
;;;3619   #else
;;;3620   				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;3621   					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
;;;3622   					fp->flag &= (BYTE)~FA_DIRTY;
;;;3623   				}
;;;3624   #endif
;;;3625   #endif
;;;3626   				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
;;;3627   				continue;
;;;3628   			}
;;;3629   #if _FS_TINY
;;;3630   			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
;;;3631   				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
;;;3632   				fs->winsect = sect;
;;;3633   			}
;;;3634   #else
;;;3635   			if (fp->sect != sect && 		/* Fill sector cache with file data */
;;;3636   				fp->fptr < fp->obj.objsize &&
;;;3637   				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
;;;3638   					ABORT(fs, FR_DISK_ERR);
;;;3639   			}
;;;3640   #endif
;;;3641   			fp->sect = sect;
;;;3642   		}
;;;3643   		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
;;;3644   		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
;;;3645   #if _FS_TINY
;;;3646   		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
;;;3647   		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
;;;3648   		fs->wflag = 1;
;;;3649   #else
;;;3650   		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
;;;3651   		fp->flag |= FA_DIRTY;
;;;3652   #endif
;;;3653   	}
;;;3654   
;;;3655   	fp->flag |= FA_MODIFIED;				/* Set file change flag */
;;;3656   
;;;3657   	LEAVE_FF(fs, FR_OK);
;;;3658   }
00002c  b007              ADD      sp,sp,#0x1c
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L28.50|
000032  7c20              LDRB     r0,[r4,#0x10]         ;3563
000034  f0000002          AND      r0,r0,#2              ;3563
000038  b908              CBNZ     r0,|L28.62|
00003a  2007              MOVS     r0,#7                 ;3563
00003c  e7f6              B        |L28.44|
                  |L28.62|
00003e  bf00              NOP                            ;3566
000040  6960              LDR      r0,[r4,#0x14]         ;3566
000042  4428              ADD      r0,r0,r5              ;3566
000044  6961              LDR      r1,[r4,#0x14]         ;3566
000046  4288              CMP      r0,r1                 ;3566
000048  d202              BCS      |L28.80|
00004a  6960              LDR      r0,[r4,#0x14]         ;3567
00004c  f1c035ff          RSB      r5,r0,#0xffffffff     ;3567
                  |L28.80|
000050  e0bb              B        |L28.458|
                  |L28.82|
000052  8aa0              LDRH     r0,[r4,#0x14]         ;3572
000054  f3c00008          UBFX     r0,r0,#0,#9           ;3572
000058  2800              CMP      r0,#0                 ;3572
00005a  d175              BNE      |L28.328|
00005c  9801              LDR      r0,[sp,#4]            ;3573
00005e  8940              LDRH     r0,[r0,#0xa]          ;3573
000060  1e40              SUBS     r0,r0,#1              ;3573
000062  6961              LDR      r1,[r4,#0x14]         ;3573
000064  ea002a51          AND      r10,r0,r1,LSR #9      ;3573
000068  f1ba0f00          CMP      r10,#0                ;3574
00006c  d11e              BNE      |L28.172|
00006e  6960              LDR      r0,[r4,#0x14]         ;3575
000070  b938              CBNZ     r0,|L28.130|
000072  68a7              LDR      r7,[r4,#8]            ;3576
000074  b957              CBNZ     r7,|L28.140|
000076  2100              MOVS     r1,#0                 ;3578
000078  4620              MOV      r0,r4                 ;3578
00007a  f7fffffe          BL       create_chain
00007e  4607              MOV      r7,r0                 ;3578
000080  e004              B        |L28.140|
                  |L28.130|
000082  4620              MOV      r0,r4                 ;3587
000084  69a1              LDR      r1,[r4,#0x18]         ;3587
000086  f7fffffe          BL       create_chain
00008a  4607              MOV      r7,r0                 ;3587
                  |L28.140|
00008c  b907              CBNZ     r7,|L28.144|
00008e  e09f              B        |L28.464|
                  |L28.144|
000090  2f01              CMP      r7,#1                 ;3591
000092  d102              BNE      |L28.154|
000094  2002              MOVS     r0,#2                 ;3591
000096  7460              STRB     r0,[r4,#0x11]         ;3591
000098  e7c8              B        |L28.44|
                  |L28.154|
00009a  1c78              ADDS     r0,r7,#1              ;3592
00009c  b910              CBNZ     r0,|L28.164|
00009e  2001              MOVS     r0,#1                 ;3592
0000a0  7460              STRB     r0,[r4,#0x11]         ;3592
0000a2  e7c3              B        |L28.44|
                  |L28.164|
0000a4  61a7              STR      r7,[r4,#0x18]         ;3593
0000a6  68a0              LDR      r0,[r4,#8]            ;3594
0000a8  b900              CBNZ     r0,|L28.172|
0000aa  60a7              STR      r7,[r4,#8]            ;3594
                  |L28.172|
0000ac  7c20              LDRB     r0,[r4,#0x10]         ;3599
0000ae  f0000080          AND      r0,r0,#0x80           ;3599
0000b2  b178              CBZ      r0,|L28.212|
0000b4  69e2              LDR      r2,[r4,#0x1c]         ;3600
0000b6  9901              LDR      r1,[sp,#4]            ;3600
0000b8  7848              LDRB     r0,[r1,#1]            ;3600
0000ba  2301              MOVS     r3,#1                 ;3600
0000bc  f1040128          ADD      r1,r4,#0x28           ;3600
0000c0  f7fffffe          BL       disk_write
0000c4  b110              CBZ      r0,|L28.204|
0000c6  2001              MOVS     r0,#1                 ;3600
0000c8  7460              STRB     r0,[r4,#0x11]         ;3600
0000ca  e7af              B        |L28.44|
                  |L28.204|
0000cc  7c20              LDRB     r0,[r4,#0x10]         ;3601
0000ce  f000007f          AND      r0,r0,#0x7f           ;3601
0000d2  7420              STRB     r0,[r4,#0x10]         ;3601
                  |L28.212|
0000d4  69a1              LDR      r1,[r4,#0x18]         ;3604
0000d6  9801              LDR      r0,[sp,#4]            ;3604
0000d8  f7fffffe          BL       clust2sect
0000dc  4606              MOV      r6,r0                 ;3604
0000de  b916              CBNZ     r6,|L28.230|
0000e0  2002              MOVS     r0,#2                 ;3605
0000e2  7460              STRB     r0,[r4,#0x11]         ;3605
0000e4  e7a2              B        |L28.44|
                  |L28.230|
0000e6  4456              ADD      r6,r6,r10             ;3606
0000e8  ea4f2955          LSR      r9,r5,#9              ;3607
0000ec  f1b90f00          CMP      r9,#0                 ;3608
0000f0  d02b              BEQ      |L28.330|
0000f2  eb0a0009          ADD      r0,r10,r9             ;3609
0000f6  9901              LDR      r1,[sp,#4]            ;3609
0000f8  8949              LDRH     r1,[r1,#0xa]          ;3609
0000fa  4288              CMP      r0,r1                 ;3609
0000fc  d903              BLS      |L28.262|
0000fe  9801              LDR      r0,[sp,#4]            ;3610
000100  8940              LDRH     r0,[r0,#0xa]          ;3610
000102  eba0090a          SUB      r9,r0,r10             ;3610
                  |L28.262|
000106  9901              LDR      r1,[sp,#4]            ;3612
000108  7848              LDRB     r0,[r1,#1]            ;3612
00010a  464b              MOV      r3,r9                 ;3612
00010c  4632              MOV      r2,r6                 ;3612
00010e  9900              LDR      r1,[sp,#0]            ;3612
000110  f7fffffe          BL       disk_write
000114  b110              CBZ      r0,|L28.284|
000116  2001              MOVS     r0,#1                 ;3612
000118  7460              STRB     r0,[r4,#0x11]         ;3612
00011a  e787              B        |L28.44|
                  |L28.284|
00011c  69e0              LDR      r0,[r4,#0x1c]         ;3620
00011e  1b80              SUBS     r0,r0,r6              ;3620
000120  4548              CMP      r0,r9                 ;3620
000122  d20e              BCS      |L28.322|
000124  69e0              LDR      r0,[r4,#0x1c]         ;3621
000126  1b80              SUBS     r0,r0,r6              ;3621
000128  9a00              LDR      r2,[sp,#0]            ;3621
00012a  eb022140          ADD      r1,r2,r0,LSL #9       ;3621
00012e  f44f7200          MOV      r2,#0x200             ;3621
000132  f1040028          ADD      r0,r4,#0x28           ;3621
000136  f7fffffe          BL       mem_cpy
00013a  7c20              LDRB     r0,[r4,#0x10]         ;3622
00013c  f000007f          AND      r0,r0,#0x7f           ;3622
000140  7420              STRB     r0,[r4,#0x10]         ;3622
                  |L28.322|
000142  ea4f2849          LSL      r8,r9,#9              ;3626
000146  e02b              B        |L28.416|
                  |L28.328|
000148  e013              B        |L28.370|
                  |L28.330|
00014a  69e0              LDR      r0,[r4,#0x1c]         ;3635
00014c  42b0              CMP      r0,r6                 ;3635
00014e  d00f              BEQ      |L28.368|
000150  68e1              LDR      r1,[r4,#0xc]          ;3636
000152  6960              LDR      r0,[r4,#0x14]         ;3636
000154  4288              CMP      r0,r1                 ;3636
000156  d20b              BCS      |L28.368|
000158  9901              LDR      r1,[sp,#4]            ;3637
00015a  7848              LDRB     r0,[r1,#1]            ;3637
00015c  2301              MOVS     r3,#1                 ;3637
00015e  4632              MOV      r2,r6                 ;3637
000160  f1040128          ADD      r1,r4,#0x28           ;3637
000164  f7fffffe          BL       disk_read
000168  b110              CBZ      r0,|L28.368|
00016a  2001              MOVS     r0,#1                 ;3638
00016c  7460              STRB     r0,[r4,#0x11]         ;3638
00016e  e75d              B        |L28.44|
                  |L28.368|
000170  61e6              STR      r6,[r4,#0x1c]         ;3641
                  |L28.370|
000172  8aa0              LDRH     r0,[r4,#0x14]         ;3643
000174  f3c00008          UBFX     r0,r0,#0,#9           ;3643
000178  f5c07800          RSB      r8,r0,#0x200          ;3643
00017c  45a8              CMP      r8,r5                 ;3644
00017e  d900              BLS      |L28.386|
000180  46a8              MOV      r8,r5                 ;3644
                  |L28.386|
000182  8aa1              LDRH     r1,[r4,#0x14]         ;3650
000184  f3c10208          UBFX     r2,r1,#0,#9           ;3650
000188  f1040128          ADD      r1,r4,#0x28           ;3650
00018c  1850              ADDS     r0,r2,r1              ;3650
00018e  4642              MOV      r2,r8                 ;3650
000190  9900              LDR      r1,[sp,#0]            ;3650
000192  f7fffffe          BL       mem_cpy
000196  7c20              LDRB     r0,[r4,#0x10]         ;3651
000198  f0400080          ORR      r0,r0,#0x80           ;3651
00019c  7420              STRB     r0,[r4,#0x10]         ;3651
00019e  bf00              NOP                            ;3627
                  |L28.416|
0001a0  9800              LDR      r0,[sp,#0]            ;3571
0001a2  4440              ADD      r0,r0,r8              ;3571
0001a4  9000              STR      r0,[sp,#0]            ;3571
0001a6  6960              LDR      r0,[r4,#0x14]         ;3571
0001a8  4440              ADD      r0,r0,r8              ;3571
0001aa  6160              STR      r0,[r4,#0x14]         ;3571
0001ac  68e1              LDR      r1,[r4,#0xc]          ;3571
0001ae  6960              LDR      r0,[r4,#0x14]         ;3571
0001b0  4288              CMP      r0,r1                 ;3571
0001b2  d901              BLS      |L28.440|
0001b4  6960              LDR      r0,[r4,#0x14]         ;3571
0001b6  e000              B        |L28.442|
                  |L28.440|
0001b8  68e0              LDR      r0,[r4,#0xc]          ;3571
                  |L28.442|
0001ba  60e0              STR      r0,[r4,#0xc]          ;3571
0001bc  f8db0000          LDR      r0,[r11,#0]           ;3571
0001c0  4440              ADD      r0,r0,r8              ;3571
0001c2  f8cb0000          STR      r0,[r11,#0]           ;3571
0001c6  eba50508          SUB      r5,r5,r8              ;3571
                  |L28.458|
0001ca  2d00              CMP      r5,#0                 ;3570
0001cc  f47faf41          BNE      |L28.82|
                  |L28.464|
0001d0  bf00              NOP                            ;3590
0001d2  7c20              LDRB     r0,[r4,#0x10]         ;3655
0001d4  f0400040          ORR      r0,r0,#0x40           ;3655
0001d8  7420              STRB     r0,[r4,#0x10]         ;3655
0001da  2000              MOVS     r0,#0                 ;3657
0001dc  e726              B        |L28.44|
;;;3659   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2941   static
;;;2942   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;2943   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2944   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2945   	BYTE mode			/* !=0: Check write protection for write access */
;;;2946   )
;;;2947   {
000004  b08a              SUB      sp,sp,#0x28
;;;2948   	BYTE fmt, *pt;
;;;2949   	int vol;
;;;2950   	DSTATUS stat;
;;;2951   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
;;;2952   	WORD nrsv;
;;;2953   	FATFS *fs;
;;;2954   	UINT i;
;;;2955   
;;;2956   
;;;2957   	/* Get logical drive number */
;;;2958   	*rfs = 0;
000006  2100              MOVS     r1,#0
000008  980b              LDR      r0,[sp,#0x2c]
00000a  6001              STR      r1,[r0,#0]
;;;2959   	vol = get_ldnumber(path);
00000c  980a              LDR      r0,[sp,#0x28]
00000e  f7fffffe          BL       get_ldnumber
000012  9008              STR      r0,[sp,#0x20]
;;;2960   	if (vol < 0) return FR_INVALID_DRIVE;
000014  9808              LDR      r0,[sp,#0x20]
000016  2800              CMP      r0,#0
000018  da03              BGE      |L29.34|
00001a  200b              MOVS     r0,#0xb
                  |L29.28|
;;;2961   
;;;2962   	/* Check if the file system object is valid or not */
;;;2963   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;2964   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2965   
;;;2966   	ENTER_FF(fs);						/* Lock the volume */
;;;2967   	*rfs = fs;							/* Return pointer to the file system object */
;;;2968   
;;;2969   	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
;;;2970   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2971   		stat = disk_status(fs->drv);
;;;2972   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;2973   			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
;;;2974   				return FR_WRITE_PROTECTED;
;;;2975   			}
;;;2976   			return FR_OK;				/* The file system object is valid */
;;;2977   		}
;;;2978   	}
;;;2979   
;;;2980   	/* The file system object is not valid. */
;;;2981   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2982   
;;;2983   	fs->fs_type = 0;					/* Clear the file system object */
;;;2984   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2985   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2986   	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
;;;2987   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2988   	}
;;;2989   	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
;;;2990   		return FR_WRITE_PROTECTED;
;;;2991   	}
;;;2992   #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
;;;2993   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
;;;2994   	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
;;;2995   #endif
;;;2996   	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;;;2997   	bsect = 0;
;;;2998   	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
;;;2999   	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
;;;3000   		for (i = 0; i < 4; i++) {			/* Get partition offset */
;;;3001   			pt = fs->win + (MBR_Table + i * SZ_PTE);
;;;3002   			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
;;;3003   		}
;;;3004   		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;;;3005   		if (i) i--;
;;;3006   		do {								/* Find an FAT volume */
;;;3007   			bsect = br[i];
;;;3008   			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
;;;3009   		} while (!LD2PT(vol) && fmt >= 2 && ++i < 4);
;;;3010   	}
;;;3011   	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;3012   	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
;;;3013   
;;;3014   	/* An FAT volume is found. Following code initializes the file system object */
;;;3015   
;;;3016   #if _FS_EXFAT
;;;3017   	if (fmt == 1) {
;;;3018   		QWORD maxlba;
;;;3019   
;;;3020   		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
;;;3021   		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
;;;3022   
;;;3023   		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
;;;3024   
;;;3025   		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs))	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
;;;3026   			return FR_NO_FILESYSTEM;
;;;3027   
;;;3028   		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
;;;3029   		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
;;;3030   
;;;3031   		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
;;;3032   
;;;3033   		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
;;;3034   		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
;;;3035   
;;;3036   		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
;;;3037   		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
;;;3038   
;;;3039   		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
;;;3040   		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
;;;3041   		fs->n_fatent = nclst + 2;
;;;3042   
;;;3043   		/* Boundaries and Limits */
;;;3044   		fs->volbase = bsect;
;;;3045   		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
;;;3046   		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
;;;3047   		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
;;;3048   		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
;;;3049   
;;;3050   		/* Check if bitmap location is in assumption (at the first cluster) */
;;;3051   		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
;;;3052   		for (i = 0; i < SS(fs); i += SZDIRE) {
;;;3053   			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
;;;3054   		}
;;;3055   		if (i == SS(fs)) return FR_NO_FILESYSTEM;
;;;3056   #if !_FS_READONLY
;;;3057   		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
;;;3058   #endif
;;;3059   		fmt = FS_EXFAT;			/* FAT sub-type */
;;;3060   	} else
;;;3061   #endif	/* _FS_EXFAT */
;;;3062   	{
;;;3063   		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;3064   
;;;3065   		fasize = ld_word(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
;;;3066   		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
;;;3067   		fs->fsize = fasize;
;;;3068   
;;;3069   		fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FATs */
;;;3070   		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
;;;3071   		fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;;;3072   
;;;3073   		fs->csize = fs->win[BPB_SecPerClus];				/* Cluster size */
;;;3074   		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
;;;3075   
;;;3076   		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
;;;3077   		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
;;;3078   
;;;3079   		tsect = ld_word(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
;;;3080   		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
;;;3081   
;;;3082   		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
;;;3083   		if (nrsv == 0) return FR_NO_FILESYSTEM;				/* (Must not be 0) */
;;;3084   
;;;3085   		/* Determine the FAT sub type */
;;;3086   		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
;;;3087   		if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;3088   		nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;3089   		if (nclst == 0) return FR_NO_FILESYSTEM;			/* (Invalid volume size) */
;;;3090   		fmt = FS_FAT32;
;;;3091   		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
;;;3092   		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
;;;3093   
;;;3094   		/* Boundaries and Limits */
;;;3095   		fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;3096   		fs->volbase = bsect;								/* Volume start sector */
;;;3097   		fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;3098   		fs->database = bsect + sysect;						/* Data start sector */
;;;3099   		if (fmt == FS_FAT32) {
;;;3100   			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
;;;3101   			if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;3102   			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
;;;3103   			szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
;;;3104   		} else {
;;;3105   			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
;;;3106   			fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;3107   			szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
;;;3108   				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;3109   		}
;;;3110   		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
;;;3111   
;;;3112   #if !_FS_READONLY
;;;3113   		/* Get FSINFO if available */
;;;3114   		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
;;;3115   		fs->fsi_flag = 0x80;
;;;3116   #if (_FS_NOFSINFO & 3) != 3
;;;3117   		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
;;;3118   			&& ld_word(fs->win + BPB_FSInfo32) == 1
;;;3119   			&& move_window(fs, bsect + 1) == FR_OK)
;;;3120   		{
;;;3121   			fs->fsi_flag = 0;
;;;3122   			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;3123   				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
;;;3124   				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
;;;3125   			{
;;;3126   #if (_FS_NOFSINFO & 1) == 0
;;;3127   				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
;;;3128   #endif
;;;3129   #if (_FS_NOFSINFO & 2) == 0
;;;3130   				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
;;;3131   #endif
;;;3132   			}
;;;3133   		}
;;;3134   #endif	/* (_FS_NOFSINFO & 3) != 3 */
;;;3135   #endif	/* !_FS_READONLY */
;;;3136   	}
;;;3137   
;;;3138   	fs->fs_type = fmt;	/* FAT sub-type */
;;;3139   	fs->id = ++Fsid;	/* File system mount ID */
;;;3140   #if _USE_LFN == 1
;;;3141   	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
;;;3142   #if _FS_EXFAT
;;;3143   	fs->dirbuf = DirBuf;	/* Static directory block working buuffer */
;;;3144   #endif
;;;3145   #endif
;;;3146   #if _FS_RPATH != 0
;;;3147   	fs->cdir = 0;		/* Initialize current directory */
;;;3148   #endif
;;;3149   #if _FS_LOCK != 0		/* Clear file lock semaphores */
;;;3150   	clear_lock(fs);
;;;3151   #endif
;;;3152   	return FR_OK;
;;;3153   }
00001c  b00d              ADD      sp,sp,#0x34
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L29.34|
000022  49b1              LDR      r1,|L29.744|
000024  9808              LDR      r0,[sp,#0x20]         ;2963
000026  f8514020          LDR      r4,[r1,r0,LSL #2]     ;2963
00002a  b90c              CBNZ     r4,|L29.48|
00002c  200c              MOVS     r0,#0xc               ;2964
00002e  e7f5              B        |L29.28|
                  |L29.48|
000030  980b              LDR      r0,[sp,#0x2c]         ;2967
000032  6004              STR      r4,[r0,#0]            ;2967
000034  980c              LDR      r0,[sp,#0x30]         ;2969
000036  f00000fe          AND      r0,r0,#0xfe           ;2969
00003a  900c              STR      r0,[sp,#0x30]         ;2969
00003c  7820              LDRB     r0,[r4,#0]            ;2970
00003e  b178              CBZ      r0,|L29.96|
000040  7860              LDRB     r0,[r4,#1]            ;2971
000042  f7fffffe          BL       disk_status
000046  4681              MOV      r9,r0                 ;2971
000048  f0090001          AND      r0,r9,#1              ;2972
00004c  b940              CBNZ     r0,|L29.96|
00004e  980c              LDR      r0,[sp,#0x30]         ;2973
000050  b120              CBZ      r0,|L29.92|
000052  f0090004          AND      r0,r9,#4              ;2973
000056  b108              CBZ      r0,|L29.92|
000058  200a              MOVS     r0,#0xa               ;2974
00005a  e7df              B        |L29.28|
                  |L29.92|
00005c  2000              MOVS     r0,#0                 ;2976
00005e  e7dd              B        |L29.28|
                  |L29.96|
000060  2000              MOVS     r0,#0                 ;2983
000062  7020              STRB     r0,[r4,#0]            ;2983
000064  9808              LDR      r0,[sp,#0x20]         ;2984
000066  7060              STRB     r0,[r4,#1]            ;2984
000068  7860              LDRB     r0,[r4,#1]            ;2985
00006a  f7fffffe          BL       disk_initialize
00006e  4681              MOV      r9,r0                 ;2985
000070  f0090001          AND      r0,r9,#1              ;2986
000074  b108              CBZ      r0,|L29.122|
000076  2003              MOVS     r0,#3                 ;2987
000078  e7d0              B        |L29.28|
                  |L29.122|
00007a  980c              LDR      r0,[sp,#0x30]         ;2989
00007c  b120              CBZ      r0,|L29.136|
00007e  f0090004          AND      r0,r9,#4              ;2989
000082  b108              CBZ      r0,|L29.136|
000084  200a              MOVS     r0,#0xa               ;2990
000086  e7c9              B        |L29.28|
                  |L29.136|
000088  2700              MOVS     r7,#0                 ;2997
00008a  4639              MOV      r1,r7                 ;2998
00008c  4620              MOV      r0,r4                 ;2998
00008e  f7fffffe          BL       check_fs
000092  4605              MOV      r5,r0                 ;2998
000094  2d02              CMP      r5,#2                 ;2999
000096  d001              BEQ      |L29.156|
000098  da2e              BGE      |L29.248|
00009a  e02d              B        |L29.248|
                  |L29.156|
00009c  2600              MOVS     r6,#0                 ;3000
00009e  e014              B        |L29.202|
                  |L29.160|
0000a0  f44f70df          MOV      r0,#0x1be             ;3001
0000a4  eb001106          ADD      r1,r0,r6,LSL #4       ;3001
0000a8  f1040030          ADD      r0,r4,#0x30           ;3001
0000ac  4408              ADD      r0,r0,r1              ;3001
0000ae  9009              STR      r0,[sp,#0x24]         ;3001
0000b0  9809              LDR      r0,[sp,#0x24]         ;3002
0000b2  7900              LDRB     r0,[r0,#4]            ;3002
0000b4  b120              CBZ      r0,|L29.192|
0000b6  9809              LDR      r0,[sp,#0x24]         ;3002
0000b8  3008              ADDS     r0,r0,#8              ;3002
0000ba  f7fffffe          BL       ld_dword
0000be  e000              B        |L29.194|
                  |L29.192|
0000c0  2000              MOVS     r0,#0                 ;3002
                  |L29.194|
0000c2  a902              ADD      r1,sp,#8              ;3002
0000c4  f8410026          STR      r0,[r1,r6,LSL #2]     ;3002
0000c8  1c76              ADDS     r6,r6,#1              ;3000
                  |L29.202|
0000ca  2e04              CMP      r6,#4                 ;3000
0000cc  d3e8              BCC      |L29.160|
0000ce  2600              MOVS     r6,#0                 ;3004
0000d0  b106              CBZ      r6,|L29.212|
0000d2  1e76              SUBS     r6,r6,#1              ;3005
                  |L29.212|
0000d4  bf00              NOP                            ;3006
                  |L29.214|
0000d6  a802              ADD      r0,sp,#8              ;3007
0000d8  f8507026          LDR      r7,[r0,r6,LSL #2]     ;3007
0000dc  b127              CBZ      r7,|L29.232|
0000de  4639              MOV      r1,r7                 ;3008
0000e0  4620              MOV      r0,r4                 ;3008
0000e2  f7fffffe          BL       check_fs
0000e6  e000              B        |L29.234|
                  |L29.232|
0000e8  2003              MOVS     r0,#3                 ;3008
                  |L29.234|
0000ea  4605              MOV      r5,r0                 ;3008
0000ec  2d02              CMP      r5,#2                 ;3009
0000ee  db03              BLT      |L29.248|
0000f0  1c70              ADDS     r0,r6,#1              ;3009
0000f2  4606              MOV      r6,r0                 ;3009
0000f4  2804              CMP      r0,#4                 ;3009
0000f6  d3ee              BCC      |L29.214|
                  |L29.248|
0000f8  2d04              CMP      r5,#4                 ;3011
0000fa  d101              BNE      |L29.256|
0000fc  2001              MOVS     r0,#1                 ;3011
0000fe  e78d              B        |L29.28|
                  |L29.256|
000100  2d02              CMP      r5,#2                 ;3012
000102  db01              BLT      |L29.264|
000104  200d              MOVS     r0,#0xd               ;3012
000106  e789              B        |L29.28|
                  |L29.264|
000108  f104003b          ADD      r0,r4,#0x3b           ;3063
00010c  f7fffffe          BL       ld_word
000110  f5b07f00          CMP      r0,#0x200             ;3063
000114  d001              BEQ      |L29.282|
000116  200d              MOVS     r0,#0xd               ;3063
000118  e780              B        |L29.28|
                  |L29.282|
00011a  f1040046          ADD      r0,r4,#0x46           ;3065
00011e  f7fffffe          BL       ld_word
000122  4680              MOV      r8,r0                 ;3065
000124  f1b80f00          CMP      r8,#0                 ;3066
000128  d104              BNE      |L29.308|
00012a  f1040054          ADD      r0,r4,#0x54           ;3066
00012e  f7fffffe          BL       ld_dword
000132  4680              MOV      r8,r0                 ;3066
                  |L29.308|
000134  f8c48018          STR      r8,[r4,#0x18]         ;3067
000138  2040              MOVS     r0,#0x40              ;3069
00013a  5d00              LDRB     r0,[r0,r4]            ;3069
00013c  70a0              STRB     r0,[r4,#2]            ;3069
00013e  78a0              LDRB     r0,[r4,#2]            ;3070
000140  2801              CMP      r0,#1                 ;3070
000142  d004              BEQ      |L29.334|
000144  78a0              LDRB     r0,[r4,#2]            ;3070
000146  2802              CMP      r0,#2                 ;3070
000148  d001              BEQ      |L29.334|
00014a  200d              MOVS     r0,#0xd               ;3070
00014c  e766              B        |L29.28|
                  |L29.334|
00014e  78a0              LDRB     r0,[r4,#2]            ;3071
000150  fb08f800          MUL      r8,r8,r0              ;3071
000154  203d              MOVS     r0,#0x3d              ;3073
000156  5d00              LDRB     r0,[r0,r4]            ;3073
000158  8160              STRH     r0,[r4,#0xa]          ;3073
00015a  8960              LDRH     r0,[r4,#0xa]          ;3074
00015c  b118              CBZ      r0,|L29.358|
00015e  8960              LDRH     r0,[r4,#0xa]          ;3074
000160  1e41              SUBS     r1,r0,#1              ;3074
000162  4008              ANDS     r0,r0,r1              ;3074
000164  b108              CBZ      r0,|L29.362|
                  |L29.358|
000166  200d              MOVS     r0,#0xd               ;3074
000168  e758              B        |L29.28|
                  |L29.362|
00016a  f1040041          ADD      r0,r4,#0x41           ;3076
00016e  f7fffffe          BL       ld_word
000172  8120              STRH     r0,[r4,#8]            ;3076
000174  7a20              LDRB     r0,[r4,#8]            ;3077
000176  f000000f          AND      r0,r0,#0xf            ;3077
00017a  b108              CBZ      r0,|L29.384|
00017c  200d              MOVS     r0,#0xd               ;3077
00017e  e74d              B        |L29.28|
                  |L29.384|
000180  f1040043          ADD      r0,r4,#0x43           ;3079
000184  f7fffffe          BL       ld_word
000188  4682              MOV      r10,r0                ;3079
00018a  f1ba0f00          CMP      r10,#0                ;3080
00018e  d104              BNE      |L29.410|
000190  f1040050          ADD      r0,r4,#0x50           ;3080
000194  f7fffffe          BL       ld_dword
000198  4682              MOV      r10,r0                ;3080
                  |L29.410|
00019a  f104003e          ADD      r0,r4,#0x3e           ;3082
00019e  f7fffffe          BL       ld_word
0001a2  9001              STR      r0,[sp,#4]            ;3082
0001a4  9801              LDR      r0,[sp,#4]            ;3083
0001a6  b908              CBNZ     r0,|L29.428|
0001a8  200d              MOVS     r0,#0xd               ;3083
0001aa  e737              B        |L29.28|
                  |L29.428|
0001ac  9801              LDR      r0,[sp,#4]            ;3086
0001ae  4440              ADD      r0,r0,r8              ;3086
0001b0  8921              LDRH     r1,[r4,#8]            ;3086
0001b2  eb001011          ADD      r0,r0,r1,LSR #4       ;3086
0001b6  9007              STR      r0,[sp,#0x1c]         ;3086
0001b8  9807              LDR      r0,[sp,#0x1c]         ;3087
0001ba  4582              CMP      r10,r0                ;3087
0001bc  d201              BCS      |L29.450|
0001be  200d              MOVS     r0,#0xd               ;3087
0001c0  e72c              B        |L29.28|
                  |L29.450|
0001c2  9807              LDR      r0,[sp,#0x1c]         ;3088
0001c4  ebaa0000          SUB      r0,r10,r0             ;3088
0001c8  8961              LDRH     r1,[r4,#0xa]          ;3088
0001ca  fbb0fbf1          UDIV     r11,r0,r1             ;3088
0001ce  f1bb0f00          CMP      r11,#0                ;3089
0001d2  d101              BNE      |L29.472|
0001d4  200d              MOVS     r0,#0xd               ;3089
0001d6  e721              B        |L29.28|
                  |L29.472|
0001d8  2503              MOVS     r5,#3                 ;3090
0001da  f64f70f5          MOV      r0,#0xfff5            ;3091
0001de  4583              CMP      r11,r0                ;3091
0001e0  d800              BHI      |L29.484|
0001e2  2502              MOVS     r5,#2                 ;3091
                  |L29.484|
0001e4  f64070f5          MOV      r0,#0xff5             ;3092
0001e8  4583              CMP      r11,r0                ;3092
0001ea  d800              BHI      |L29.494|
0001ec  2501              MOVS     r5,#1                 ;3092
                  |L29.494|
0001ee  f10b0002          ADD      r0,r11,#2             ;3095
0001f2  6160              STR      r0,[r4,#0x14]         ;3095
0001f4  61e7              STR      r7,[r4,#0x1c]         ;3096
0001f6  9801              LDR      r0,[sp,#4]            ;3097
0001f8  4438              ADD      r0,r0,r7              ;3097
0001fa  6220              STR      r0,[r4,#0x20]         ;3097
0001fc  9807              LDR      r0,[sp,#0x1c]         ;3098
0001fe  4438              ADD      r0,r0,r7              ;3098
000200  62a0              STR      r0,[r4,#0x28]         ;3098
000202  2d03              CMP      r5,#3                 ;3099
000204  d113              BNE      |L29.558|
000206  f104005a          ADD      r0,r4,#0x5a           ;3100
00020a  f7fffffe          BL       ld_word
00020e  b108              CBZ      r0,|L29.532|
000210  200d              MOVS     r0,#0xd               ;3100
000212  e703              B        |L29.28|
                  |L29.532|
000214  8920              LDRH     r0,[r4,#8]            ;3101
000216  b108              CBZ      r0,|L29.540|
000218  200d              MOVS     r0,#0xd               ;3101
00021a  e6ff              B        |L29.28|
                  |L29.540|
00021c  f104005c          ADD      r0,r4,#0x5c           ;3102
000220  f7fffffe          BL       ld_dword
000224  6260              STR      r0,[r4,#0x24]         ;3102
000226  6960              LDR      r0,[r4,#0x14]         ;3103
000228  0080              LSLS     r0,r0,#2              ;3103
00022a  9006              STR      r0,[sp,#0x18]         ;3103
00022c  e014              B        |L29.600|
                  |L29.558|
00022e  8920              LDRH     r0,[r4,#8]            ;3105
000230  b908              CBNZ     r0,|L29.566|
000232  200d              MOVS     r0,#0xd               ;3105
000234  e6f2              B        |L29.28|
                  |L29.566|
000236  6a20              LDR      r0,[r4,#0x20]         ;3106
000238  4440              ADD      r0,r0,r8              ;3106
00023a  6260              STR      r0,[r4,#0x24]         ;3106
00023c  2d02              CMP      r5,#2                 ;3107
00023e  d102              BNE      |L29.582|
000240  6960              LDR      r0,[r4,#0x14]         ;3108
000242  0040              LSLS     r0,r0,#1              ;3108
000244  e007              B        |L29.598|
                  |L29.582|
000246  7d20              LDRB     r0,[r4,#0x14]         ;3108
000248  f0000001          AND      r0,r0,#1              ;3108
00024c  6961              LDR      r1,[r4,#0x14]         ;3108
00024e  eb010141          ADD      r1,r1,r1,LSL #1       ;3108
000252  eb000051          ADD      r0,r0,r1,LSR #1       ;3108
                  |L29.598|
000256  9006              STR      r0,[sp,#0x18]         ;3108
                  |L29.600|
000258  69a1              LDR      r1,[r4,#0x18]         ;3110
00025a  9806              LDR      r0,[sp,#0x18]         ;3110
00025c  f20010ff          ADD      r0,r0,#0x1ff          ;3110
000260  ebb12f50          CMP      r1,r0,LSR #9          ;3110
000264  d201              BCS      |L29.618|
000266  200d              MOVS     r0,#0xd               ;3110
000268  e6d8              B        |L29.28|
                  |L29.618|
00026a  f04f30ff          MOV      r0,#0xffffffff        ;3114
00026e  6120              STR      r0,[r4,#0x10]         ;3114
000270  60e0              STR      r0,[r4,#0xc]          ;3114
000272  2080              MOVS     r0,#0x80              ;3115
000274  7120              STRB     r0,[r4,#4]            ;3115
000276  2d03              CMP      r5,#3                 ;3117
000278  d12c              BNE      |L29.724|
00027a  f1040060          ADD      r0,r4,#0x60           ;3118
00027e  f7fffffe          BL       ld_word
000282  2801              CMP      r0,#1                 ;3118
000284  d126              BNE      |L29.724|
000286  1c79              ADDS     r1,r7,#1              ;3119
000288  4620              MOV      r0,r4                 ;3119
00028a  f7fffffe          BL       move_window
00028e  bb08              CBNZ     r0,|L29.724|
000290  2000              MOVS     r0,#0                 ;3121
000292  7120              STRB     r0,[r4,#4]            ;3121
000294  f204202e          ADD      r0,r4,#0x22e          ;3122
000298  f7fffffe          BL       ld_word
00029c  f64a2155          MOV      r1,#0xaa55            ;3122
0002a0  4288              CMP      r0,r1                 ;3122
0002a2  d117              BNE      |L29.724|
0002a4  f1040030          ADD      r0,r4,#0x30           ;3123
0002a8  f7fffffe          BL       ld_dword
0002ac  490f              LDR      r1,|L29.748|
0002ae  4288              CMP      r0,r1                 ;3123
0002b0  d110              BNE      |L29.724|
0002b2  f5047005          ADD      r0,r4,#0x214          ;3124
0002b6  f7fffffe          BL       ld_dword
0002ba  490d              LDR      r1,|L29.752|
0002bc  4288              CMP      r0,r1                 ;3124
0002be  d109              BNE      |L29.724|
0002c0  f5047006          ADD      r0,r4,#0x218          ;3127
0002c4  f7fffffe          BL       ld_dword
0002c8  6120              STR      r0,[r4,#0x10]         ;3127
0002ca  f5047007          ADD      r0,r4,#0x21c          ;3130
0002ce  f7fffffe          BL       ld_dword
0002d2  60e0              STR      r0,[r4,#0xc]          ;3130
                  |L29.724|
0002d4  7025              STRB     r5,[r4,#0]            ;3138
0002d6  4807              LDR      r0,|L29.756|
0002d8  8800              LDRH     r0,[r0,#0]            ;3139  ; Fsid
0002da  1c40              ADDS     r0,r0,#1              ;3139
0002dc  b280              UXTH     r0,r0                 ;3139
0002de  4905              LDR      r1,|L29.756|
0002e0  8008              STRH     r0,[r1,#0]            ;3139
0002e2  80e0              STRH     r0,[r4,#6]            ;3139
0002e4  2000              MOVS     r0,#0                 ;3152
0002e6  e699              B        |L29.28|
;;;3154   
                          ENDP

                  |L29.744|
                          DCD      FatFs
                  |L29.748|
                          DCD      0x41615252
                  |L29.752|
                          DCD      0x61417272
                  |L29.756|
                          DCD      Fsid

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2764   static
;;;2765   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;2766   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2767   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2768   )
;;;2769   {
000004  4604              MOV      r4,r0
;;;2770   	FRESULT res;
;;;2771   	BYTE ns;
;;;2772   	_FDID *obj = &dp->obj;
000006  4626              MOV      r6,r4
;;;2773   	FATFS *fs = obj->fs;
000008  f8d68000          LDR      r8,[r6,#0]
;;;2774   
;;;2775   
;;;2776   #if _FS_RPATH != 0
;;;2777   	if (*path != '/' && *path != '\\') {	/* Without heading separator */
;;;2778   		obj->sclust = fs->cdir;				/* Start from the current directory */
;;;2779   	} else
;;;2780   #endif
;;;2781   	{										/* With heading separator */
;;;2782   		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
00000c  e002              B        |L30.20|
                  |L30.14|
00000e  9801              LDR      r0,[sp,#4]
000010  1c40              ADDS     r0,r0,#1
000012  9001              STR      r0,[sp,#4]
                  |L30.20|
000014  9801              LDR      r0,[sp,#4]
000016  7800              LDRB     r0,[r0,#0]
000018  282f              CMP      r0,#0x2f
00001a  d0f8              BEQ      |L30.14|
00001c  9801              LDR      r0,[sp,#4]
00001e  7800              LDRB     r0,[r0,#0]
000020  285c              CMP      r0,#0x5c
000022  d0f4              BEQ      |L30.14|
;;;2783   		obj->sclust = 0;					/* Start from the root directory */
000024  2000              MOVS     r0,#0
000026  60b0              STR      r0,[r6,#8]
;;;2784   	}
;;;2785   #if _FS_EXFAT && _FS_RPATH != 0
;;;2786   	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
;;;2787   		DIR dj;
;;;2788   
;;;2789   		obj->c_scl = fs->cdc_scl;
;;;2790   		obj->c_size = fs->cdc_size;
;;;2791   		obj->c_ofs = fs->cdc_ofs;
;;;2792   		res = load_obj_dir(&dj, obj);
;;;2793   		if (res != FR_OK) return res;
;;;2794   		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
;;;2795   		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;2796   	}
;;;2797   #endif
;;;2798   
;;;2799   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
000028  9801              LDR      r0,[sp,#4]
00002a  7800              LDRB     r0,[r0,#0]
00002c  2820              CMP      r0,#0x20
00002e  d208              BCS      |L30.66|
;;;2800   		dp->fn[NSFLAG] = NS_NONAME;
000030  2180              MOVS     r1,#0x80
000032  202b              MOVS     r0,#0x2b
000034  5501              STRB     r1,[r0,r4]
;;;2801   		res = dir_sdi(dp, 0);
000036  2100              MOVS     r1,#0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       dir_sdi
00003e  4605              MOV      r5,r0
000040  e02c              B        |L30.156|
                  |L30.66|
;;;2802   
;;;2803   	} else {								/* Follow path */
;;;2804   		for (;;) {
000042  bf00              NOP      
                  |L30.68|
;;;2805   			res = create_name(dp, &path);	/* Get a segment name of the path */
000044  a901              ADD      r1,sp,#4
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       create_name
00004c  4605              MOV      r5,r0
;;;2806   			if (res != FR_OK) break;
00004e  b105              CBZ      r5,|L30.82|
000050  e023              B        |L30.154|
                  |L30.82|
;;;2807   			res = dir_find(dp);				/* Find an object with the segment name */
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       dir_find
000058  4605              MOV      r5,r0
;;;2808   			ns = dp->fn[NSFLAG];
00005a  202b              MOVS     r0,#0x2b
00005c  5d07              LDRB     r7,[r0,r4]
;;;2809   			if (res != FR_OK) {				/* Failed to find the object */
00005e  b13d              CBZ      r5,|L30.112|
;;;2810   				if (res == FR_NO_FILE) {	/* Object is not found */
000060  2d04              CMP      r5,#4
000062  d104              BNE      |L30.110|
;;;2811   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
000064  bf00              NOP      
;;;2812   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2813   						dp->fn[NSFLAG] = NS_NONAME;
;;;2814   						res = FR_OK;
;;;2815   					} else {							/* Could not find the object */
;;;2816   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
000066  f0070004          AND      r0,r7,#4
00006a  b900              CBNZ     r0,|L30.110|
00006c  2505              MOVS     r5,#5
                  |L30.110|
;;;2817   					}
;;;2818   				}
;;;2819   				break;
00006e  e014              B        |L30.154|
                  |L30.112|
;;;2820   			}
;;;2821   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
000070  f0070004          AND      r0,r7,#4
000074  b100              CBZ      r0,|L30.120|
000076  e010              B        |L30.154|
                  |L30.120|
;;;2822   			/* Get into the sub-directory */
;;;2823   			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
000078  79b0              LDRB     r0,[r6,#6]
00007a  f0000010          AND      r0,r0,#0x10
00007e  b908              CBNZ     r0,|L30.132|
;;;2824   				res = FR_NO_PATH; break;
000080  2505              MOVS     r5,#5
000082  e00a              B        |L30.154|
                  |L30.132|
;;;2825   			}
;;;2826   #if _FS_EXFAT
;;;2827   			if (fs->fs_type == FS_EXFAT) {
;;;2828   				obj->c_scl = obj->sclust;		/* Save containing directory information for next dir */
;;;2829   				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
;;;2830   				obj->c_ofs = dp->blk_ofs;
;;;2831   				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
;;;2832   				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
;;;2833   				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
;;;2834   			} else
;;;2835   #endif
;;;2836   			{
;;;2837   				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
000084  8a20              LDRH     r0,[r4,#0x10]
000086  f3c00208          UBFX     r2,r0,#0,#9
00008a  f1080030          ADD      r0,r8,#0x30
00008e  1811              ADDS     r1,r2,r0
000090  4640              MOV      r0,r8
000092  f7fffffe          BL       ld_clust
000096  60b0              STR      r0,[r6,#8]
000098  e7d4              B        |L30.68|
                  |L30.154|
00009a  bf00              NOP                            ;2806
                  |L30.156|
;;;2838   			}
;;;2839   		}
;;;2840   	}
;;;2841   
;;;2842   	return res;
00009c  4628              MOV      r0,r5
;;;2843   }
00009e  e8bd81fc          POP      {r2-r8,pc}
;;;2844   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;985    static
;;;986    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;987    	_FDID* obj,	/* Corresponding object */
;;;988    	DWORD clst	/* Cluster number to get the value */
;;;989    )
;;;990    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;991    	UINT wc, bc;
;;;992    	DWORD val;
;;;993    	FATFS *fs = obj->fs;
000008  f8d95000          LDR      r5,[r9,#0]
;;;994    
;;;995    
;;;996    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
00000c  2c02              CMP      r4,#2
00000e  d302              BCC      |L31.22|
000010  6968              LDR      r0,[r5,#0x14]
000012  42a0              CMP      r0,r4
000014  d802              BHI      |L31.28|
                  |L31.22|
;;;997    		val = 1;	/* Internal error */
000016  f04f0801          MOV      r8,#1
00001a  e05e              B        |L31.218|
                  |L31.28|
;;;998    
;;;999    	} else {
;;;1000   		val = 0xFFFFFFFF;	/* Default value falls on disk error */
00001c  f04f38ff          MOV      r8,#0xffffffff
;;;1001   
;;;1002   		switch (fs->fs_type) {
000020  7828              LDRB     r0,[r5,#0]
000022  2801              CMP      r0,#1
000024  d004              BEQ      |L31.48|
000026  2802              CMP      r0,#2
000028  d02c              BEQ      |L31.132|
00002a  2803              CMP      r0,#3
00002c  d151              BNE      |L31.210|
00002e  e03c              B        |L31.170|
                  |L31.48|
;;;1003   		case FS_FAT12 :
;;;1004   			bc = (UINT)clst; bc += bc / 2;
000030  4626              MOV      r6,r4
000032  eb060656          ADD      r6,r6,r6,LSR #1
;;;1005   			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
000036  6a28              LDR      r0,[r5,#0x20]
000038  eb002156          ADD      r1,r0,r6,LSR #9
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       move_window
000042  b100              CBZ      r0,|L31.70|
000044  e048              B        |L31.216|
                  |L31.70|
;;;1006   			wc = fs->win[bc++ % SS(fs)];
000046  4630              MOV      r0,r6
000048  1c76              ADDS     r6,r6,#1
00004a  f3c00108          UBFX     r1,r0,#0,#9
00004e  f1050030          ADD      r0,r5,#0x30
000052  5c47              LDRB     r7,[r0,r1]
;;;1007   			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
000054  6a28              LDR      r0,[r5,#0x20]
000056  eb002156          ADD      r1,r0,r6,LSR #9
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       move_window
000060  b100              CBZ      r0,|L31.100|
000062  e039              B        |L31.216|
                  |L31.100|
;;;1008   			wc |= fs->win[bc % SS(fs)] << 8;
000064  f3c60108          UBFX     r1,r6,#0,#9
000068  f1050030          ADD      r0,r5,#0x30
00006c  5c40              LDRB     r0,[r0,r1]
00006e  ea472700          ORR      r7,r7,r0,LSL #8
;;;1009   			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
000072  f0040001          AND      r0,r4,#1
000076  b108              CBZ      r0,|L31.124|
000078  0938              LSRS     r0,r7,#4
00007a  e001              B        |L31.128|
                  |L31.124|
00007c  f3c7000b          UBFX     r0,r7,#0,#12
                  |L31.128|
000080  4680              MOV      r8,r0
;;;1010   			break;
000082  e029              B        |L31.216|
                  |L31.132|
;;;1011   
;;;1012   		case FS_FAT16 :
;;;1013   			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
000084  6a28              LDR      r0,[r5,#0x20]
000086  eb002114          ADD      r1,r0,r4,LSR #8
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       move_window
000090  b100              CBZ      r0,|L31.148|
000092  e021              B        |L31.216|
                  |L31.148|
;;;1014   			val = ld_word(fs->win + clst * 2 % SS(fs));
000094  f24011ff          MOV      r1,#0x1ff
000098  ea010244          AND      r2,r1,r4,LSL #1
00009c  f1050130          ADD      r1,r5,#0x30
0000a0  1850              ADDS     r0,r2,r1
0000a2  f7fffffe          BL       ld_word
0000a6  4680              MOV      r8,r0
;;;1015   			break;
0000a8  e016              B        |L31.216|
                  |L31.170|
;;;1016   
;;;1017   		case FS_FAT32 :
;;;1018   			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
0000aa  6a28              LDR      r0,[r5,#0x20]
0000ac  eb0011d4          ADD      r1,r0,r4,LSR #7
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       move_window
0000b6  b100              CBZ      r0,|L31.186|
0000b8  e00e              B        |L31.216|
                  |L31.186|
;;;1019   			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
0000ba  f24011ff          MOV      r1,#0x1ff
0000be  ea010284          AND      r2,r1,r4,LSL #2
0000c2  f1050130          ADD      r1,r5,#0x30
0000c6  1850              ADDS     r0,r2,r1
0000c8  f7fffffe          BL       ld_dword
0000cc  f0204870          BIC      r8,r0,#0xf0000000
;;;1020   			break;
0000d0  e002              B        |L31.216|
                  |L31.210|
;;;1021   #if _FS_EXFAT
;;;1022   		case FS_EXFAT :
;;;1023   			if (obj->objsize) {
;;;1024   				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
;;;1025   				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
;;;1026   
;;;1027   				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
;;;1028   					if (cofs <= clen) {
;;;1029   						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
;;;1030   						break;
;;;1031   					}
;;;1032   				}
;;;1033   				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the contiguous part? */
;;;1034   					val = clst + 1; 	/* Generate the value */
;;;1035   					break;
;;;1036   				}
;;;1037   				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
;;;1038   					if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
;;;1039   					val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
;;;1040   					break;
;;;1041   				}
;;;1042   			}
;;;1043   			/* go next */
;;;1044   #endif
;;;1045   		default:
;;;1046   			val = 1;	/* Internal error */
0000d2  f04f0801          MOV      r8,#1
0000d6  bf00              NOP                            ;1002
                  |L31.216|
0000d8  bf00              NOP                            ;1005
                  |L31.218|
;;;1047   		}
;;;1048   	}
;;;1049   
;;;1050   	return val;
0000da  4640              MOV      r0,r8
;;;1051   }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;1052   
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;2395   static
;;;2396   void get_fileinfo (		/* No return code */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2397   	DIR* dp,			/* Pointer to the directory object */
;;;2398   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;2399   )
;;;2400   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;2401   	UINT i, j;
;;;2402   	TCHAR c;
;;;2403   	DWORD tm;
;;;2404   #if _USE_LFN != 0
;;;2405   	WCHAR w, lfv;
;;;2406   	FATFS *fs = dp->obj.fs;
;;;2407   #endif
;;;2408   
;;;2409   
;;;2410   	fno->fname[0] = 0;		/* Invaidate file info */
000008  2000              MOVS     r0,#0
00000a  7260              STRB     r0,[r4,#9]
;;;2411   	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
00000c  69a8              LDR      r0,[r5,#0x18]
00000e  b908              CBNZ     r0,|L32.20|
                  |L32.16|
;;;2412   
;;;2413   #if _USE_LFN != 0	/* LFN configuration */
;;;2414   #if _FS_EXFAT
;;;2415   	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
;;;2416   		get_xdir_info(fs->dirbuf, fno);
;;;2417   		return;
;;;2418   	} else
;;;2419   #endif
;;;2420   	{	/* On the FAT12/16/32 volume */
;;;2421   		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
;;;2422   			i = j = 0;
;;;2423   			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
;;;2424   #if !_LFN_UNICODE
;;;2425   				w = ff_convert(w, 0);		/* Unicode -> OEM */
;;;2426   				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
;;;2427   				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
;;;2428   					fno->fname[i++] = (char)(w >> 8);
;;;2429   				}
;;;2430   #endif
;;;2431   				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
;;;2432   				fno->fname[i++] = (TCHAR)w;
;;;2433   			}
;;;2434   			fno->fname[i] = 0;	/* Terminate the LFN */
;;;2435   		}
;;;2436   	}
;;;2437   
;;;2438   	i = j = 0;
;;;2439   	lfv = fno->fname[i];	/* LFN is exist if non-zero */
;;;2440   	while (i < 11) {		/* Copy name body and extension */
;;;2441   		c = (TCHAR)dp->dir[i++];
;;;2442   		if (c == ' ') continue;				/* Skip padding spaces */
;;;2443   		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;2444   		if (i == 9) {						/* Insert a . if extension is exist */
;;;2445   			if (!lfv) fno->fname[j] = '.';
;;;2446   			fno->altname[j++] = '.';
;;;2447   		}
;;;2448   #if _LFN_UNICODE
;;;2449   		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
;;;2450   			c = c << 8 | dp->dir[i++];
;;;2451   		}
;;;2452   		c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;2453   		if (!c) c = '?';
;;;2454   #endif
;;;2455   		fno->altname[j] = c;
;;;2456   		if (!lfv) {
;;;2457   			if (IsUpper(c) && (dp->dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY))) {
;;;2458   				c += 0x20;			/* To lower */
;;;2459   			}
;;;2460   			fno->fname[j] = c;
;;;2461   		}
;;;2462   		j++;
;;;2463   	}
;;;2464   	if (!lfv) {
;;;2465   		fno->fname[j] = 0;
;;;2466   		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
;;;2467   	}
;;;2468   	fno->altname[j] = 0;	/* Terminate the SFN */
;;;2469   
;;;2470   #else	/* Non-LFN configuration */
;;;2471   	i = j = 0;
;;;2472   	while (i < 11) {		/* Copy name body and extension */
;;;2473   		c = (TCHAR)dp->dir[i++];
;;;2474   		if (c == ' ') continue;				/* Skip padding spaces */
;;;2475   		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;2476   		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
;;;2477   		fno->fname[j++] = c;
;;;2478   	}
;;;2479   	fno->fname[j] = 0;
;;;2480   #endif
;;;2481   
;;;2482   	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
;;;2483   	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
;;;2484   	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
;;;2485   	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
;;;2486   }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L32.20|
000014  2600              MOVS     r6,#0                 ;2471
000016  4637              MOV      r7,r6                 ;2471
000018  e01c              B        |L32.84|
                  |L32.26|
00001a  4630              MOV      r0,r6                 ;2473
00001c  1c76              ADDS     r6,r6,#1              ;2473
00001e  69ea              LDR      r2,[r5,#0x1c]         ;2473
000020  f8129000          LDRB     r9,[r2,r0]            ;2473
000024  f1b90f20          CMP      r9,#0x20              ;2474
000028  d100              BNE      |L32.44|
00002a  e013              B        |L32.84|
                  |L32.44|
00002c  f1b90f05          CMP      r9,#5                 ;2475
000030  d101              BNE      |L32.54|
000032  f04f09e5          MOV      r9,#0xe5              ;2475
                  |L32.54|
000036  2e09              CMP      r6,#9                 ;2476
000038  d105              BNE      |L32.70|
00003a  222e              MOVS     r2,#0x2e              ;2476
00003c  4638              MOV      r0,r7                 ;2476
00003e  1c7f              ADDS     r7,r7,#1              ;2476
000040  f1040109          ADD      r1,r4,#9              ;2476
000044  540a              STRB     r2,[r1,r0]            ;2476
                  |L32.70|
000046  4638              MOV      r0,r7                 ;2477
000048  1c7f              ADDS     r7,r7,#1              ;2477
00004a  f1040109          ADD      r1,r4,#9              ;2477
00004e  f8019000          STRB     r9,[r1,r0]            ;2477
000052  bf00              NOP                            ;2474
                  |L32.84|
000054  2e0b              CMP      r6,#0xb               ;2472
000056  d3e0              BCC      |L32.26|
000058  2100              MOVS     r1,#0                 ;2479
00005a  f1040009          ADD      r0,r4,#9              ;2479
00005e  55c1              STRB     r1,[r0,r7]            ;2479
000060  69e8              LDR      r0,[r5,#0x1c]         ;2482
000062  7ac0              LDRB     r0,[r0,#0xb]          ;2482
000064  7220              STRB     r0,[r4,#8]            ;2482
000066  69e9              LDR      r1,[r5,#0x1c]         ;2483
000068  f101001c          ADD      r0,r1,#0x1c           ;2483
00006c  f7fffffe          BL       ld_dword
000070  6020              STR      r0,[r4,#0]            ;2483
000072  69e9              LDR      r1,[r5,#0x1c]         ;2484
000074  f1010016          ADD      r0,r1,#0x16           ;2484
000078  f7fffffe          BL       ld_dword
00007c  4680              MOV      r8,r0                 ;2484
00007e  f8a48006          STRH     r8,[r4,#6]            ;2485
000082  ea4f4018          LSR      r0,r8,#16             ;2485
000086  80a0              STRH     r0,[r4,#4]            ;2485
000088  bf00              NOP      
00008a  e7c1              B        |L32.16|
;;;2487   
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;2852   static
;;;2853   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b570              PUSH     {r4-r6,lr}
;;;2854   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2855   )
;;;2856   {
000002  4602              MOV      r2,r0
;;;2857   	const TCHAR *tp, *tt;
;;;2858   	UINT i;
;;;2859   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
;;;2860   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2861   	static const char* const str[] = {_VOLUME_STRS};
;;;2862   	const char *sp;
;;;2863   	char c;
;;;2864   	TCHAR tc;
;;;2865   #endif
;;;2866   
;;;2867   
;;;2868   	if (*path) {	/* If the pointer is not a null */
000008  6815              LDR      r5,[r2,#0]
00000a  b1dd              CBZ      r5,|L33.68|
;;;2869   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
00000c  6811              LDR      r1,[r2,#0]
00000e  e000              B        |L33.18|
                  |L33.16|
000010  1c49              ADDS     r1,r1,#1
                  |L33.18|
000012  780d              LDRB     r5,[r1,#0]
000014  2d21              CMP      r5,#0x21
000016  d302              BCC      |L33.30|
000018  780d              LDRB     r5,[r1,#0]
00001a  2d3a              CMP      r5,#0x3a
00001c  d1f8              BNE      |L33.16|
                  |L33.30|
;;;2870   		if (*tt == ':') {	/* If a ':' is exist in the path name */
00001e  780d              LDRB     r5,[r1,#0]
000020  2d3a              CMP      r5,#0x3a
000022  d10e              BNE      |L33.66|
;;;2871   			tp = *path;
000024  6814              LDR      r4,[r2,#0]
;;;2872   			i = *tp++ - '0'; 
000026  f8145b01          LDRB     r5,[r4],#1
00002a  f1a50330          SUB      r3,r5,#0x30
;;;2873   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
00002e  2b0a              CMP      r3,#0xa
000030  d206              BCS      |L33.64|
000032  428c              CMP      r4,r1
000034  d104              BNE      |L33.64|
;;;2874   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
000036  b91b              CBNZ     r3,|L33.64|
;;;2875   					vol = (int)i;
000038  4618              MOV      r0,r3
;;;2876   					*path = ++tt;
00003a  1c4d              ADDS     r5,r1,#1
00003c  4629              MOV      r1,r5
00003e  6015              STR      r5,[r2,#0]
                  |L33.64|
;;;2877   				}
;;;2878   			}
;;;2879   #if _STR_VOLUME_ID
;;;2880   			 else {	/* No numeric drive number, find string drive id */
;;;2881   				i = 0; tt++;
;;;2882   				do {
;;;2883   					sp = str[i]; tp = *path;
;;;2884   					do {	/* Compare a string drive id with path name */
;;;2885   						c = *sp++; tc = *tp++;
;;;2886   						if (IsLower(tc)) tc -= 0x20;
;;;2887   					} while (c && (TCHAR)c == tc);
;;;2888   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2889   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2890   					vol = (int)i;
;;;2891   					*path = tt;
;;;2892   				}
;;;2893   			}
;;;2894   #endif
;;;2895   			return vol;
;;;2896   		}
;;;2897   #if _FS_RPATH != 0 && _VOLUMES >= 2
;;;2898   		vol = CurrVol;	/* Current drive */
;;;2899   #else
;;;2900   		vol = 0;		/* Drive 0 */
;;;2901   #endif
;;;2902   	}
;;;2903   	return vol;
;;;2904   }
000040  bd70              POP      {r4-r6,pc}
                  |L33.66|
000042  2000              MOVS     r0,#0                 ;2900
                  |L33.68|
000044  bf00              NOP                            ;2903
000046  e7fb              B        |L33.64|
;;;2905   
                          ENDP


                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1588   static
;;;1589   DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
000000  b570              PUSH     {r4-r6,lr}
;;;1590   	FATFS* fs,		/* Pointer to the fs object */
;;;1591   	const BYTE* dir	/* Pointer to the key entry */
;;;1592   )
;;;1593   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1594   	DWORD cl;
;;;1595   
;;;1596   	cl = ld_word(dir + DIR_FstClusLO);
000006  f104001a          ADD      r0,r4,#0x1a
00000a  f7fffffe          BL       ld_word
00000e  4606              MOV      r6,r0
;;;1597   	if (fs->fs_type == FS_FAT32) {
000010  7828              LDRB     r0,[r5,#0]
000012  2803              CMP      r0,#3
000014  d105              BNE      |L34.34|
;;;1598   		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
000016  f1040014          ADD      r0,r4,#0x14
00001a  f7fffffe          BL       ld_word
00001e  ea464600          ORR      r6,r6,r0,LSL #16
                  |L34.34|
;;;1599   	}
;;;1600   
;;;1601   	return cl;
000022  4630              MOV      r0,r6
;;;1602   }
000024  bd70              POP      {r4-r6,pc}
;;;1603   
                          ENDP


                          AREA ||i.ld_dword||, CODE, READONLY, ALIGN=1

                  ld_dword PROC
;;;611    static
;;;612    DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
000000  4601              MOV      r1,r0
;;;613    {
;;;614    	DWORD rv;
;;;615    
;;;616    	rv = ptr[3];
000002  78c8              LDRB     r0,[r1,#3]
;;;617    	rv = rv << 8 | ptr[2];
000004  788a              LDRB     r2,[r1,#2]
000006  ea422000          ORR      r0,r2,r0,LSL #8
;;;618    	rv = rv << 8 | ptr[1];
00000a  784a              LDRB     r2,[r1,#1]
00000c  ea422000          ORR      r0,r2,r0,LSL #8
;;;619    	rv = rv << 8 | ptr[0];
000010  780a              LDRB     r2,[r1,#0]
000012  ea422000          ORR      r0,r2,r0,LSL #8
;;;620    	return rv;
;;;621    }
000016  4770              BX       lr
;;;622    
                          ENDP


                          AREA ||i.ld_word||, CODE, READONLY, ALIGN=1

                  ld_word PROC
;;;601    static
;;;602    WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
000000  4601              MOV      r1,r0
;;;603    {
;;;604    	WORD rv;
;;;605    
;;;606    	rv = ptr[1];
000002  7848              LDRB     r0,[r1,#1]
;;;607    	rv = rv << 8 | ptr[0];
000004  780a              LDRB     r2,[r1,#0]
000006  ea422000          ORR      r0,r2,r0,LSL #8
;;;608    	return rv;
;;;609    }
00000a  4770              BX       lr
;;;610    
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;700    static
;;;701    int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
000000  b5f0              PUSH     {r4-r7,lr}
000002  4603              MOV      r3,r0
;;;702    	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
000004  461d              MOV      r5,r3
000006  460c              MOV      r4,r1
;;;703    	int r = 0;
000008  2000              MOVS     r0,#0
;;;704    
;;;705    	do {
00000a  bf00              NOP      
                  |L37.12|
;;;706    		r = *d++ - *s++;
00000c  f8157b01          LDRB     r7,[r5],#1
000010  f814cb01          LDRB     r12,[r4],#1
000014  eba7000c          SUB      r0,r7,r12
;;;707    	} while (--cnt && r == 0);
000018  1e56              SUBS     r6,r2,#1
00001a  1e32              SUBS     r2,r6,#0
00001c  d001              BEQ      |L37.34|
00001e  2800              CMP      r0,#0
000020  d0f4              BEQ      |L37.12|
                  |L37.34|
;;;708    
;;;709    	return r;
;;;710    }
000022  bdf0              POP      {r4-r7,pc}
;;;711    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;681    static
;;;682    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  b530              PUSH     {r4,r5,lr}
;;;683    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;684    	const BYTE *s = (const BYTE*)src;
000004  460c              MOV      r4,r1
;;;685    
;;;686    	if (cnt) {
000006  b13a              CBZ      r2,|L38.24|
;;;687    		do *d++ = *s++; while (--cnt);
000008  bf00              NOP      
                  |L38.10|
00000a  f8145b01          LDRB     r5,[r4],#1
00000e  f8035b01          STRB     r5,[r3],#1
000012  1e55              SUBS     r5,r2,#1
000014  1e2a              SUBS     r2,r5,#0
000016  d1f8              BNE      |L38.10|
                  |L38.24|
;;;688    	}
;;;689    }
000018  bd30              POP      {r4,r5,pc}
;;;690    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;692    static
;;;693    void mem_set (void* dst, int val, UINT cnt) {
000000  b510              PUSH     {r4,lr}
;;;694    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;695    
;;;696    	do *d++ = (BYTE)val; while (--cnt);
000004  bf00              NOP      
                  |L39.6|
000006  f8031b01          STRB     r1,[r3],#1
00000a  1e54              SUBS     r4,r2,#1
00000c  1e22              SUBS     r2,r4,#0
00000e  d1fa              BNE      |L39.6|
;;;697    }
000010  bd10              POP      {r4,pc}
;;;698    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;896    static
;;;897    FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
000000  b570              PUSH     {r4-r6,lr}
;;;898    	FATFS* fs,			/* File system object */
;;;899    	DWORD sector		/* Sector number to make appearance in the fs->win[] */
;;;900    )
;;;901    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;902    	FRESULT res = FR_OK;
000006  2600              MOVS     r6,#0
;;;903    
;;;904    
;;;905    	if (sector != fs->winsect) {	/* Window offset changed? */
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  42a8              CMP      r0,r5
00000c  d010              BEQ      |L40.48|
;;;906    #if !_FS_READONLY
;;;907    		res = sync_window(fs);		/* Write-back changes */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sync_window
000014  4606              MOV      r6,r0
;;;908    #endif
;;;909    		if (res == FR_OK) {			/* Fill sector window with new data */
000016  b95e              CBNZ     r6,|L40.48|
;;;910    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
000018  7860              LDRB     r0,[r4,#1]
00001a  2301              MOVS     r3,#1
00001c  462a              MOV      r2,r5
00001e  f1040130          ADD      r1,r4,#0x30
000022  f7fffffe          BL       disk_read
000026  b110              CBZ      r0,|L40.46|
;;;911    				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
000028  f04f35ff          MOV      r5,#0xffffffff
;;;912    				res = FR_DISK_ERR;
00002c  2601              MOVS     r6,#1
                  |L40.46|
;;;913    			}
;;;914    			fs->winsect = sector;
00002e  62e5              STR      r5,[r4,#0x2c]
                  |L40.48|
;;;915    		}
;;;916    	}
;;;917    	return res;
000030  4630              MOV      r0,r6
;;;918    }
000032  bd70              POP      {r4-r6,pc}
;;;919    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;1061   static
;;;1062   FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1063   	FATFS* fs,		/* Corresponding file system object */
;;;1064   	DWORD clst,		/* FAT index number (cluster number) to be changed */
;;;1065   	DWORD val		/* New value to be set to the entry */
;;;1066   )
;;;1067   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1068   	UINT bc;
;;;1069   	BYTE *p;
;;;1070   	FRESULT res = FR_INT_ERR;
00000a  f04f0902          MOV      r9,#2
;;;1071   
;;;1072   
;;;1073   	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
00000e  2d02              CMP      r5,#2
000010  d374              BCC      |L41.252|
000012  6960              LDR      r0,[r4,#0x14]
000014  42a8              CMP      r0,r5
000016  d971              BLS      |L41.252|
;;;1074   		switch (fs->fs_type) {
000018  7820              LDRB     r0,[r4,#0]
00001a  2801              CMP      r0,#1
00001c  d004              BEQ      |L41.40|
00001e  2802              CMP      r0,#2
000020  d049              BEQ      |L41.182|
000022  2803              CMP      r0,#3
000024  d10d              BNE      |L41.66|
000026  e05e              B        |L41.230|
                  |L41.40|
;;;1075   		case FS_FAT12 :	/* Bitfield items */
;;;1076   			bc = (UINT)clst; bc += bc / 2;
000028  462f              MOV      r7,r5
00002a  eb070757          ADD      r7,r7,r7,LSR #1
;;;1077   			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
00002e  6a20              LDR      r0,[r4,#0x20]
000030  eb002157          ADD      r1,r0,r7,LSR #9
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       move_window
00003a  4681              MOV      r9,r0
;;;1078   			if (res != FR_OK) break;
00003c  f1b90f00          CMP      r9,#0
000040  d000              BEQ      |L41.68|
                  |L41.66|
000042  e075              B        |L41.304|
                  |L41.68|
;;;1079   			p = fs->win + bc++ % SS(fs);
000044  4638              MOV      r0,r7
000046  1c7f              ADDS     r7,r7,#1
000048  f3c00108          UBFX     r1,r0,#0,#9
00004c  f1040030          ADD      r0,r4,#0x30
000050  eb010800          ADD      r8,r1,r0
;;;1080   			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
000054  f0050001          AND      r0,r5,#1
000058  b128              CBZ      r0,|L41.102|
00005a  b2f1              UXTB     r1,r6
00005c  f8980000          LDRB     r0,[r8,#0]
000060  f361101f          BFI      r0,r1,#4,#28
000064  e000              B        |L41.104|
                  |L41.102|
000066  4630              MOV      r0,r6
                  |L41.104|
000068  f8880000          STRB     r0,[r8,#0]
;;;1081   			fs->wflag = 1;
00006c  2001              MOVS     r0,#1
00006e  70e0              STRB     r0,[r4,#3]
;;;1082   			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
000070  6a20              LDR      r0,[r4,#0x20]
000072  eb002157          ADD      r1,r0,r7,LSR #9
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       move_window
00007c  4681              MOV      r9,r0
;;;1083   			if (res != FR_OK) break;
00007e  f1b90f00          CMP      r9,#0
000082  d000              BEQ      |L41.134|
000084  e054              B        |L41.304|
                  |L41.134|
;;;1084   			p = fs->win + bc % SS(fs);
000086  f3c70108          UBFX     r1,r7,#0,#9
00008a  f1040030          ADD      r0,r4,#0x30
00008e  eb010800          ADD      r8,r1,r0
;;;1085   			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
000092  f0050001          AND      r0,r5,#1
000096  b110              CBZ      r0,|L41.158|
000098  f3c61007          UBFX     r0,r6,#4,#8
00009c  e006              B        |L41.172|
                  |L41.158|
00009e  f8980000          LDRB     r0,[r8,#0]
0000a2  f00000f0          AND      r0,r0,#0xf0
0000a6  f3c62103          UBFX     r1,r6,#8,#4
0000aa  4308              ORRS     r0,r0,r1
                  |L41.172|
0000ac  f8880000          STRB     r0,[r8,#0]
;;;1086   			fs->wflag = 1;
0000b0  2001              MOVS     r0,#1
0000b2  70e0              STRB     r0,[r4,#3]
;;;1087   			break;
0000b4  e03c              B        |L41.304|
                  |L41.182|
;;;1088   
;;;1089   		case FS_FAT16 :	/* WORD aligned items */
;;;1090   			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  eb002115          ADD      r1,r0,r5,LSR #8
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       move_window
0000c2  4681              MOV      r9,r0
;;;1091   			if (res != FR_OK) break;
0000c4  f1b90f00          CMP      r9,#0
0000c8  d000              BEQ      |L41.204|
0000ca  e031              B        |L41.304|
                  |L41.204|
;;;1092   			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
0000cc  b2b1              UXTH     r1,r6
0000ce  f24012ff          MOV      r2,#0x1ff
0000d2  ea020345          AND      r3,r2,r5,LSL #1
0000d6  f1040230          ADD      r2,r4,#0x30
0000da  1898              ADDS     r0,r3,r2
0000dc  f7fffffe          BL       st_word
;;;1093   			fs->wflag = 1;
0000e0  2001              MOVS     r0,#1
0000e2  70e0              STRB     r0,[r4,#3]
;;;1094   			break;
0000e4  e024              B        |L41.304|
                  |L41.230|
;;;1095   
;;;1096   		case FS_FAT32 :	/* DWORD aligned items */
;;;1097   #if _FS_EXFAT
;;;1098   		case FS_EXFAT :
;;;1099   #endif
;;;1100   			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
0000e6  6a20              LDR      r0,[r4,#0x20]
0000e8  eb0011d5          ADD      r1,r0,r5,LSR #7
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       move_window
0000f2  4681              MOV      r9,r0
;;;1101   			if (res != FR_OK) break;
0000f4  f1b90f00          CMP      r9,#0
0000f8  d001              BEQ      |L41.254|
0000fa  e019              B        |L41.304|
                  |L41.252|
0000fc  e019              B        |L41.306|
                  |L41.254|
;;;1102   			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
;;;1103   				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
0000fe  f24011ff          MOV      r1,#0x1ff
000102  ea010285          AND      r2,r1,r5,LSL #2
000106  f1040130          ADD      r1,r4,#0x30
00010a  1850              ADDS     r0,r2,r1
00010c  f7fffffe          BL       ld_dword
000110  f366001b          BFI      r0,r6,#0,#28
000114  4606              MOV      r6,r0
;;;1104   			}
;;;1105   			st_dword(fs->win + clst * 4 % SS(fs), val);
000116  f24011ff          MOV      r1,#0x1ff
00011a  ea010285          AND      r2,r1,r5,LSL #2
00011e  f1040130          ADD      r1,r4,#0x30
000122  1850              ADDS     r0,r2,r1
000124  4631              MOV      r1,r6
000126  f7fffffe          BL       st_dword
;;;1106   			fs->wflag = 1;
00012a  2001              MOVS     r0,#1
00012c  70e0              STRB     r0,[r4,#3]
;;;1107   			break;
00012e  bf00              NOP      
                  |L41.304|
000130  bf00              NOP                            ;1078
                  |L41.306|
;;;1108   		}
;;;1109   	}
;;;1110   	return res;
000132  4648              MOV      r0,r9
;;;1111   }
000134  e8bd87f0          POP      {r4-r10,pc}
;;;1112   
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;1231   static
;;;1232   FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1233   	_FDID* obj,			/* Corresponding object */
;;;1234   	DWORD clst,			/* Cluster to remove a chain from */
;;;1235   	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
;;;1236   )
;;;1237   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1238   	FRESULT res = FR_OK;
00000a  f04f0800          MOV      r8,#0
;;;1239   	DWORD nxt;
;;;1240   	FATFS *fs = obj->fs;
00000e  f8d94000          LDR      r4,[r9,#0]
;;;1241   #if _FS_EXFAT || _USE_TRIM
;;;1242   	DWORD scl = clst, ecl = clst;
;;;1243   #endif
;;;1244   #if _USE_TRIM
;;;1245   	DWORD rt[2];
;;;1246   #endif
;;;1247   
;;;1248   	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
000012  2e02              CMP      r6,#2
000014  d302              BCC      |L42.28|
000016  6960              LDR      r0,[r4,#0x14]
000018  42b0              CMP      r0,r6
00001a  d802              BHI      |L42.34|
                  |L42.28|
00001c  2002              MOVS     r0,#2
                  |L42.30|
;;;1249   
;;;1250   	/* Mark the previous cluster 'EOC' on the FAT if it exists */
;;;1251   	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
;;;1252   		res = put_fat(fs, pclst, 0xFFFFFFFF);
;;;1253   		if (res != FR_OK) return res;
;;;1254   	}
;;;1255   
;;;1256   	/* Remove the chain */
;;;1257   	do {
;;;1258   		nxt = get_fat(obj, clst);			/* Get cluster status */
;;;1259   		if (nxt == 0) break;				/* Empty cluster? */
;;;1260   		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
;;;1261   		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
;;;1262   		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
;;;1263   			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
;;;1264   			if (res != FR_OK) return res;
;;;1265   		}
;;;1266   		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
;;;1267   			fs->free_clst++;
;;;1268   			fs->fsi_flag |= 1;
;;;1269   		}
;;;1270   #if _FS_EXFAT || _USE_TRIM
;;;1271   		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;1272   			ecl = nxt;
;;;1273   		} else {				/* End of contiguous cluster block */ 
;;;1274   #if _FS_EXFAT
;;;1275   			if (fs->fs_type == FS_EXFAT) {
;;;1276   				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
;;;1277   				if (res != FR_OK) return res;
;;;1278   			}
;;;1279   #endif
;;;1280   #if _USE_TRIM
;;;1281   			rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;1282   			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;1283   			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
;;;1284   #endif
;;;1285   			scl = ecl = nxt;
;;;1286   		}
;;;1287   #endif
;;;1288   		clst = nxt;					/* Next cluster */
;;;1289   	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
;;;1290   
;;;1291   #if _FS_EXFAT
;;;1292   	if (fs->fs_type == FS_EXFAT) {
;;;1293   		if (pclst == 0) {	/* Does object have no chain? */
;;;1294   			obj->stat = 0;		/* Change the object status 'initial' */
;;;1295   		} else {
;;;1296   			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain got contiguous? */
;;;1297   				obj->stat = 2;	/* Change the object status 'contiguous' */
;;;1298   			}
;;;1299   		}
;;;1300   	}
;;;1301   #endif
;;;1302   	return FR_OK;
;;;1303   }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L42.34|
000022  b167              CBZ      r7,|L42.62|
000024  bf00              NOP                            ;1251
000026  f04f32ff          MOV      r2,#0xffffffff        ;1252
00002a  4639              MOV      r1,r7                 ;1252
00002c  4620              MOV      r0,r4                 ;1252
00002e  f7fffffe          BL       put_fat
000032  4680              MOV      r8,r0                 ;1252
000034  f1b80f00          CMP      r8,#0                 ;1253
000038  d001              BEQ      |L42.62|
00003a  4640              MOV      r0,r8                 ;1253
00003c  e7ef              B        |L42.30|
                  |L42.62|
00003e  bf00              NOP                            ;1257
                  |L42.64|
000040  4631              MOV      r1,r6                 ;1258
000042  4648              MOV      r0,r9                 ;1258
000044  f7fffffe          BL       get_fat
000048  4605              MOV      r5,r0                 ;1258
00004a  b905              CBNZ     r5,|L42.78|
00004c  e022              B        |L42.148|
                  |L42.78|
00004e  2d01              CMP      r5,#1                 ;1260
000050  d101              BNE      |L42.86|
000052  2002              MOVS     r0,#2                 ;1260
000054  e7e3              B        |L42.30|
                  |L42.86|
000056  1c68              ADDS     r0,r5,#1              ;1261
000058  b908              CBNZ     r0,|L42.94|
00005a  2001              MOVS     r0,#1                 ;1261
00005c  e7df              B        |L42.30|
                  |L42.94|
00005e  2200              MOVS     r2,#0                 ;1263
000060  4631              MOV      r1,r6                 ;1263
000062  4620              MOV      r0,r4                 ;1263
000064  f7fffffe          BL       put_fat
000068  4680              MOV      r8,r0                 ;1263
00006a  f1b80f00          CMP      r8,#0                 ;1264
00006e  d001              BEQ      |L42.116|
000070  4640              MOV      r0,r8                 ;1264
000072  e7d4              B        |L42.30|
                  |L42.116|
000074  e9d41004          LDRD     r1,r0,[r4,#0x10]      ;1266
000078  1e80              SUBS     r0,r0,#2              ;1266
00007a  4281              CMP      r1,r0                 ;1266
00007c  d206              BCS      |L42.140|
00007e  6920              LDR      r0,[r4,#0x10]         ;1267
000080  1c40              ADDS     r0,r0,#1              ;1267
000082  6120              STR      r0,[r4,#0x10]         ;1267
000084  7920              LDRB     r0,[r4,#4]            ;1268
000086  f0400001          ORR      r0,r0,#1              ;1268
00008a  7120              STRB     r0,[r4,#4]            ;1268
                  |L42.140|
00008c  462e              MOV      r6,r5                 ;1288
00008e  6960              LDR      r0,[r4,#0x14]         ;1289
000090  42b0              CMP      r0,r6                 ;1289
000092  d8d5              BHI      |L42.64|
                  |L42.148|
000094  bf00              NOP                            ;1259
000096  2000              MOVS     r0,#0                 ;1302
000098  e7c1              B        |L42.30|
;;;1304   
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1606   static
;;;1607   void st_clust (
000000  b570              PUSH     {r4-r6,lr}
;;;1608   	FATFS* fs,	/* Pointer to the fs object */
;;;1609   	BYTE* dir,	/* Pointer to the key entry */
;;;1610   	DWORD cl	/* Value to be set */
;;;1611   )
;;;1612   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1613   	st_word(dir + DIR_FstClusLO, (WORD)cl);
000008  b2a9              UXTH     r1,r5
00000a  f104001a          ADD      r0,r4,#0x1a
00000e  f7fffffe          BL       st_word
;;;1614   	if (fs->fs_type == FS_FAT32) {
000012  7830              LDRB     r0,[r6,#0]
000014  2803              CMP      r0,#3
000016  d104              BNE      |L43.34|
;;;1615   		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
000018  0c29              LSRS     r1,r5,#16
00001a  f1040014          ADD      r0,r4,#0x14
00001e  f7fffffe          BL       st_word
                  |L43.34|
;;;1616   	}
;;;1617   }
000022  bd70              POP      {r4-r6,pc}
;;;1618   #endif
                          ENDP


                          AREA ||i.st_dword||, CODE, READONLY, ALIGN=1

                  st_dword PROC
;;;649    static
;;;650    void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
000000  f8001b01          STRB     r1,[r0],#1
;;;651    {
;;;652    	*ptr++ = (BYTE)val; val >>= 8;
000004  0a09              LSRS     r1,r1,#8
;;;653    	*ptr++ = (BYTE)val; val >>= 8;
000006  f8001b01          STRB     r1,[r0],#1
00000a  0a09              LSRS     r1,r1,#8
;;;654    	*ptr++ = (BYTE)val; val >>= 8;
00000c  f8001b01          STRB     r1,[r0],#1
000010  0a09              LSRS     r1,r1,#8
;;;655    	*ptr++ = (BYTE)val;
000012  f8001b01          STRB     r1,[r0],#1
;;;656    }
000016  4770              BX       lr
;;;657    
                          ENDP


                          AREA ||i.st_word||, CODE, READONLY, ALIGN=1

                  st_word PROC
;;;642    static
;;;643    void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
000000  f8001b01          STRB     r1,[r0],#1
;;;644    {
;;;645    	*ptr++ = (BYTE)val; val >>= 8;
000004  1209              ASRS     r1,r1,#8
;;;646    	*ptr++ = (BYTE)val;
000006  f8001b01          STRB     r1,[r0],#1
;;;647    }
00000a  4770              BX       lr
;;;648    
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=2

                  sync_fs PROC
;;;928    static
;;;929    FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;930    	FATFS* fs		/* File system object */
;;;931    )
;;;932    {
000002  4604              MOV      r4,r0
;;;933    	FRESULT res;
;;;934    
;;;935    
;;;936    	res = sync_window(fs);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       sync_window
00000a  4605              MOV      r5,r0
;;;937    	if (res == FR_OK) {
00000c  2d00              CMP      r5,#0
00000e  d138              BNE      |L46.130|
;;;938    		/* Update FSInfo sector if needed */
;;;939    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d12e              BNE      |L46.116|
000016  7920              LDRB     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d12b              BNE      |L46.116|
;;;940    			/* Create FSInfo structure */
;;;941    			mem_set(fs->win, 0, SS(fs));
00001c  0242              LSLS     r2,r0,#9
00001e  2100              MOVS     r1,#0
000020  f1040030          ADD      r0,r4,#0x30
000024  f7fffffe          BL       mem_set
;;;942    			st_word(fs->win + BS_55AA, 0xAA55);
000028  f64a2155          MOV      r1,#0xaa55
00002c  f204202e          ADD      r0,r4,#0x22e
000030  f7fffffe          BL       st_word
;;;943    			st_dword(fs->win + FSI_LeadSig, 0x41615252);
000034  4914              LDR      r1,|L46.136|
000036  f1040030          ADD      r0,r4,#0x30
00003a  f7fffffe          BL       st_dword
;;;944    			st_dword(fs->win + FSI_StrucSig, 0x61417272);
00003e  4913              LDR      r1,|L46.140|
000040  f5047005          ADD      r0,r4,#0x214
000044  f7fffffe          BL       st_dword
;;;945    			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
000048  f5047006          ADD      r0,r4,#0x218
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f7fffffe          BL       st_dword
;;;946    			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
000052  f5047007          ADD      r0,r4,#0x21c
000056  68e1              LDR      r1,[r4,#0xc]
000058  f7fffffe          BL       st_dword
;;;947    			/* Write it into the FSInfo sector */
;;;948    			fs->winsect = fs->volbase + 1;
00005c  69e0              LDR      r0,[r4,#0x1c]
00005e  1c40              ADDS     r0,r0,#1
000060  62e0              STR      r0,[r4,#0x2c]
;;;949    			disk_write(fs->drv, fs->win, fs->winsect, 1);
000062  7860              LDRB     r0,[r4,#1]
000064  2301              MOVS     r3,#1
000066  f1040130          ADD      r1,r4,#0x30
00006a  6ae2              LDR      r2,[r4,#0x2c]
00006c  f7fffffe          BL       disk_write
;;;950    			fs->fsi_flag = 0;
000070  2000              MOVS     r0,#0
000072  7120              STRB     r0,[r4,#4]
                  |L46.116|
;;;951    		}
;;;952    		/* Make sure that no pending write process in the physical drive */
;;;953    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
000074  7860              LDRB     r0,[r4,#1]
000076  2200              MOVS     r2,#0
000078  4611              MOV      r1,r2
00007a  f7fffffe          BL       disk_ioctl
00007e  b100              CBZ      r0,|L46.130|
000080  2501              MOVS     r5,#1
                  |L46.130|
;;;954    	}
;;;955    
;;;956    	return res;
000082  4628              MOV      r0,r5
;;;957    }
000084  bd70              POP      {r4-r6,pc}
;;;958    
                          ENDP

000086  0000              DCW      0x0000
                  |L46.136|
                          DCD      0x41615252
                  |L46.140|
                          DCD      0x61417272

                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;867    static
;;;868    FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;869    	FATFS* fs			/* File system object */
;;;870    )
;;;871    {
000004  4604              MOV      r4,r0
;;;872    	DWORD wsect;
;;;873    	UINT nf;
;;;874    	FRESULT res = FR_OK;
000006  2700              MOVS     r7,#0
;;;875    
;;;876    
;;;877    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000008  78e0              LDRB     r0,[r4,#3]
00000a  b1f8              CBZ      r0,|L47.76|
;;;878    		wsect = fs->winsect;	/* Current sector number */
00000c  6ae5              LDR      r5,[r4,#0x2c]
;;;879    		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
00000e  7860              LDRB     r0,[r4,#1]
000010  2301              MOVS     r3,#1
000012  462a              MOV      r2,r5
000014  f1040130          ADD      r1,r4,#0x30
000018  f7fffffe          BL       disk_write
00001c  b108              CBZ      r0,|L47.34|
;;;880    			res = FR_DISK_ERR;
00001e  2701              MOVS     r7,#1
000020  e014              B        |L47.76|
                  |L47.34|
;;;881    		} else {
;;;882    			fs->wflag = 0;
000022  2000              MOVS     r0,#0
000024  70e0              STRB     r0,[r4,#3]
;;;883    			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
000026  6a20              LDR      r0,[r4,#0x20]
000028  1a28              SUBS     r0,r5,r0
00002a  69a1              LDR      r1,[r4,#0x18]
00002c  4288              CMP      r0,r1
00002e  d20d              BCS      |L47.76|
;;;884    				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
000030  78a6              LDRB     r6,[r4,#2]
000032  e009              B        |L47.72|
                  |L47.52|
;;;885    					wsect += fs->fsize;
000034  69a0              LDR      r0,[r4,#0x18]
000036  4405              ADD      r5,r5,r0
;;;886    					disk_write(fs->drv, fs->win, wsect, 1);
000038  7860              LDRB     r0,[r4,#1]
00003a  2301              MOVS     r3,#1
00003c  462a              MOV      r2,r5
00003e  f1040130          ADD      r1,r4,#0x30
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1              ;884
                  |L47.72|
000048  2e02              CMP      r6,#2                 ;884
00004a  d2f3              BCS      |L47.52|
                  |L47.76|
;;;887    				}
;;;888    			}
;;;889    		}
;;;890    	}
;;;891    	return res;
00004c  4638              MOV      r0,r7
;;;892    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;893    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;3162   static
;;;3163   FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
000000  b570              PUSH     {r4-r6,lr}
;;;3164   	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
;;;3165   	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
;;;3166   )
;;;3167   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3168   	FRESULT res;
;;;3169   
;;;3170   
;;;3171   	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
000006  b184              CBZ      r4,|L48.42|
000008  6820              LDR      r0,[r4,#0]
00000a  b170              CBZ      r0,|L48.42|
00000c  6820              LDR      r0,[r4,#0]
00000e  7800              LDRB     r0,[r0,#0]
000010  b158              CBZ      r0,|L48.42|
000012  6820              LDR      r0,[r4,#0]
000014  88c0              LDRH     r0,[r0,#6]
000016  88a1              LDRH     r1,[r4,#4]
000018  4288              CMP      r0,r1
00001a  d106              BNE      |L48.42|
00001c  6821              LDR      r1,[r4,#0]
00001e  7848              LDRB     r0,[r1,#1]
000020  f7fffffe          BL       disk_status
000024  f0000001          AND      r0,r0,#1
000028  b118              CBZ      r0,|L48.50|
                  |L48.42|
;;;3172   		*fs = 0;				/* The object is invalid */
00002a  2000              MOVS     r0,#0
00002c  6028              STR      r0,[r5,#0]
;;;3173   		res = FR_INVALID_OBJECT;
00002e  2609              MOVS     r6,#9
000030  e002              B        |L48.56|
                  |L48.50|
;;;3174   	} else {
;;;3175   		*fs = obj->fs;			/* Owner file sytem object */
000032  6820              LDR      r0,[r4,#0]
000034  6028              STR      r0,[r5,#0]
;;;3176   		ENTER_FF(obj->fs);		/* Lock file system */
;;;3177   		res = FR_OK;
000036  2600              MOVS     r6,#0
                  |L48.56|
;;;3178   	}
;;;3179   	return res;
000038  4630              MOV      r0,r6
;;;3180   }
00003a  bd70              POP      {r4-r6,pc}
;;;3181   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  FatFs
                          DCD      0x00000000
                  Fsid
000004  0000              DCB      0x00,0x00
