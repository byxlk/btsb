; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_rtc.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1215     */
;;;1216   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1217   {
000002  4602              MOV      r2,r0
;;;1218     __IO uint32_t alarmcounter = 0x00;
000004  2400              MOVS     r4,#0
000006  9400              STR      r4,[sp,#0]
;;;1219     uint32_t alarmstatus = 0x00;
000008  2300              MOVS     r3,#0
;;;1220     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1221       
;;;1222     /* Check the parameters */
;;;1223     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1224     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1225   
;;;1226     /* Disable the write protection for RTC registers */
;;;1227     RTC->WPR = 0xCA;
00000c  24ca              MOVS     r4,#0xca
00000e  4d18              LDR      r5,|L1.112|
000010  602c              STR      r4,[r5,#0]
;;;1228     RTC->WPR = 0x53;
000012  2453              MOVS     r4,#0x53
000014  602c              STR      r4,[r5,#0]
;;;1229   
;;;1230     /* Configure the Alarm state */
;;;1231     if (NewState != DISABLE)
000016  b141              CBZ      r1,|L1.42|
;;;1232     {
;;;1233       RTC->CR |= (uint32_t)RTC_Alarm;
000018  4c15              LDR      r4,|L1.112|
00001a  3c1c              SUBS     r4,r4,#0x1c
00001c  6824              LDR      r4,[r4,#0]
00001e  4314              ORRS     r4,r4,r2
000020  4d13              LDR      r5,|L1.112|
000022  3d1c              SUBS     r5,r5,#0x1c
000024  602c              STR      r4,[r5,#0]
;;;1234   
;;;1235       status = SUCCESS;    
000026  2001              MOVS     r0,#1
000028  e01e              B        |L1.104|
                  |L1.42|
;;;1236     }
;;;1237     else
;;;1238     { 
;;;1239       /* Disable the Alarm in RTC_CR register */
;;;1240       RTC->CR &= (uint32_t)~RTC_Alarm;
00002a  4c11              LDR      r4,|L1.112|
00002c  3c1c              SUBS     r4,r4,#0x1c
00002e  6824              LDR      r4,[r4,#0]
000030  4394              BICS     r4,r4,r2
000032  4d0f              LDR      r5,|L1.112|
000034  3d1c              SUBS     r5,r5,#0x1c
000036  602c              STR      r4,[r5,#0]
;;;1241      
;;;1242       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1243       do
000038  bf00              NOP      
                  |L1.58|
;;;1244       {
;;;1245         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
00003a  4c0d              LDR      r4,|L1.112|
00003c  3c18              SUBS     r4,r4,#0x18
00003e  6824              LDR      r4,[r4,#0]
000040  ea042312          AND      r3,r4,r2,LSR #8
;;;1246         alarmcounter++;  
000044  9c00              LDR      r4,[sp,#0]
000046  1c64              ADDS     r4,r4,#1
000048  9400              STR      r4,[sp,#0]
;;;1247       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
00004a  9c00              LDR      r4,[sp,#0]
00004c  f5b43f80          CMP      r4,#0x10000
000050  d001              BEQ      |L1.86|
000052  2b00              CMP      r3,#0
000054  d0f1              BEQ      |L1.58|
                  |L1.86|
;;;1248       
;;;1249       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000056  4c06              LDR      r4,|L1.112|
000058  3c18              SUBS     r4,r4,#0x18
00005a  6824              LDR      r4,[r4,#0]
00005c  ea042412          AND      r4,r4,r2,LSR #8
000060  b90c              CBNZ     r4,|L1.102|
;;;1250       {
;;;1251         status = ERROR;
000062  2000              MOVS     r0,#0
000064  e000              B        |L1.104|
                  |L1.102|
;;;1252       } 
;;;1253       else
;;;1254       {
;;;1255         status = SUCCESS;
000066  2001              MOVS     r0,#1
                  |L1.104|
;;;1256       }        
;;;1257     } 
;;;1258   
;;;1259     /* Enable the write protection for RTC registers */
;;;1260     RTC->WPR = 0xFF; 
000068  24ff              MOVS     r4,#0xff
00006a  4d01              LDR      r5,|L1.112|
00006c  602c              STR      r4,[r5,#0]
;;;1261     
;;;1262     return status;
;;;1263   }
00006e  bd38              POP      {r3-r5,pc}
;;;1264   
                          ENDP

                  |L1.112|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1131     */
;;;1132   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1133   {
;;;1134     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1135     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1136     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1137     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1138     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1139   
;;;1140     /* Alarm Date Settings : Date = 1st day of the month */
;;;1141     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
00000a  6081              STR      r1,[r0,#8]
;;;1142     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000c  2101              MOVS     r1,#1
00000e  7301              STRB     r1,[r0,#0xc]
;;;1143   
;;;1144     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1145     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  2100              MOVS     r1,#0
000012  6041              STR      r1,[r0,#4]
;;;1146   }
000014  4770              BX       lr
;;;1147   
                          ENDP


                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2224     */
;;;2225   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  4601              MOV      r1,r0
;;;2226   {
;;;2227     uint8_t tmp = 0;
000002  bf00              NOP      
;;;2228     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000004  0908              LSRS     r0,r1,#4
000006  eb000080          ADD      r0,r0,r0,LSL #2
00000a  0042              LSLS     r2,r0,#1
;;;2229     return (tmp + (Value & (uint8_t)0x0F));
00000c  f001000f          AND      r0,r1,#0xf
000010  4410              ADD      r0,r0,r2
000012  b2c0              UXTB     r0,r0
;;;2230   }
000014  4770              BX       lr
;;;2231   
                          ENDP


                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2206     */
;;;2207   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  4601              MOV      r1,r0
;;;2208   {
;;;2209     uint8_t bcdhigh = 0;
000002  2200              MOVS     r2,#0
;;;2210     
;;;2211     while (Value >= 10)
000004  e004              B        |L4.16|
                  |L4.6|
;;;2212     {
;;;2213       bcdhigh++;
000006  1c50              ADDS     r0,r2,#1
000008  b2c2              UXTB     r2,r0
;;;2214       Value -= 10;
00000a  f1a1000a          SUB      r0,r1,#0xa
00000e  b2c1              UXTB     r1,r0
                  |L4.16|
000010  290a              CMP      r1,#0xa               ;2211
000012  daf8              BGE      |L4.6|
;;;2215     }
;;;2216     
;;;2217     return  ((uint8_t)(bcdhigh << 4) | Value);
000014  0710              LSLS     r0,r2,#28
000016  ea416010          ORR      r0,r1,r0,LSR #24
;;;2218   }
00001a  4770              BX       lr
;;;2219   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1640     */
;;;1641   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  21ca              MOVS     r1,#0xca
;;;1642   {
;;;1643     /* Check the parameters */
;;;1644     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1645     
;;;1646     /* Disable the write protection for RTC registers */
;;;1647     RTC->WPR = 0xCA;
000002  4a0d              LDR      r2,|L5.56|
000004  6011              STR      r1,[r2,#0]
;;;1648     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1649     
;;;1650     if (NewState != DISABLE)
00000a  b140              CBZ      r0,|L5.30|
;;;1651     {
;;;1652       /* Enable the RTC clock output */
;;;1653       RTC->CR |= (uint32_t)RTC_CR_COE;
00000c  490a              LDR      r1,|L5.56|
00000e  391c              SUBS     r1,r1,#0x1c
000010  6809              LDR      r1,[r1,#0]
000012  f4410100          ORR      r1,r1,#0x800000
000016  4a08              LDR      r2,|L5.56|
000018  3a1c              SUBS     r2,r2,#0x1c
00001a  6011              STR      r1,[r2,#0]
00001c  e007              B        |L5.46|
                  |L5.30|
;;;1654     }
;;;1655     else
;;;1656     { 
;;;1657       /* Disable the RTC clock output */
;;;1658       RTC->CR &= (uint32_t)~RTC_CR_COE;
00001e  4906              LDR      r1,|L5.56|
000020  391c              SUBS     r1,r1,#0x1c
000022  6809              LDR      r1,[r1,#0]
000024  f4210100          BIC      r1,r1,#0x800000
000028  4a03              LDR      r2,|L5.56|
00002a  3a1c              SUBS     r2,r2,#0x1c
00002c  6011              STR      r1,[r2,#0]
                  |L5.46|
;;;1659     }
;;;1660     
;;;1661     /* Enable the write protection for RTC registers */
;;;1662     RTC->WPR = 0xFF; 
00002e  21ff              MOVS     r1,#0xff
000030  4a01              LDR      r2,|L5.56|
000032  6011              STR      r1,[r2,#0]
;;;1663   }
000034  4770              BX       lr
;;;1664   
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2123     */
;;;2124   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  b281              UXTH     r1,r0
;;;2125   {
;;;2126     /* Check the parameters */
;;;2127     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2128   
;;;2129     /* Clear the Flags in the RTC_ISR register */
;;;2130     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
000002  f0410180          ORR      r1,r1,#0x80
000006  4a04              LDR      r2,|L6.24|
000008  6812              LDR      r2,[r2,#0]
00000a  f0020280          AND      r2,r2,#0x80
00000e  ea620101          ORN      r1,r2,r1
000012  4a01              LDR      r2,|L6.24|
000014  6011              STR      r1,[r2,#0]
;;;2131   }
000016  4770              BX       lr
;;;2132   
                          ENDP

                  |L6.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2183     */
;;;2184   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  2100              MOVS     r1,#0
;;;2185   {
;;;2186     uint32_t tmpreg = 0;
;;;2187   
;;;2188     /* Check the parameters */
;;;2189     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2190   
;;;2191     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2192     tmpreg = (uint32_t)(RTC_IT >> 4);
000002  0901              LSRS     r1,r0,#4
;;;2193   
;;;2194     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2195     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  b28a              UXTH     r2,r1
000006  f0420280          ORR      r2,r2,#0x80
00000a  4b04              LDR      r3,|L7.28|
00000c  681b              LDR      r3,[r3,#0]
00000e  f0030380          AND      r3,r3,#0x80
000012  ea630202          ORN      r2,r3,r2
000016  4b01              LDR      r3,|L7.28|
000018  601a              STR      r2,[r3,#0]
;;;2196   }
00001a  4770              BX       lr
;;;2197   
                          ENDP

                  |L7.28|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1594     */
;;;1595   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1596   {
000002  4604              MOV      r4,r0
;;;1597     ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;1598     
;;;1599     /* Check the parameters */
;;;1600     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1601   
;;;1602     /* Disable the write protection for RTC registers */
;;;1603     RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4910              LDR      r1,|L8.76|
00000a  6008              STR      r0,[r1,#0]
;;;1604     RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;1605     
;;;1606     /* Set Initialization mode */
;;;1607     if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b900              CBNZ     r0,|L8.24|
;;;1608     {
;;;1609       status =  ERROR;
000016  e014              B        |L8.66|
                  |L8.24|
;;;1610     }
;;;1611     else
;;;1612     {
;;;1613       if (NewState != DISABLE)
000018  b144              CBZ      r4,|L8.44|
;;;1614       {
;;;1615         /* Enable the Coarse Calibration */
;;;1616         RTC->CR |= (uint32_t)RTC_CR_DCE;
00001a  480c              LDR      r0,|L8.76|
00001c  381c              SUBS     r0,r0,#0x1c
00001e  6800              LDR      r0,[r0,#0]
000020  f0400080          ORR      r0,r0,#0x80
000024  4909              LDR      r1,|L8.76|
000026  391c              SUBS     r1,r1,#0x1c
000028  6008              STR      r0,[r1,#0]
00002a  e007              B        |L8.60|
                  |L8.44|
;;;1617       }
;;;1618       else
;;;1619       { 
;;;1620         /* Disable the Coarse Calibration */
;;;1621         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00002c  4807              LDR      r0,|L8.76|
00002e  381c              SUBS     r0,r0,#0x1c
000030  6800              LDR      r0,[r0,#0]
000032  f0200080          BIC      r0,r0,#0x80
000036  4905              LDR      r1,|L8.76|
000038  391c              SUBS     r1,r1,#0x1c
00003a  6008              STR      r0,[r1,#0]
                  |L8.60|
;;;1622       }
;;;1623       /* Exit Initialization mode */
;;;1624       RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;1625       
;;;1626       status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L8.66|
;;;1627     } 
;;;1628     
;;;1629     /* Enable the write protection for RTC registers */
;;;1630     RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  4901              LDR      r1,|L8.76|
000046  6008              STR      r0,[r1,#0]
;;;1631     
;;;1632     return status;
000048  4628              MOV      r0,r5
;;;1633   }
00004a  bd30              POP      {r4,r5,pc}
;;;1634   
                          ENDP

                  |L8.76|
                          DCD      0x40002824

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1553     */
;;;1554   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  b570              PUSH     {r4-r6,lr}
;;;1555   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1556     ErrorStatus status = ERROR;
000006  2600              MOVS     r6,#0
;;;1557      
;;;1558     /* Check the parameters */
;;;1559     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1560     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1561   
;;;1562     /* Disable the write protection for RTC registers */
;;;1563     RTC->WPR = 0xCA;
000008  20ca              MOVS     r0,#0xca
00000a  490a              LDR      r1,|L9.52|
00000c  6008              STR      r0,[r1,#0]
;;;1564     RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6008              STR      r0,[r1,#0]
;;;1565   
;;;1566     /* Set Initialization mode */
;;;1567     if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b900              CBNZ     r0,|L9.26|
;;;1568     {
;;;1569       status = ERROR;
000018  e007              B        |L9.42|
                  |L9.26|
;;;1570     } 
;;;1571     else
;;;1572     {
;;;1573       /* Set the coarse calibration value */
;;;1574       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
00001a  ea440005          ORR      r0,r4,r5
00001e  4905              LDR      r1,|L9.52|
000020  390c              SUBS     r1,r1,#0xc
000022  6008              STR      r0,[r1,#0]
;;;1575       /* Exit Initialization mode */
;;;1576       RTC_ExitInitMode();
000024  f7fffffe          BL       RTC_ExitInitMode
;;;1577       
;;;1578       status = SUCCESS;
000028  2601              MOVS     r6,#1
                  |L9.42|
;;;1579     } 
;;;1580   
;;;1581     /* Enable the write protection for RTC registers */
;;;1582     RTC->WPR = 0xFF; 
00002a  20ff              MOVS     r0,#0xff
00002c  4901              LDR      r1,|L9.52|
00002e  6008              STR      r0,[r1,#0]
;;;1583     
;;;1584     return status;
000030  4630              MOV      r0,r6
;;;1585   }
000032  bd70              POP      {r4-r6,pc}
;;;1586   
                          ENDP

                  |L9.52|
                          DCD      0x40002824

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;941      */
;;;942    void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;943    {
;;;944      /* Monday, January 01 xx00 */
;;;945      RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;946      RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;947      RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;948      RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;949    }
00000c  4770              BX       lr
;;;950    
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1433     */
;;;1434   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  22ca              MOVS     r2,#0xca
;;;1435   {
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1438     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1439   
;;;1440     /* Disable the write protection for RTC registers */
;;;1441     RTC->WPR = 0xCA;
000002  4b0c              LDR      r3,|L11.52|
000004  601a              STR      r2,[r3,#0]
;;;1442     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;1443   
;;;1444     /* Clear the bits to be configured */
;;;1445     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000a  4a0a              LDR      r2,|L11.52|
00000c  3a1c              SUBS     r2,r2,#0x1c
00000e  6812              LDR      r2,[r2,#0]
000010  f4222280          BIC      r2,r2,#0x40000
000014  4b07              LDR      r3,|L11.52|
000016  3b1c              SUBS     r3,r3,#0x1c
000018  601a              STR      r2,[r3,#0]
;;;1446   
;;;1447     /* Configure the RTC_CR register */
;;;1448     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
00001a  461a              MOV      r2,r3
00001c  6812              LDR      r2,[r2,#0]
00001e  ea400301          ORR      r3,r0,r1
000022  431a              ORRS     r2,r2,r3
000024  4b03              LDR      r3,|L11.52|
000026  3b1c              SUBS     r3,r3,#0x1c
000028  601a              STR      r2,[r3,#0]
;;;1449   
;;;1450     /* Enable the write protection for RTC registers */
;;;1451     RTC->WPR = 0xFF; 
00002a  22ff              MOVS     r2,#0xff
00002c  4b01              LDR      r3,|L11.52|
00002e  601a              STR      r2,[r3,#0]
;;;1452   }
000030  4770              BX       lr
;;;1453   
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;351      */
;;;352    ErrorStatus RTC_DeInit(void)
000000  b538              PUSH     {r3-r5,lr}
;;;353    {
;;;354      __IO uint32_t wutcounter = 0x00;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;355      uint32_t wutwfstatus = 0x00;
000006  2400              MOVS     r4,#0
;;;356      ErrorStatus status = ERROR;
000008  2500              MOVS     r5,#0
;;;357      
;;;358      /* Disable the write protection for RTC registers */
;;;359      RTC->WPR = 0xCA;
00000a  20ca              MOVS     r0,#0xca
00000c  492a              LDR      r1,|L12.184|
00000e  6008              STR      r0,[r1,#0]
;;;360      RTC->WPR = 0x53;
000010  2053              MOVS     r0,#0x53
000012  6008              STR      r0,[r1,#0]
;;;361    
;;;362      /* Set Initialization mode */
;;;363      if (RTC_EnterInitMode() == ERROR)
000014  f7fffffe          BL       RTC_EnterInitMode
000018  b900              CBNZ     r0,|L12.28|
;;;364      {
;;;365        status = ERROR;
00001a  e047              B        |L12.172|
                  |L12.28|
;;;366      }  
;;;367      else
;;;368      {
;;;369        /* Reset TR, DR and CR registers */
;;;370        RTC->TR = (uint32_t)0x00000000;
00001c  2000              MOVS     r0,#0
00001e  4926              LDR      r1,|L12.184|
000020  3924              SUBS     r1,r1,#0x24
000022  6008              STR      r0,[r1,#0]
;;;371        RTC->DR = (uint32_t)0x00002101;
000024  f2421001          MOV      r0,#0x2101
000028  1d09              ADDS     r1,r1,#4
00002a  6008              STR      r0,[r1,#0]
;;;372        /* Reset All CR bits except CR[2:0] */
;;;373        RTC->CR &= (uint32_t)0x00000007;
00002c  1d08              ADDS     r0,r1,#4
00002e  6800              LDR      r0,[r0,#0]
000030  f0000007          AND      r0,r0,#7
000034  1d09              ADDS     r1,r1,#4
000036  6008              STR      r0,[r1,#0]
;;;374      
;;;375        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;376        do
000038  bf00              NOP      
                  |L12.58|
;;;377        {
;;;378          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
00003a  481f              LDR      r0,|L12.184|
00003c  3818              SUBS     r0,r0,#0x18
00003e  6800              LDR      r0,[r0,#0]
000040  f0000404          AND      r4,r0,#4
;;;379          wutcounter++;  
000044  9800              LDR      r0,[sp,#0]
000046  1c40              ADDS     r0,r0,#1
000048  9000              STR      r0,[sp,#0]
;;;380        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00004a  9800              LDR      r0,[sp,#0]
00004c  f5b03f80          CMP      r0,#0x10000
000050  d001              BEQ      |L12.86|
000052  2c00              CMP      r4,#0
000054  d0f1              BEQ      |L12.58|
                  |L12.86|
;;;381        
;;;382        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000056  4818              LDR      r0,|L12.184|
000058  3818              SUBS     r0,r0,#0x18
00005a  6800              LDR      r0,[r0,#0]
00005c  f0000004          AND      r0,r0,#4
000060  b908              CBNZ     r0,|L12.102|
;;;383        {
;;;384          status = ERROR;
000062  2500              MOVS     r5,#0
000064  e022              B        |L12.172|
                  |L12.102|
;;;385        }
;;;386        else
;;;387        {
;;;388          /* Reset all RTC CR register bits */
;;;389          RTC->CR &= (uint32_t)0x00000000;
000066  4814              LDR      r0,|L12.184|
000068  381c              SUBS     r0,r0,#0x1c
00006a  6800              LDR      r0,[r0,#0]
00006c  2000              MOVS     r0,#0
00006e  4912              LDR      r1,|L12.184|
000070  391c              SUBS     r1,r1,#0x1c
000072  6008              STR      r0,[r1,#0]
;;;390          RTC->WUTR = (uint32_t)0x0000FFFF;
000074  f64f70ff          MOV      r0,#0xffff
000078  490f              LDR      r1,|L12.184|
00007a  3910              SUBS     r1,r1,#0x10
00007c  6008              STR      r0,[r1,#0]
;;;391          RTC->PRER = (uint32_t)0x007F00FF;
00007e  480f              LDR      r0,|L12.188|
000080  1f09              SUBS     r1,r1,#4
000082  6008              STR      r0,[r1,#0]
;;;392          RTC->CALIBR = (uint32_t)0x00000000;
000084  2000              MOVS     r0,#0
000086  490c              LDR      r1,|L12.184|
000088  390c              SUBS     r1,r1,#0xc
00008a  6008              STR      r0,[r1,#0]
;;;393          RTC->ALRMAR = (uint32_t)0x00000000;        
00008c  1d09              ADDS     r1,r1,#4
00008e  6008              STR      r0,[r1,#0]
;;;394          RTC->ALRMBR = (uint32_t)0x00000000;
000090  1d09              ADDS     r1,r1,#4
000092  6008              STR      r0,[r1,#0]
;;;395          
;;;396          /* Reset ISR register and exit initialization mode */
;;;397          RTC->ISR = (uint32_t)0x00000000;
000094  4908              LDR      r1,|L12.184|
000096  3918              SUBS     r1,r1,#0x18
000098  6008              STR      r0,[r1,#0]
;;;398          
;;;399          /* Reset Tamper and alternate functions configuration register */
;;;400          RTC->TAFCR = 0x00000000;
00009a  4907              LDR      r1,|L12.184|
00009c  311c              ADDS     r1,r1,#0x1c
00009e  6008              STR      r0,[r1,#0]
;;;401      
;;;402          if(RTC_WaitForSynchro() == ERROR)
0000a0  f7fffffe          BL       RTC_WaitForSynchro
0000a4  b908              CBNZ     r0,|L12.170|
;;;403          {
;;;404            status = ERROR;
0000a6  2500              MOVS     r5,#0
0000a8  e000              B        |L12.172|
                  |L12.170|
;;;405          }
;;;406          else
;;;407          {
;;;408            status = SUCCESS;      
0000aa  2501              MOVS     r5,#1
                  |L12.172|
;;;409          }
;;;410        }
;;;411      }
;;;412      
;;;413      /* Enable the write protection for RTC registers */
;;;414      RTC->WPR = 0xFF;  
0000ac  20ff              MOVS     r0,#0xff
0000ae  4902              LDR      r1,|L12.184|
0000b0  6008              STR      r0,[r1,#0]
;;;415      
;;;416      return status;
0000b2  4628              MOV      r0,r5
;;;417    }
0000b4  bd38              POP      {r3-r5,pc}
;;;418    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L12.184|
                          DCD      0x40002824
                  |L12.188|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;524      */
;;;525    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;526    {
;;;527      __IO uint32_t initcounter = 0x00;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;528      ErrorStatus status = ERROR;
000006  2000              MOVS     r0,#0
;;;529      uint32_t initstatus = 0x00;
000008  2100              MOVS     r1,#0
;;;530         
;;;531      /* Check if the Initialization mode is set */
;;;532      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
00000a  4a10              LDR      r2,|L13.76|
00000c  6812              LDR      r2,[r2,#0]
00000e  f0020240          AND      r2,r2,#0x40
000012  b9ca              CBNZ     r2,|L13.72|
;;;533      {
;;;534        /* Set the Initialization mode */
;;;535        RTC->ISR = (uint32_t)RTC_INIT_MASK;
000014  1e42              SUBS     r2,r0,#1
000016  4b0d              LDR      r3,|L13.76|
000018  601a              STR      r2,[r3,#0]
;;;536        
;;;537        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;538        do
00001a  bf00              NOP      
                  |L13.28|
;;;539        {
;;;540          initstatus = RTC->ISR & RTC_ISR_INITF;
00001c  4a0b              LDR      r2,|L13.76|
00001e  6812              LDR      r2,[r2,#0]
000020  f0020140          AND      r1,r2,#0x40
;;;541          initcounter++;  
000024  9a00              LDR      r2,[sp,#0]
000026  1c52              ADDS     r2,r2,#1
000028  9200              STR      r2,[sp,#0]
;;;542        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
00002a  9a00              LDR      r2,[sp,#0]
00002c  f5b23f80          CMP      r2,#0x10000
000030  d001              BEQ      |L13.54|
000032  2900              CMP      r1,#0
000034  d0f2              BEQ      |L13.28|
                  |L13.54|
;;;543        
;;;544        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
000036  4a05              LDR      r2,|L13.76|
000038  6812              LDR      r2,[r2,#0]
00003a  f0020240          AND      r2,r2,#0x40
00003e  b10a              CBZ      r2,|L13.68|
;;;545        {
;;;546          status = SUCCESS;
000040  2001              MOVS     r0,#1
000042  e002              B        |L13.74|
                  |L13.68|
;;;547        }
;;;548        else
;;;549        {
;;;550          status = ERROR;
000044  2000              MOVS     r0,#0
000046  e000              B        |L13.74|
                  |L13.72|
;;;551        }        
;;;552      }
;;;553      else
;;;554      {
;;;555        status = SUCCESS;  
000048  2001              MOVS     r0,#1
                  |L13.74|
;;;556      } 
;;;557        
;;;558      return (status);  
;;;559    }
00004a  bd08              POP      {r3,pc}
;;;560    
                          ENDP

                  |L13.76|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;569      */
;;;570    void RTC_ExitInitMode(void)
000000  4803              LDR      r0,|L14.16|
;;;571    { 
;;;572      /* Exit Initialization mode */
;;;573      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
000002  6800              LDR      r0,[r0,#0]
000004  f0200080          BIC      r0,r0,#0x80
000008  4901              LDR      r1,|L14.16|
00000a  6008              STR      r0,[r1,#0]
;;;574    }
00000c  4770              BX       lr
;;;575    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1161     */
;;;1162   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1163   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;1164     uint32_t tmpreg = 0;
00000a  2500              MOVS     r5,#0
;;;1165   
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1168     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1169   
;;;1170     /* Get the RTC_ALRMxR register */
;;;1171     if (RTC_Alarm == RTC_Alarm_A)
00000c  f5b77f80          CMP      r7,#0x100
000010  d102              BNE      |L15.24|
;;;1172     {
;;;1173       tmpreg = (uint32_t)(RTC->ALRMAR);
000012  4817              LDR      r0,|L15.112|
000014  6805              LDR      r5,[r0,#0]
000016  e002              B        |L15.30|
                  |L15.24|
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       tmpreg = (uint32_t)(RTC->ALRMBR);
000018  4815              LDR      r0,|L15.112|
00001a  1d00              ADDS     r0,r0,#4
00001c  6805              LDR      r5,[r0,#0]
                  |L15.30|
;;;1178     }
;;;1179   
;;;1180     /* Fill the structure with the read parameters */
;;;1181     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00001e  f3c54005          UBFX     r0,r5,#16,#6
000022  7020              STRB     r0,[r4,#0]
;;;1182                                                        RTC_ALRMAR_HU)) >> 16);
;;;1183     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000024  f3c52006          UBFX     r0,r5,#8,#7
000028  7060              STRB     r0,[r4,#1]
;;;1184                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1185     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00002a  f005007f          AND      r0,r5,#0x7f
00002e  70a0              STRB     r0,[r4,#2]
;;;1186                                                        RTC_ALRMAR_SU));
;;;1187     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000030  f4050080          AND      r0,r5,#0x400000
000034  0c00              LSRS     r0,r0,#16
000036  70e0              STRB     r0,[r4,#3]
;;;1188     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000038  f3c56005          UBFX     r0,r5,#24,#6
00003c  7320              STRB     r0,[r4,#0xc]
;;;1189     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00003e  f0054080          AND      r0,r5,#0x40000000
000042  60a0              STR      r0,[r4,#8]
;;;1190     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000044  f0053080          AND      r0,r5,#0x80808080
000048  6060              STR      r0,[r4,#4]
;;;1191   
;;;1192     if (RTC_Format == RTC_Format_BIN)
00004a  b97e              CBNZ     r6,|L15.108|
;;;1193     {
;;;1194       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004c  7820              LDRB     r0,[r4,#0]
00004e  f7fffffe          BL       RTC_Bcd2ToByte
000052  7020              STRB     r0,[r4,#0]
;;;1195                                                           RTC_AlarmTime.RTC_Hours);
;;;1196       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000054  7860              LDRB     r0,[r4,#1]
000056  f7fffffe          BL       RTC_Bcd2ToByte
00005a  7060              STRB     r0,[r4,#1]
;;;1197                                                           RTC_AlarmTime.RTC_Minutes);
;;;1198       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00005c  78a0              LDRB     r0,[r4,#2]
00005e  f7fffffe          BL       RTC_Bcd2ToByte
000062  70a0              STRB     r0,[r4,#2]
;;;1199                                                           RTC_AlarmTime.RTC_Seconds);
;;;1200       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000064  7b20              LDRB     r0,[r4,#0xc]
000066  f7fffffe          BL       RTC_Bcd2ToByte
00006a  7320              STRB     r0,[r4,#0xc]
                  |L15.108|
;;;1201     }  
;;;1202   }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;1203   
                          ENDP

                  |L15.112|
                          DCD      0x4000281c

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;960      */
;;;961    void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;962    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;963      uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;964    
;;;965      /* Check the parameters */
;;;966      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;967      
;;;968      /* Get the RTC_TR register */
;;;969      tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000008  480e              LDR      r0,|L16.68|
00000a  6800              LDR      r0,[r0,#0]
00000c  490e              LDR      r1,|L16.72|
00000e  ea000501          AND      r5,r0,r1
;;;970    
;;;971      /* Fill the structure fields with the read parameters */
;;;972      RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
000012  0c28              LSRS     r0,r5,#16
000014  70e0              STRB     r0,[r4,#3]
;;;973      RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000016  f3c52004          UBFX     r0,r5,#8,#5
00001a  7060              STRB     r0,[r4,#1]
;;;974      RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
00001c  f005003f          AND      r0,r5,#0x3f
000020  70a0              STRB     r0,[r4,#2]
;;;975      RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
000022  f3c53042          UBFX     r0,r5,#13,#3
000026  7020              STRB     r0,[r4,#0]
;;;976    
;;;977      /* Check the input parameters format */
;;;978      if (RTC_Format == RTC_Format_BIN)
000028  b95e              CBNZ     r6,|L16.66|
;;;979      {
;;;980        /* Convert the structure parameters to Binary format */
;;;981        RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
00002a  78e0              LDRB     r0,[r4,#3]
00002c  f7fffffe          BL       RTC_Bcd2ToByte
000030  70e0              STRB     r0,[r4,#3]
;;;982        RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000032  7860              LDRB     r0,[r4,#1]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  7060              STRB     r0,[r4,#1]
;;;983        RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date); 
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  70a0              STRB     r0,[r4,#2]
                  |L16.66|
;;;984      }
;;;985    }
000042  bd70              POP      {r4-r6,pc}
;;;986    
                          ENDP

                  |L16.68|
                          DCD      0x40002804
                  |L16.72|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2087     */
;;;2088   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;2089   {
000002  4601              MOV      r1,r0
;;;2090     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2091     uint32_t tmpreg = 0;
000006  2200              MOVS     r2,#0
;;;2092     
;;;2093     /* Check the parameters */
;;;2094     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2095     
;;;2096     /* Get all the flags */
;;;2097     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000008  4b06              LDR      r3,|L17.36|
00000a  681b              LDR      r3,[r3,#0]
00000c  f6437477          MOV      r4,#0x3f77
000010  ea030204          AND      r2,r3,r4
;;;2098     
;;;2099     /* Return the status of the flag */
;;;2100     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
000014  ea020301          AND      r3,r2,r1
000018  b10b              CBZ      r3,|L17.30|
;;;2101     {
;;;2102       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L17.32|
                  |L17.30|
;;;2103     }
;;;2104     else
;;;2105     {
;;;2106       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L17.32|
;;;2107     }
;;;2108     return bitstatus;
;;;2109   }
000020  bd10              POP      {r4,pc}
;;;2110   
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2143     */
;;;2144   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2145   {
000002  4601              MOV      r1,r0
;;;2146     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2147     uint32_t tmpreg = 0, enablestatus = 0;
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;2148    
;;;2149     /* Check the parameters */
;;;2150     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2151     
;;;2152     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2153     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
00000a  4c0c              LDR      r4,|L18.60|
00000c  6824              LDR      r4,[r4,#0]
00000e  f0040204          AND      r2,r4,#4
;;;2154    
;;;2155     /* Get the Interrupt enable Status */
;;;2156     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
000012  4c0a              LDR      r4,|L18.60|
000014  3c38              SUBS     r4,r4,#0x38
000016  6824              LDR      r4,[r4,#0]
000018  400c              ANDS     r4,r4,r1
00001a  ea0235d1          AND      r5,r2,r1,LSR #15
00001e  ea440305          ORR      r3,r4,r5
;;;2157     
;;;2158     /* Get the Interrupt pending bit */
;;;2159     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000022  4c06              LDR      r4,|L18.60|
000024  3c34              SUBS     r4,r4,#0x34
000026  6824              LDR      r4,[r4,#0]
000028  ea041211          AND      r2,r4,r1,LSR #4
;;;2160     
;;;2161     /* Get the status of the Interrupt */
;;;2162     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
00002c  b11b              CBZ      r3,|L18.54|
00002e  b294              UXTH     r4,r2
000030  b10c              CBZ      r4,|L18.54|
;;;2163     {
;;;2164       bitstatus = SET;
000032  2001              MOVS     r0,#1
000034  e000              B        |L18.56|
                  |L18.54|
;;;2165     }
;;;2166     else
;;;2167     {
;;;2168       bitstatus = RESET;
000036  2000              MOVS     r0,#0
                  |L18.56|
;;;2169     }
;;;2170     return bitstatus;
;;;2171   }
000038  bd30              POP      {r4,r5,pc}
;;;2172   
                          ENDP

00003a  0000              DCW      0x0000
                  |L18.60|
                          DCD      0x40002840

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1460     */
;;;1461   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L19.12|
;;;1462   {
;;;1463     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1464   }
000008  4770              BX       lr
;;;1465   
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;820      */
;;;821    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;822    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;823      uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;824    
;;;825      /* Check the parameters */
;;;826      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;827    
;;;828      /* Get the RTC_TR register */
;;;829      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000008  480f              LDR      r0,|L20.72|
00000a  6800              LDR      r0,[r0,#0]
00000c  490f              LDR      r1,|L20.76|
00000e  ea000501          AND      r5,r0,r1
;;;830      
;;;831      /* Fill the structure fields with the read parameters */
;;;832      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000012  f3c54005          UBFX     r0,r5,#16,#6
000016  7020              STRB     r0,[r4,#0]
;;;833      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000018  f3c52006          UBFX     r0,r5,#8,#7
00001c  7060              STRB     r0,[r4,#1]
;;;834      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
00001e  f005007f          AND      r0,r5,#0x7f
000022  70a0              STRB     r0,[r4,#2]
;;;835      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
000024  f4050080          AND      r0,r5,#0x400000
000028  0c00              LSRS     r0,r0,#16
00002a  70e0              STRB     r0,[r4,#3]
;;;836    
;;;837      /* Check the input parameters format */
;;;838      if (RTC_Format == RTC_Format_BIN)
00002c  b95e              CBNZ     r6,|L20.70|
;;;839      {
;;;840        /* Convert the structure parameters to Binary format */
;;;841        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002e  7820              LDRB     r0,[r4,#0]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  7020              STRB     r0,[r4,#0]
;;;842        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000036  7860              LDRB     r0,[r4,#1]
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  7060              STRB     r0,[r4,#1]
;;;843        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00003e  78a0              LDRB     r0,[r4,#2]
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  70a0              STRB     r0,[r4,#2]
                  |L20.70|
;;;844      }
;;;845    }
000046  bd70              POP      {r4-r6,pc}
;;;846    
                          ENDP

                  |L20.72|
                          DCD      0x40002800
                  |L20.76|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;1739     */
;;;1740   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1741                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;1742   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1743     uint32_t tmptime = 0, tmpdate = 0;
00000a  2600              MOVS     r6,#0
00000c  2700              MOVS     r7,#0
;;;1744   
;;;1745     /* Check the parameters */
;;;1746     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1747   
;;;1748     /* Get the TimeStamp time and date registers values */
;;;1749     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
00000e  4820              LDR      r0,|L21.144|
000010  6800              LDR      r0,[r0,#0]
000012  4920              LDR      r1,|L21.148|
000014  ea000601          AND      r6,r0,r1
;;;1750     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
000018  481d              LDR      r0,|L21.144|
00001a  1d00              ADDS     r0,r0,#4
00001c  6800              LDR      r0,[r0,#0]
00001e  491e              LDR      r1,|L21.152|
000020  ea000701          AND      r7,r0,r1
;;;1751   
;;;1752     /* Fill the Time structure fields with the read parameters */
;;;1753     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000024  f3c64005          UBFX     r0,r6,#16,#6
000028  7020              STRB     r0,[r4,#0]
;;;1754     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
00002a  f3c62006          UBFX     r0,r6,#8,#7
00002e  7060              STRB     r0,[r4,#1]
;;;1755     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000030  f006007f          AND      r0,r6,#0x7f
000034  70a0              STRB     r0,[r4,#2]
;;;1756     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
000036  f4060080          AND      r0,r6,#0x400000
00003a  0c00              LSRS     r0,r0,#16
00003c  70e0              STRB     r0,[r4,#3]
;;;1757   
;;;1758     /* Fill the Date structure fields with the read parameters */
;;;1759     RTC_StampDateStruct->RTC_Year = 0;
00003e  2000              MOVS     r0,#0
000040  70e8              STRB     r0,[r5,#3]
;;;1760     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000042  f3c72004          UBFX     r0,r7,#8,#5
000046  7068              STRB     r0,[r5,#1]
;;;1761     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
000048  f007003f          AND      r0,r7,#0x3f
00004c  70a8              STRB     r0,[r5,#2]
;;;1762     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
00004e  f3c73042          UBFX     r0,r7,#13,#3
000052  7028              STRB     r0,[r5,#0]
;;;1763   
;;;1764     /* Check the input parameters format */
;;;1765     if (RTC_Format == RTC_Format_BIN)
000054  f1b80f00          CMP      r8,#0
000058  d117              BNE      |L21.138|
;;;1766     {
;;;1767       /* Convert the Time structure parameters to Binary format */
;;;1768       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
00005a  7820              LDRB     r0,[r4,#0]
00005c  f7fffffe          BL       RTC_Bcd2ToByte
000060  7020              STRB     r0,[r4,#0]
;;;1769       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000062  7860              LDRB     r0,[r4,#1]
000064  f7fffffe          BL       RTC_Bcd2ToByte
000068  7060              STRB     r0,[r4,#1]
;;;1770       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
00006a  78a0              LDRB     r0,[r4,#2]
00006c  f7fffffe          BL       RTC_Bcd2ToByte
000070  70a0              STRB     r0,[r4,#2]
;;;1771   
;;;1772       /* Convert the Date structure parameters to Binary format */
;;;1773       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000072  7868              LDRB     r0,[r5,#1]
000074  f7fffffe          BL       RTC_Bcd2ToByte
000078  7068              STRB     r0,[r5,#1]
;;;1774       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00007a  78a8              LDRB     r0,[r5,#2]
00007c  f7fffffe          BL       RTC_Bcd2ToByte
000080  70a8              STRB     r0,[r5,#2]
;;;1775       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000082  7828              LDRB     r0,[r5,#0]
000084  f7fffffe          BL       RTC_Bcd2ToByte
000088  7028              STRB     r0,[r5,#0]
                  |L21.138|
;;;1776     }
;;;1777   }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;1778   
                          ENDP

00008e  0000              DCW      0x0000
                  |L21.144|
                          DCD      0x40002830
                  |L21.148|
                          DCD      0x007f7f7f
                  |L21.152|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1344     */
;;;1345   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L22.8|
;;;1346   {
;;;1347     /* Get the counter value */
;;;1348     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1349   }
000006  4770              BX       lr
;;;1350   
                          ENDP

                  |L22.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2041     */
;;;2042   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  22ca              MOVS     r2,#0xca
;;;2043   {
;;;2044     /* Check the parameters */
;;;2045     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2046     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2047   
;;;2048     /* Disable the write protection for RTC registers */
;;;2049     RTC->WPR = 0xCA;
000002  4b17              LDR      r3,|L23.96|
000004  601a              STR      r2,[r3,#0]
;;;2050     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;2051   
;;;2052     if (NewState != DISABLE)
00000a  b191              CBZ      r1,|L23.50|
;;;2053     {
;;;2054       /* Configure the Interrupts in the RTC_CR register */
;;;2055       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4a14              LDR      r2,|L23.96|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6812              LDR      r2,[r2,#0]
000012  f0200304          BIC      r3,r0,#4
000016  431a              ORRS     r2,r2,r3
000018  4b11              LDR      r3,|L23.96|
00001a  3b1c              SUBS     r3,r3,#0x1c
00001c  601a              STR      r2,[r3,#0]
;;;2056       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2057       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00001e  4a10              LDR      r2,|L23.96|
000020  321c              ADDS     r2,r2,#0x1c
000022  6812              LDR      r2,[r2,#0]
000024  f0000304          AND      r3,r0,#4
000028  431a              ORRS     r2,r2,r3
00002a  4b0d              LDR      r3,|L23.96|
00002c  331c              ADDS     r3,r3,#0x1c
00002e  601a              STR      r2,[r3,#0]
000030  e011              B        |L23.86|
                  |L23.50|
;;;2058     }
;;;2059     else
;;;2060     {
;;;2061       /* Configure the Interrupts in the RTC_CR register */
;;;2062       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000032  4a0b              LDR      r2,|L23.96|
000034  3a1c              SUBS     r2,r2,#0x1c
000036  6812              LDR      r2,[r2,#0]
000038  f0200304          BIC      r3,r0,#4
00003c  439a              BICS     r2,r2,r3
00003e  4b08              LDR      r3,|L23.96|
000040  3b1c              SUBS     r3,r3,#0x1c
000042  601a              STR      r2,[r3,#0]
;;;2063       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2064       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000044  4a06              LDR      r2,|L23.96|
000046  321c              ADDS     r2,r2,#0x1c
000048  6812              LDR      r2,[r2,#0]
00004a  f0000304          AND      r3,r0,#4
00004e  439a              BICS     r2,r2,r3
000050  4b03              LDR      r3,|L23.96|
000052  331c              ADDS     r3,r3,#0x1c
000054  601a              STR      r2,[r3,#0]
                  |L23.86|
;;;2065     }
;;;2066     /* Enable the write protection for RTC registers */
;;;2067     RTC->WPR = 0xFF; 
000056  22ff              MOVS     r2,#0xff
000058  4b01              LDR      r3,|L23.96|
00005a  601a              STR      r2,[r3,#0]
;;;2068   }
00005c  4770              BX       lr
;;;2069   
                          ENDP

00005e  0000              DCW      0x0000
                  |L23.96|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;429      */
;;;430    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;431    {
000002  4604              MOV      r4,r0
;;;432      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;433      
;;;434      /* Check the parameters */
;;;435      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;436      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;437      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;438    
;;;439      /* Disable the write protection for RTC registers */
;;;440      RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4915              LDR      r1,|L24.96|
00000a  6008              STR      r0,[r1,#0]
;;;441      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;442    
;;;443      /* Set Initialization mode */
;;;444      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b900              CBNZ     r0,|L24.24|
;;;445      {
;;;446        status = ERROR;
000016  e01d              B        |L24.84|
                  |L24.24|
;;;447      } 
;;;448      else
;;;449      {
;;;450        /* Clear RTC CR FMT Bit */
;;;451        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000018  4811              LDR      r0,|L24.96|
00001a  381c              SUBS     r0,r0,#0x1c
00001c  6800              LDR      r0,[r0,#0]
00001e  f0200040          BIC      r0,r0,#0x40
000022  490f              LDR      r1,|L24.96|
000024  391c              SUBS     r1,r1,#0x1c
000026  6008              STR      r0,[r1,#0]
;;;452        /* Set RTC_CR register */
;;;453        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  6821              LDR      r1,[r4,#0]
00002e  4308              ORRS     r0,r0,r1
000030  490b              LDR      r1,|L24.96|
000032  391c              SUBS     r1,r1,#0x1c
000034  6008              STR      r0,[r1,#0]
;;;454      
;;;455        /* Configure the RTC PRER */
;;;456        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
000036  490a              LDR      r1,|L24.96|
000038  3914              SUBS     r1,r1,#0x14
00003a  68a0              LDR      r0,[r4,#8]
00003c  6008              STR      r0,[r1,#0]
;;;457        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  88a1              LDRH     r1,[r4,#4]
000044  ea404001          ORR      r0,r0,r1,LSL #16
000048  4905              LDR      r1,|L24.96|
00004a  3914              SUBS     r1,r1,#0x14
00004c  6008              STR      r0,[r1,#0]
;;;458    
;;;459        /* Exit Initialization mode */
;;;460        RTC_ExitInitMode();
00004e  f7fffffe          BL       RTC_ExitInitMode
;;;461    
;;;462        status = SUCCESS;    
000052  2501              MOVS     r5,#1
                  |L24.84|
;;;463      }
;;;464      /* Enable the write protection for RTC registers */
;;;465      RTC->WPR = 0xFF; 
000054  20ff              MOVS     r0,#0xff
000056  4902              LDR      r1,|L24.96|
000058  6008              STR      r0,[r1,#0]
;;;466      
;;;467      return status;
00005a  4628              MOV      r0,r5
;;;468    }
00005c  bd30              POP      {r4,r5,pc}
;;;469    
                          ENDP

00005e  0000              DCW      0x0000
                  |L24.96|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1499     */
;;;1500   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  22ca              MOVS     r2,#0xca
;;;1501   {
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1504     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1505   
;;;1506     /* Disable the write protection for RTC registers */
;;;1507     RTC->WPR = 0xCA;
000002  4b0c              LDR      r3,|L25.52|
000004  601a              STR      r2,[r3,#0]
;;;1508     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;1509   
;;;1510     /* Clear the bits to be configured */
;;;1511     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000a  4a0a              LDR      r2,|L25.52|
00000c  3a1c              SUBS     r2,r2,#0x1c
00000e  6812              LDR      r2,[r2,#0]
000010  f42202e0          BIC      r2,r2,#0x700000
000014  4b07              LDR      r3,|L25.52|
000016  3b1c              SUBS     r3,r3,#0x1c
000018  601a              STR      r2,[r3,#0]
;;;1512   
;;;1513     /* Configure the output selection and polarity */
;;;1514     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
00001a  461a              MOV      r2,r3
00001c  6812              LDR      r2,[r2,#0]
00001e  ea400301          ORR      r3,r0,r1
000022  431a              ORRS     r2,r2,r3
000024  4b03              LDR      r3,|L25.52|
000026  3b1c              SUBS     r3,r3,#0x1c
000028  601a              STR      r2,[r3,#0]
;;;1515   
;;;1516     /* Enable the write protection for RTC registers */
;;;1517     RTC->WPR = 0xFF; 
00002a  22ff              MOVS     r2,#0xff
00002c  4b01              LDR      r3,|L25.52|
00002e  601a              STR      r2,[r3,#0]
;;;1518   }
000030  4770              BX       lr
;;;1519   
                          ENDP

000032  0000              DCW      0x0000
                  |L25.52|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;1970     */
;;;1971   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4905              LDR      r1,|L26.24|
;;;1972   {
;;;1973     /* Check the parameters */
;;;1974     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;1975     
;;;1976     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  6809              LDR      r1,[r1,#0]
000004  f4212180          BIC      r1,r1,#0x40000
000008  4a03              LDR      r2,|L26.24|
00000a  6011              STR      r1,[r2,#0]
;;;1977     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;1978   }
000014  4770              BX       lr
;;;1979   
                          ENDP

000016  0000              DCW      0x0000
                  |L26.24|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;1894     */
;;;1895   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b508              PUSH     {r3,lr}
;;;1896   {
000002  4601              MOV      r1,r0
;;;1897     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1898     
;;;1899     /* Check the parameters */
;;;1900     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;1901   
;;;1902     tmp = RTC_BASE + 0x50;
000008  4804              LDR      r0,|L27.28|
00000a  9000              STR      r0,[sp,#0]
;;;1903     tmp += (RTC_BKP_DR * 4);
00000c  9800              LDR      r0,[sp,#0]
00000e  eb000081          ADD      r0,r0,r1,LSL #2
000012  9000              STR      r0,[sp,#0]
;;;1904     
;;;1905     /* Read the specified register */
;;;1906     return (*(__IO uint32_t *)tmp);
000014  9800              LDR      r0,[sp,#0]
000016  6800              LDR      r0,[r0,#0]
;;;1907   }
000018  bd08              POP      {r3,pc}
;;;1908   
                          ENDP

00001a  0000              DCW      0x0000
                  |L27.28|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;634      */
;;;635    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;636    { 
000002  4604              MOV      r4,r0
;;;637      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;638      
;;;639      /* Check the parameters */
;;;640      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;641      
;;;642      /* Disable the write protection for RTC registers */
;;;643      RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4910              LDR      r1,|L28.76|
00000a  6008              STR      r0,[r1,#0]
;;;644      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;645        
;;;646      /* Set Initialization mode */
;;;647      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b900              CBNZ     r0,|L28.24|
;;;648      {
;;;649        status = ERROR;
000016  e014              B        |L28.66|
                  |L28.24|
;;;650      } 
;;;651      else
;;;652      {  
;;;653        if (NewState != DISABLE)
000018  b144              CBZ      r4,|L28.44|
;;;654        {
;;;655          /* Enable the RTC reference clock detection */
;;;656          RTC->CR |= RTC_CR_REFCKON;   
00001a  480c              LDR      r0,|L28.76|
00001c  381c              SUBS     r0,r0,#0x1c
00001e  6800              LDR      r0,[r0,#0]
000020  f0400010          ORR      r0,r0,#0x10
000024  4909              LDR      r1,|L28.76|
000026  391c              SUBS     r1,r1,#0x1c
000028  6008              STR      r0,[r1,#0]
00002a  e007              B        |L28.60|
                  |L28.44|
;;;657        }
;;;658        else
;;;659        {
;;;660          /* Disable the RTC reference clock detection */
;;;661          RTC->CR &= ~RTC_CR_REFCKON;    
00002c  4807              LDR      r0,|L28.76|
00002e  381c              SUBS     r0,r0,#0x1c
000030  6800              LDR      r0,[r0,#0]
000032  f0200010          BIC      r0,r0,#0x10
000036  4905              LDR      r1,|L28.76|
000038  391c              SUBS     r1,r1,#0x1c
00003a  6008              STR      r0,[r1,#0]
                  |L28.60|
;;;662        }
;;;663        /* Exit Initialization mode */
;;;664        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;665        
;;;666        status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L28.66|
;;;667      }
;;;668      
;;;669      /* Enable the write protection for RTC registers */
;;;670      RTC->WPR = 0xFF;  
000042  20ff              MOVS     r0,#0xff
000044  4901              LDR      r1,|L28.76|
000046  6008              STR      r0,[r1,#0]
;;;671      
;;;672      return status; 
000048  4628              MOV      r0,r5
;;;673    }
00004a  bd30              POP      {r4,r5,pc}
;;;674    
                          ENDP

                  |L28.76|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1020     */
;;;1021   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1022   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1023     uint32_t tmpreg = 0;
00000a  2700              MOVS     r7,#0
;;;1024     
;;;1025     /* Check the parameters */
;;;1026     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1027     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1028     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1029     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1030   
;;;1031     if (RTC_Format == RTC_Format_BIN)
00000c  b965              CBNZ     r5,|L29.40|
;;;1032     {
;;;1033       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000e  4836              LDR      r0,|L29.232|
000010  6800              LDR      r0,[r0,#0]
000012  f0000040          AND      r0,r0,#0x40
000016  b100              CBZ      r0,|L29.26|
;;;1034       {
;;;1035         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1036         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
000018  e002              B        |L29.32|
                  |L29.26|
;;;1037       } 
;;;1038       else
;;;1039       {
;;;1040         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
00001a  2000              MOVS     r0,#0
00001c  70e0              STRB     r0,[r4,#3]
;;;1041         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
00001e  bf00              NOP      
                  |L29.32|
;;;1042       }
;;;1043       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1044       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1045       
;;;1046       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000020  68a0              LDR      r0,[r4,#8]
000022  b900              CBNZ     r0,|L29.38|
;;;1047       {
;;;1048         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000024  e019              B        |L29.90|
                  |L29.38|
;;;1049       }
;;;1050       else
;;;1051       {
;;;1052         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000026  e018              B        |L29.90|
                  |L29.40|
;;;1053       }
;;;1054     }
;;;1055     else
;;;1056     {
;;;1057       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000028  482f              LDR      r0,|L29.232|
00002a  6800              LDR      r0,[r0,#0]
00002c  f0000040          AND      r0,r0,#0x40
000030  b120              CBZ      r0,|L29.60|
;;;1058       {
;;;1059         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000032  7820              LDRB     r0,[r4,#0]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  4607              MOV      r7,r0
;;;1060         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1061         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00003a  e002              B        |L29.66|
                  |L29.60|
;;;1062       } 
;;;1063       else
;;;1064       {
;;;1065         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
00003c  2000              MOVS     r0,#0
00003e  70e0              STRB     r0,[r4,#3]
;;;1066         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
000040  bf00              NOP      
                  |L29.66|
;;;1067       }
;;;1068       
;;;1069       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1070       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1071       
;;;1072       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000042  68a0              LDR      r0,[r4,#8]
000044  b920              CBNZ     r0,|L29.80|
;;;1073       {
;;;1074         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000046  7b20              LDRB     r0,[r4,#0xc]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  4607              MOV      r7,r0
;;;1075         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
00004e  e004              B        |L29.90|
                  |L29.80|
;;;1076       }
;;;1077       else
;;;1078       {
;;;1079         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000050  7b20              LDRB     r0,[r4,#0xc]
000052  f7fffffe          BL       RTC_Bcd2ToByte
000056  4607              MOV      r7,r0
;;;1080         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
000058  bf00              NOP      
                  |L29.90|
;;;1081       }    
;;;1082     }
;;;1083   
;;;1084     /* Check the input parameters format */
;;;1085     if (RTC_Format != RTC_Format_BIN)
00005a  b195              CBZ      r5,|L29.130|
;;;1086     {
;;;1087       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
00005c  7820              LDRB     r0,[r4,#0]
00005e  0400              LSLS     r0,r0,#16
000060  7861              LDRB     r1,[r4,#1]
000062  ea402001          ORR      r0,r0,r1,LSL #8
000066  78a1              LDRB     r1,[r4,#2]
000068  4308              ORRS     r0,r0,r1
00006a  78e1              LDRB     r1,[r4,#3]
00006c  ea404001          ORR      r0,r0,r1,LSL #16
000070  7b21              LDRB     r1,[r4,#0xc]
000072  ea406001          ORR      r0,r0,r1,LSL #24
000076  68a1              LDR      r1,[r4,#8]
000078  4308              ORRS     r0,r0,r1
00007a  6861              LDR      r1,[r4,#4]
00007c  ea400701          ORR      r7,r0,r1
000080  e01b              B        |L29.186|
                  |L29.130|
;;;1088                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1089                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1090                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1091                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1092                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1093                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1094     }  
;;;1095     else
;;;1096     {
;;;1097       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000082  7820              LDRB     r0,[r4,#0]
000084  f7fffffe          BL       RTC_ByteToBcd2
000088  ea4f4800          LSL      r8,r0,#16
00008c  7860              LDRB     r0,[r4,#1]
00008e  f7fffffe          BL       RTC_ByteToBcd2
000092  ea482800          ORR      r8,r8,r0,LSL #8
000096  78a0              LDRB     r0,[r4,#2]
000098  f7fffffe          BL       RTC_ByteToBcd2
00009c  ea480800          ORR      r8,r8,r0
0000a0  78e0              LDRB     r0,[r4,#3]
0000a2  ea484800          ORR      r8,r8,r0,LSL #16
0000a6  7b20              LDRB     r0,[r4,#0xc]
0000a8  f7fffffe          BL       RTC_ByteToBcd2
0000ac  ea486000          ORR      r0,r8,r0,LSL #24
0000b0  68a1              LDR      r1,[r4,#8]
0000b2  4308              ORRS     r0,r0,r1
0000b4  6861              LDR      r1,[r4,#4]
0000b6  ea400701          ORR      r7,r0,r1
                  |L29.186|
;;;1098                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1099                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1100                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1101                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1102                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1103                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1104     } 
;;;1105   
;;;1106     /* Disable the write protection for RTC registers */
;;;1107     RTC->WPR = 0xCA;
0000ba  20ca              MOVS     r0,#0xca
0000bc  490a              LDR      r1,|L29.232|
0000be  311c              ADDS     r1,r1,#0x1c
0000c0  6008              STR      r0,[r1,#0]
;;;1108     RTC->WPR = 0x53;
0000c2  2053              MOVS     r0,#0x53
0000c4  6008              STR      r0,[r1,#0]
;;;1109   
;;;1110     /* Configure the Alarm register */
;;;1111     if (RTC_Alarm == RTC_Alarm_A)
0000c6  f5b67f80          CMP      r6,#0x100
0000ca  d103              BNE      |L29.212|
;;;1112     {
;;;1113       RTC->ALRMAR = (uint32_t)tmpreg;
0000cc  4806              LDR      r0,|L29.232|
0000ce  3014              ADDS     r0,r0,#0x14
0000d0  6007              STR      r7,[r0,#0]
0000d2  e002              B        |L29.218|
                  |L29.212|
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       RTC->ALRMBR = (uint32_t)tmpreg;
0000d4  4804              LDR      r0,|L29.232|
0000d6  3018              ADDS     r0,r0,#0x18
0000d8  6007              STR      r7,[r0,#0]
                  |L29.218|
;;;1118     }
;;;1119   
;;;1120     /* Enable the write protection for RTC registers */
;;;1121     RTC->WPR = 0xFF;   
0000da  20ff              MOVS     r0,#0xff
0000dc  4902              LDR      r1,|L29.232|
0000de  311c              ADDS     r1,r1,#0x1c
0000e0  6008              STR      r0,[r1,#0]
;;;1122   }
0000e2  e8bd81f0          POP      {r4-r8,pc}
;;;1123   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L29.232|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;858      */
;;;859    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;860    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;861      uint32_t tmpreg = 0;
000008  2600              MOVS     r6,#0
;;;862      ErrorStatus status = ERROR;
00000a  2700              MOVS     r7,#0
;;;863      
;;;864      /* Check the parameters */
;;;865      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;866    
;;;867      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
00000c  b94d              CBNZ     r5,|L30.34|
00000e  7860              LDRB     r0,[r4,#1]
000010  f0000010          AND      r0,r0,#0x10
000014  2810              CMP      r0,#0x10
000016  d104              BNE      |L30.34|
;;;868      {
;;;869        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
000018  7860              LDRB     r0,[r4,#1]
00001a  f0200010          BIC      r0,r0,#0x10
00001e  300a              ADDS     r0,r0,#0xa
000020  7060              STRB     r0,[r4,#1]
                  |L30.34|
;;;870      }  
;;;871      if (RTC_Format == RTC_Format_BIN)
000022  b905              CBNZ     r5,|L30.38|
;;;872      {
;;;873        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;874        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;875        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
000024  e008              B        |L30.56|
                  |L30.38|
;;;876      }
;;;877      else
;;;878      {
;;;879        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;880        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000026  7860              LDRB     r0,[r4,#1]
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  4606              MOV      r6,r0
;;;881        assert_param(IS_RTC_MONTH(tmpreg));
;;;882        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
00002e  78a0              LDRB     r0,[r4,#2]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  4606              MOV      r6,r0
;;;883        assert_param(IS_RTC_DATE(tmpreg));
000036  bf00              NOP      
                  |L30.56|
;;;884      }
;;;885      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;886    
;;;887      /* Check the input parameters format */
;;;888      if (RTC_Format != RTC_Format_BIN)
000038  b155              CBZ      r5,|L30.80|
;;;889      {
;;;890        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
00003a  78e0              LDRB     r0,[r4,#3]
00003c  0400              LSLS     r0,r0,#16
00003e  7861              LDRB     r1,[r4,#1]
000040  ea402001          ORR      r0,r0,r1,LSL #8
000044  78a1              LDRB     r1,[r4,#2]
000046  4308              ORRS     r0,r0,r1
000048  7821              LDRB     r1,[r4,#0]
00004a  ea403641          ORR      r6,r0,r1,LSL #13
00004e  e011              B        |L30.116|
                  |L30.80|
;;;891                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;892                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;893                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;894      }  
;;;895      else
;;;896      {
;;;897        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
000050  78e0              LDRB     r0,[r4,#3]
000052  f7fffffe          BL       RTC_ByteToBcd2
000056  ea4f4800          LSL      r8,r0,#16
00005a  7860              LDRB     r0,[r4,#1]
00005c  f7fffffe          BL       RTC_ByteToBcd2
000060  ea482800          ORR      r8,r8,r0,LSL #8
000064  78a0              LDRB     r0,[r4,#2]
000066  f7fffffe          BL       RTC_ByteToBcd2
00006a  ea480800          ORR      r8,r8,r0
00006e  7820              LDRB     r0,[r4,#0]
000070  ea483640          ORR      r6,r8,r0,LSL #13
                  |L30.116|
;;;898                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;899                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;900                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;901      }
;;;902    
;;;903      /* Disable the write protection for RTC registers */
;;;904      RTC->WPR = 0xCA;
000074  20ca              MOVS     r0,#0xca
000076  490e              LDR      r1,|L30.176|
000078  6008              STR      r0,[r1,#0]
;;;905      RTC->WPR = 0x53;
00007a  2053              MOVS     r0,#0x53
00007c  6008              STR      r0,[r1,#0]
;;;906    
;;;907      /* Set Initialization mode */
;;;908      if (RTC_EnterInitMode() == ERROR)
00007e  f7fffffe          BL       RTC_EnterInitMode
000082  b908              CBNZ     r0,|L30.136|
;;;909      {
;;;910        status = ERROR;
000084  2700              MOVS     r7,#0
000086  e00c              B        |L30.162|
                  |L30.136|
;;;911      } 
;;;912      else
;;;913      {
;;;914        /* Set the RTC_DR register */
;;;915        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
000088  480a              LDR      r0,|L30.180|
00008a  4030              ANDS     r0,r0,r6
00008c  4908              LDR      r1,|L30.176|
00008e  3920              SUBS     r1,r1,#0x20
000090  6008              STR      r0,[r1,#0]
;;;916    
;;;917        /* Exit Initialization mode */
;;;918        RTC_ExitInitMode(); 
000092  f7fffffe          BL       RTC_ExitInitMode
;;;919    
;;;920        if(RTC_WaitForSynchro() == ERROR)
000096  f7fffffe          BL       RTC_WaitForSynchro
00009a  b908              CBNZ     r0,|L30.160|
;;;921        {
;;;922          status = ERROR;
00009c  2700              MOVS     r7,#0
00009e  e000              B        |L30.162|
                  |L30.160|
;;;923        }
;;;924        else
;;;925        {
;;;926          status = SUCCESS;
0000a0  2701              MOVS     r7,#1
                  |L30.162|
;;;927        }
;;;928      }
;;;929      /* Enable the write protection for RTC registers */
;;;930      RTC->WPR = 0xFF;   
0000a2  20ff              MOVS     r0,#0xff
0000a4  4902              LDR      r1,|L30.176|
0000a6  6008              STR      r0,[r1,#0]
;;;931      
;;;932      return status;
0000a8  4638              MOV      r0,r7
;;;933    }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;934    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L30.176|
                          DCD      0x40002824
                  |L30.180|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;705      */
;;;706    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;707    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;708      uint32_t tmpreg = 0;
000008  2600              MOVS     r6,#0
;;;709      ErrorStatus status = ERROR;
00000a  2700              MOVS     r7,#0
;;;710        
;;;711      /* Check the parameters */
;;;712      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;713      
;;;714      if (RTC_Format == RTC_Format_BIN)
00000c  b94d              CBNZ     r5,|L31.34|
;;;715      {
;;;716        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000e  482a              LDR      r0,|L31.184|
000010  6800              LDR      r0,[r0,#0]
000012  f0000040          AND      r0,r0,#0x40
000016  b100              CBZ      r0,|L31.26|
;;;717        {
;;;718          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;719          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
000018  e002              B        |L31.32|
                  |L31.26|
;;;720        } 
;;;721        else
;;;722        {
;;;723          RTC_TimeStruct->RTC_H12 = 0x00;
00001a  2000              MOVS     r0,#0
00001c  70e0              STRB     r0,[r4,#3]
;;;724          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
00001e  bf00              NOP      
                  |L31.32|
;;;725        }
;;;726        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;727        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
000020  e00d              B        |L31.62|
                  |L31.34|
;;;728      }
;;;729      else
;;;730      {
;;;731        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000022  4825              LDR      r0,|L31.184|
000024  6800              LDR      r0,[r0,#0]
000026  f0000040          AND      r0,r0,#0x40
00002a  b120              CBZ      r0,|L31.54|
;;;732        {
;;;733          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002c  7820              LDRB     r0,[r4,#0]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  4606              MOV      r6,r0
;;;734          assert_param(IS_RTC_HOUR12(tmpreg));
;;;735          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
000034  e002              B        |L31.60|
                  |L31.54|
;;;736        } 
;;;737        else
;;;738        {
;;;739          RTC_TimeStruct->RTC_H12 = 0x00;
000036  2000              MOVS     r0,#0
000038  70e0              STRB     r0,[r4,#3]
;;;740          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
00003a  bf00              NOP      
                  |L31.60|
;;;741        }
;;;742        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;743        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
00003c  bf00              NOP      
                  |L31.62|
;;;744      }
;;;745      
;;;746      /* Check the input parameters format */
;;;747      if (RTC_Format != RTC_Format_BIN)
00003e  b155              CBZ      r5,|L31.86|
;;;748      {
;;;749        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
000040  7820              LDRB     r0,[r4,#0]
000042  0400              LSLS     r0,r0,#16
000044  7861              LDRB     r1,[r4,#1]
000046  ea402001          ORR      r0,r0,r1,LSL #8
00004a  78a1              LDRB     r1,[r4,#2]
00004c  4308              ORRS     r0,r0,r1
00004e  78e1              LDRB     r1,[r4,#3]
000050  ea404601          ORR      r6,r0,r1,LSL #16
000054  e011              B        |L31.122|
                  |L31.86|
;;;750                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;751                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;752                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;753      }  
;;;754      else
;;;755      {
;;;756        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
000056  7820              LDRB     r0,[r4,#0]
000058  f7fffffe          BL       RTC_ByteToBcd2
00005c  ea4f4800          LSL      r8,r0,#16
000060  7860              LDRB     r0,[r4,#1]
000062  f7fffffe          BL       RTC_ByteToBcd2
000066  ea482800          ORR      r8,r8,r0,LSL #8
00006a  78a0              LDRB     r0,[r4,#2]
00006c  f7fffffe          BL       RTC_ByteToBcd2
000070  ea480800          ORR      r8,r8,r0
000074  78e0              LDRB     r0,[r4,#3]
000076  ea484600          ORR      r6,r8,r0,LSL #16
                  |L31.122|
;;;757                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;758                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;759                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;760      }  
;;;761    
;;;762      /* Disable the write protection for RTC registers */
;;;763      RTC->WPR = 0xCA;
00007a  20ca              MOVS     r0,#0xca
00007c  490e              LDR      r1,|L31.184|
00007e  311c              ADDS     r1,r1,#0x1c
000080  6008              STR      r0,[r1,#0]
;;;764      RTC->WPR = 0x53;
000082  2053              MOVS     r0,#0x53
000084  6008              STR      r0,[r1,#0]
;;;765    
;;;766      /* Set Initialization mode */
;;;767      if (RTC_EnterInitMode() == ERROR)
000086  f7fffffe          BL       RTC_EnterInitMode
00008a  b908              CBNZ     r0,|L31.144|
;;;768      {
;;;769        status = ERROR;
00008c  2700              MOVS     r7,#0
00008e  e00c              B        |L31.170|
                  |L31.144|
;;;770      } 
;;;771      else
;;;772      {
;;;773        /* Set the RTC_TR register */
;;;774        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000090  480a              LDR      r0,|L31.188|
000092  4030              ANDS     r0,r0,r6
000094  4908              LDR      r1,|L31.184|
000096  3908              SUBS     r1,r1,#8
000098  6008              STR      r0,[r1,#0]
;;;775    
;;;776        /* Exit Initialization mode */
;;;777        RTC_ExitInitMode(); 
00009a  f7fffffe          BL       RTC_ExitInitMode
;;;778    
;;;779        if(RTC_WaitForSynchro() == ERROR)
00009e  f7fffffe          BL       RTC_WaitForSynchro
0000a2  b908              CBNZ     r0,|L31.168|
;;;780        {
;;;781          status = ERROR;
0000a4  2700              MOVS     r7,#0
0000a6  e000              B        |L31.170|
                  |L31.168|
;;;782        }
;;;783        else
;;;784        {
;;;785          status = SUCCESS;
0000a8  2701              MOVS     r7,#1
                  |L31.170|
;;;786        }
;;;787      
;;;788      }
;;;789      /* Enable the write protection for RTC registers */
;;;790      RTC->WPR = 0xFF; 
0000aa  20ff              MOVS     r0,#0xff
0000ac  4902              LDR      r1,|L31.184|
0000ae  311c              ADDS     r1,r1,#0x1c
0000b0  6008              STR      r0,[r1,#0]
;;;791        
;;;792      return status;
0000b2  4638              MOV      r0,r7
;;;793    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
;;;794    
                          ENDP

                  |L31.184|
                          DCD      0x40002808
                  |L31.188|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1323     */
;;;1324   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  21ca              MOVS     r1,#0xca
;;;1325   {
;;;1326     /* Check the parameters */
;;;1327     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1328     
;;;1329     /* Disable the write protection for RTC registers */
;;;1330     RTC->WPR = 0xCA;
000002  4a05              LDR      r2,|L32.24|
000004  6011              STR      r1,[r2,#0]
;;;1331     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1332     
;;;1333     /* Configure the Wakeup Timer counter */
;;;1334     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4903              LDR      r1,|L32.24|
00000c  3910              SUBS     r1,r1,#0x10
00000e  6008              STR      r0,[r1,#0]
;;;1335     
;;;1336     /* Enable the write protection for RTC registers */
;;;1337     RTC->WPR = 0xFF; 
000010  21ff              MOVS     r1,#0xff
000012  6011              STR      r1,[r2,#0]
;;;1338   }
000014  4770              BX       lr
;;;1339   
                          ENDP

000016  0000              DCW      0x0000
                  |L32.24|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;475      */
;;;476    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;477    {
;;;478      /* Initialize the RTC_HourFormat member */
;;;479      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
000002  6001              STR      r1,[r0,#0]
;;;480        
;;;481      /* Initialize the RTC_AsynchPrediv member */
;;;482      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000004  217f              MOVS     r1,#0x7f
000006  6041              STR      r1,[r0,#4]
;;;483    
;;;484      /* Initialize the RTC_SynchPrediv member */
;;;485      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;486    }
00000c  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;1831     */
;;;1832   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  b129              CBZ      r1,|L34.14|
;;;1833   {
;;;1834     /* Check the parameters */
;;;1835     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;1836     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1837     
;;;1838     if (NewState != DISABLE)
;;;1839     {
;;;1840       /* Enable the selected Tamper pin */
;;;1841       RTC->TAFCR |= (uint32_t)RTC_Tamper;
000002  4a06              LDR      r2,|L34.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L34.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L34.24|
                  |L34.14|
;;;1842     }
;;;1843     else
;;;1844     {
;;;1845       /* Disable the selected Tamper pin */
;;;1846       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
00000e  4a03              LDR      r2,|L34.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L34.28|
000016  601a              STR      r2,[r3,#0]
                  |L34.24|
;;;1847     }  
;;;1848   }
000018  4770              BX       lr
;;;1849   
                          ENDP

00001a  0000              DCW      0x0000
                  |L34.28|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinSelection PROC
;;;1934     */
;;;1935   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000000  4905              LDR      r1,|L35.24|
;;;1936   {
;;;1937     /* Check the parameters */
;;;1938     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;1939     
;;;1940     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000002  6809              LDR      r1,[r1,#0]
000004  f4213180          BIC      r1,r1,#0x10000
000008  4a03              LDR      r2,|L35.24|
00000a  6011              STR      r1,[r2,#0]
;;;1941     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;1942   }
000014  4770              BX       lr
;;;1943   
                          ENDP

000016  0000              DCW      0x0000
                  |L35.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;1805     */
;;;1806   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  b931              CBNZ     r1,|L36.16|
;;;1807   {
;;;1808     /* Check the parameters */
;;;1809     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;1810     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;1811    
;;;1812     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
;;;1813     {  
;;;1814       /* Configure the RTC_TAFCR register */
;;;1815       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000002  4a07              LDR      r2,|L36.32|
000004  6812              LDR      r2,[r2,#0]
000006  ea220240          BIC      r2,r2,r0,LSL #1
00000a  4b05              LDR      r3,|L36.32|
00000c  601a              STR      r2,[r3,#0]
00000e  e005              B        |L36.28|
                  |L36.16|
;;;1816     }
;;;1817     else
;;;1818     { 
;;;1819       /* Configure the RTC_TAFCR register */
;;;1820       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000010  4a03              LDR      r2,|L36.32|
000012  6812              LDR      r2,[r2,#0]
000014  ea420240          ORR      r2,r2,r0,LSL #1
000018  4b01              LDR      r3,|L36.32|
00001a  601a              STR      r2,[r3,#0]
                  |L36.28|
;;;1821     }  
;;;1822   }
00001c  4770              BX       lr
;;;1823   
                          ENDP

00001e  0000              DCW      0x0000
                  |L36.32|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1695     */
;;;1696   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1697   {
000002  460a              MOV      r2,r1
;;;1698     uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;1699   
;;;1700     /* Check the parameters */
;;;1701     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1702     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1703   
;;;1704     /* Get the RTC_CR register and clear the bits to be configured */
;;;1705     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000006  4b0b              LDR      r3,|L37.52|
000008  681b              LDR      r3,[r3,#0]
00000a  f6400408          MOV      r4,#0x808
00000e  ea230104          BIC      r1,r3,r4
;;;1706   
;;;1707     /* Get the new configuration */
;;;1708     if (NewState != DISABLE)
000012  b11a              CBZ      r2,|L37.28|
;;;1709     {
;;;1710       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
000014  f4406300          ORR      r3,r0,#0x800
000018  4319              ORRS     r1,r1,r3
00001a  e000              B        |L37.30|
                  |L37.28|
;;;1711     }
;;;1712     else
;;;1713     {
;;;1714       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00001c  4301              ORRS     r1,r1,r0
                  |L37.30|
;;;1715     }
;;;1716   
;;;1717     /* Disable the write protection for RTC registers */
;;;1718     RTC->WPR = 0xCA;
00001e  23ca              MOVS     r3,#0xca
000020  4c04              LDR      r4,|L37.52|
000022  341c              ADDS     r4,r4,#0x1c
000024  6023              STR      r3,[r4,#0]
;;;1719     RTC->WPR = 0x53;
000026  2353              MOVS     r3,#0x53
000028  6023              STR      r3,[r4,#0]
;;;1720   
;;;1721     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1722     RTC->CR = (uint32_t)tmpreg;
00002a  4b02              LDR      r3,|L37.52|
00002c  6019              STR      r1,[r3,#0]
;;;1723   
;;;1724     /* Enable the write protection for RTC registers */
;;;1725     RTC->WPR = 0xFF; 
00002e  23ff              MOVS     r3,#0xff
000030  6023              STR      r3,[r4,#0]
;;;1726   }
000032  bd10              POP      {r4,pc}
;;;1727   
                          ENDP

                  |L37.52|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampPinSelection PROC
;;;1951     */
;;;1952   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000000  4905              LDR      r1,|L38.24|
;;;1953   {
;;;1954     /* Check the parameters */
;;;1955     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;1956     
;;;1957     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000002  6809              LDR      r1,[r1,#0]
000004  f4213100          BIC      r1,r1,#0x20000
000008  4a03              LDR      r2,|L38.24|
00000a  6011              STR      r1,[r2,#0]
;;;1958     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;1959   }
000014  4770              BX       lr
;;;1960   
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;801      */
;;;802    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;803    {
;;;804      /* Time = 00h:00min:00sec */
;;;805      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;806      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;807      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;808      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;809    }
00000a  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;591      */
;;;592    ErrorStatus RTC_WaitForSynchro(void)
000000  b508              PUSH     {r3,lr}
;;;593    {
;;;594      __IO uint32_t synchrocounter = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;595      ErrorStatus status = ERROR;
000006  2000              MOVS     r0,#0
;;;596      uint32_t synchrostatus = 0x00;
000008  2100              MOVS     r1,#0
;;;597    
;;;598      /* Disable the write protection for RTC registers */
;;;599      RTC->WPR = 0xCA;
00000a  22ca              MOVS     r2,#0xca
00000c  4b13              LDR      r3,|L40.92|
00000e  601a              STR      r2,[r3,#0]
;;;600      RTC->WPR = 0x53;
000010  2253              MOVS     r2,#0x53
000012  601a              STR      r2,[r3,#0]
;;;601        
;;;602      /* Clear RSF flag */
;;;603      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000014  4a11              LDR      r2,|L40.92|
000016  3a18              SUBS     r2,r2,#0x18
000018  6812              LDR      r2,[r2,#0]
00001a  f02202a0          BIC      r2,r2,#0xa0
00001e  4b0f              LDR      r3,|L40.92|
000020  3b18              SUBS     r3,r3,#0x18
000022  601a              STR      r2,[r3,#0]
;;;604        
;;;605      /* Wait the registers to be synchronised */
;;;606      do
000024  bf00              NOP      
                  |L40.38|
;;;607      {
;;;608        synchrostatus = RTC->ISR & RTC_ISR_RSF;
000026  4a0d              LDR      r2,|L40.92|
000028  3a18              SUBS     r2,r2,#0x18
00002a  6812              LDR      r2,[r2,#0]
00002c  f0020120          AND      r1,r2,#0x20
;;;609        synchrocounter++;  
000030  9a00              LDR      r2,[sp,#0]
000032  1c52              ADDS     r2,r2,#1
000034  9200              STR      r2,[sp,#0]
;;;610      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
000036  9a00              LDR      r2,[sp,#0]
000038  f5b24f00          CMP      r2,#0x8000
00003c  d001              BEQ      |L40.66|
00003e  2900              CMP      r1,#0
000040  d0f1              BEQ      |L40.38|
                  |L40.66|
;;;611        
;;;612      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000042  4a06              LDR      r2,|L40.92|
000044  3a18              SUBS     r2,r2,#0x18
000046  6812              LDR      r2,[r2,#0]
000048  f0020220          AND      r2,r2,#0x20
00004c  b10a              CBZ      r2,|L40.82|
;;;613      {
;;;614        status = SUCCESS;
00004e  2001              MOVS     r0,#1
000050  e000              B        |L40.84|
                  |L40.82|
;;;615      }
;;;616      else
;;;617      {
;;;618        status = ERROR;
000052  2000              MOVS     r0,#0
                  |L40.84|
;;;619      }        
;;;620    
;;;621      /* Enable the write protection for RTC registers */
;;;622      RTC->WPR = 0xFF; 
000054  22ff              MOVS     r2,#0xff
000056  4b01              LDR      r3,|L40.92|
000058  601a              STR      r2,[r3,#0]
;;;623        
;;;624      return (status); 
;;;625    }
00005a  bd08              POP      {r3,pc}
;;;626    
                          ENDP

                  |L40.92|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1296     */
;;;1297   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  21ca              MOVS     r1,#0xca
;;;1298   {
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1301   
;;;1302     /* Disable the write protection for RTC registers */
;;;1303     RTC->WPR = 0xCA;
000002  4a0a              LDR      r2,|L41.44|
000004  6011              STR      r1,[r2,#0]
;;;1304     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1305   
;;;1306     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1307     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4908              LDR      r1,|L41.44|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  6809              LDR      r1,[r1,#0]
000010  f0210107          BIC      r1,r1,#7
000014  4a05              LDR      r2,|L41.44|
000016  3a1c              SUBS     r2,r2,#0x1c
000018  6011              STR      r1,[r2,#0]
;;;1308   
;;;1309     /* Configure the clock source */
;;;1310     RTC->CR |= (uint32_t)RTC_WakeUpClock;
00001a  4611              MOV      r1,r2
00001c  6809              LDR      r1,[r1,#0]
00001e  4301              ORRS     r1,r1,r0
000020  6011              STR      r1,[r2,#0]
;;;1311     
;;;1312     /* Enable the write protection for RTC registers */
;;;1313     RTC->WPR = 0xFF; 
000022  21ff              MOVS     r1,#0xff
000024  4a01              LDR      r2,|L41.44|
000026  6011              STR      r1,[r2,#0]
;;;1314   }
000028  4770              BX       lr
;;;1315   
                          ENDP

00002a  0000              DCW      0x0000
                  |L41.44|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1356     */
;;;1357   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;1358   {
000002  4601              MOV      r1,r0
;;;1359     __IO uint32_t wutcounter = 0x00;
000004  2300              MOVS     r3,#0
000006  9300              STR      r3,[sp,#0]
;;;1360     uint32_t wutwfstatus = 0x00;
000008  2200              MOVS     r2,#0
;;;1361     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1362     
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1365   
;;;1366     /* Disable the write protection for RTC registers */
;;;1367     RTC->WPR = 0xCA;
00000c  23ca              MOVS     r3,#0xca
00000e  4c19              LDR      r4,|L42.116|
000010  6023              STR      r3,[r4,#0]
;;;1368     RTC->WPR = 0x53;
000012  2353              MOVS     r3,#0x53
000014  6023              STR      r3,[r4,#0]
;;;1369   
;;;1370     if (NewState != DISABLE)
000016  b149              CBZ      r1,|L42.44|
;;;1371     {
;;;1372       /* Enable the Wakeup Timer */
;;;1373       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000018  4b16              LDR      r3,|L42.116|
00001a  3b1c              SUBS     r3,r3,#0x1c
00001c  681b              LDR      r3,[r3,#0]
00001e  f4436380          ORR      r3,r3,#0x400
000022  4c14              LDR      r4,|L42.116|
000024  3c1c              SUBS     r4,r4,#0x1c
000026  6023              STR      r3,[r4,#0]
;;;1374       status = SUCCESS;    
000028  2001              MOVS     r0,#1
00002a  e01f              B        |L42.108|
                  |L42.44|
;;;1375     }
;;;1376     else
;;;1377     {
;;;1378       /* Disable the Wakeup Timer */
;;;1379       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
00002c  4b11              LDR      r3,|L42.116|
00002e  3b1c              SUBS     r3,r3,#0x1c
000030  681b              LDR      r3,[r3,#0]
000032  f4236380          BIC      r3,r3,#0x400
000036  4c0f              LDR      r4,|L42.116|
000038  3c1c              SUBS     r4,r4,#0x1c
00003a  6023              STR      r3,[r4,#0]
;;;1380       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1381       do
00003c  bf00              NOP      
                  |L42.62|
;;;1382       {
;;;1383         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
00003e  4b0d              LDR      r3,|L42.116|
000040  3b18              SUBS     r3,r3,#0x18
000042  681b              LDR      r3,[r3,#0]
000044  f0030204          AND      r2,r3,#4
;;;1384         wutcounter++;  
000048  9b00              LDR      r3,[sp,#0]
00004a  1c5b              ADDS     r3,r3,#1
00004c  9300              STR      r3,[sp,#0]
;;;1385       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00004e  9b00              LDR      r3,[sp,#0]
000050  f5b33f80          CMP      r3,#0x10000
000054  d001              BEQ      |L42.90|
000056  2a00              CMP      r2,#0
000058  d0f1              BEQ      |L42.62|
                  |L42.90|
;;;1386       
;;;1387       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00005a  4b06              LDR      r3,|L42.116|
00005c  3b18              SUBS     r3,r3,#0x18
00005e  681b              LDR      r3,[r3,#0]
000060  f0030304          AND      r3,r3,#4
000064  b90b              CBNZ     r3,|L42.106|
;;;1388       {
;;;1389         status = ERROR;
000066  2000              MOVS     r0,#0
000068  e000              B        |L42.108|
                  |L42.106|
;;;1390       }
;;;1391       else
;;;1392       {
;;;1393         status = SUCCESS;
00006a  2001              MOVS     r0,#1
                  |L42.108|
;;;1394       }    
;;;1395     }
;;;1396   
;;;1397     /* Enable the write protection for RTC registers */
;;;1398     RTC->WPR = 0xFF; 
00006c  23ff              MOVS     r3,#0xff
00006e  4c01              LDR      r4,|L42.116|
000070  6023              STR      r3,[r4,#0]
;;;1399     
;;;1400     return status;
;;;1401   }
000072  bd18              POP      {r3,r4,pc}
;;;1402   
                          ENDP

                  |L42.116|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;1873     */
;;;1874   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;1875   {
;;;1876     __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;1877     
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;1880   
;;;1881     tmp = RTC_BASE + 0x50;
000006  4a04              LDR      r2,|L43.24|
000008  9200              STR      r2,[sp,#0]
;;;1882     tmp += (RTC_BKP_DR * 4);
00000a  9a00              LDR      r2,[sp,#0]
00000c  eb020280          ADD      r2,r2,r0,LSL #2
000010  9200              STR      r2,[sp,#0]
;;;1883   
;;;1884     /* Write the specified register */
;;;1885     *(__IO uint32_t *)tmp = (uint32_t)Data;
000012  9a00              LDR      r2,[sp,#0]
000014  6011              STR      r1,[r2,#0]
;;;1886   }
000016  bd08              POP      {r3,pc}
;;;1887   
                          ENDP

                  |L43.24|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;497      */
;;;498    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  b118              CBZ      r0,|L44.10|
;;;499    {
;;;500      /* Check the parameters */
;;;501      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;502        
;;;503      if (NewState != DISABLE)
;;;504      {
;;;505        /* Enable the write protection for RTC registers */
;;;506        RTC->WPR = 0xFF;   
000002  21ff              MOVS     r1,#0xff
000004  4a04              LDR      r2,|L44.24|
000006  6011              STR      r1,[r2,#0]
000008  e004              B        |L44.20|
                  |L44.10|
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Disable the write protection for RTC registers */
;;;511        RTC->WPR = 0xCA;
00000a  21ca              MOVS     r1,#0xca
00000c  4a02              LDR      r2,|L44.24|
00000e  6011              STR      r1,[r2,#0]
;;;512        RTC->WPR = 0x53;    
000010  2153              MOVS     r1,#0x53
000012  6011              STR      r1,[r2,#0]
                  |L44.20|
;;;513      }
;;;514    }
000014  4770              BX       lr
;;;515    
                          ENDP

000016  0000              DCW      0x0000
                  |L44.24|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_rtc_c_81435638____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f2xx_rtc_c_81435638____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_rtc_c_81435638____REVSH|
#line 402
|__asm___15_stm32f2xx_rtc_c_81435638____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_rtc_c_81435638____RRX|
#line 587
|__asm___15_stm32f2xx_rtc_c_81435638____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
