; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\diskio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\User\bsp -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\FatFS\src -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\diskio.crf ..\FatFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;59     
;;;60     DSTATUS disk_initialize (
000000  4601              MOV      r1,r0
;;;61     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;62     )
;;;63     {
;;;64     	DSTATUS stat;
;;;65     	//int result;
;;;66     
;;;67     	switch (pdrv) {
000002  b121              CBZ      r1,|L1.14|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L1.18|
000008  2902              CMP      r1,#2
00000a  d106              BNE      |L1.26|
00000c  e003              B        |L1.22|
                  |L1.14|
;;;68     	case DEV_RAM :
;;;69     		//result = RAM_disk_initialize();
;;;70     
;;;71     		// translate the reslut code here
;;;72     
;;;73     		return stat;
00000e  4610              MOV      r0,r2
                  |L1.16|
;;;74     
;;;75     	case DEV_MMC :
;;;76     		//result = MMC_disk_initialize();
;;;77     
;;;78     		// translate the reslut code here
;;;79     
;;;80     		return stat;
;;;81     
;;;82     	case DEV_USB :
;;;83     		//result = USB_disk_initialize();
;;;84     
;;;85     		// translate the reslut code here
;;;86     
;;;87     		return stat;
;;;88     	}
;;;89     	return STA_NOINIT;
;;;90     }
000010  4770              BX       lr
                  |L1.18|
000012  4610              MOV      r0,r2                 ;80
000014  e7fc              B        |L1.16|
                  |L1.22|
000016  4610              MOV      r0,r2                 ;87
000018  e7fa              B        |L1.16|
                  |L1.26|
00001a  2001              MOVS     r0,#1                 ;89
00001c  e7f8              B        |L1.16|
;;;91     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;193    
;;;194    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;195    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;196    	BYTE cmd,		/* Control code */
;;;197    	void *buff		/* Buffer to send/receive control data */
;;;198    )
;;;199    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;200    	DRESULT res;
;;;201    	//int result;
;;;202    
;;;203    	switch (pdrv) {
000006  b123              CBZ      r3,|L2.18|
000008  2b01              CMP      r3,#1
00000a  d004              BEQ      |L2.22|
00000c  2b02              CMP      r3,#2
00000e  d106              BNE      |L2.30|
000010  e003              B        |L2.26|
                  |L2.18|
;;;204    	case DEV_RAM :
;;;205    
;;;206    		// Process of the command for the RAM drive
;;;207    
;;;208    		return res;
000012  4608              MOV      r0,r1
                  |L2.20|
;;;209    
;;;210    	case DEV_MMC :
;;;211    
;;;212    		// Process of the command for the MMC/SD card
;;;213    
;;;214    		return res;
;;;215    
;;;216    	case DEV_USB :
;;;217    
;;;218    		// Process of the command the USB drive
;;;219    
;;;220    		return res;
;;;221    	}
;;;222    
;;;223    	return RES_PARERR;
;;;224    }
000014  bd10              POP      {r4,pc}
                  |L2.22|
000016  4608              MOV      r0,r1                 ;214
000018  e7fc              B        |L2.20|
                  |L2.26|
00001a  4608              MOV      r0,r1                 ;220
00001c  e7fa              B        |L2.20|
                  |L2.30|
00001e  2004              MOVS     r0,#4                 ;223
000020  e7f8              B        |L2.20|
;;;225    
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;97     
;;;98     DRESULT disk_read (
000000  b530              PUSH     {r4,r5,lr}
;;;99     	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;100    	BYTE *buff,		/* Data buffer to store read data */
;;;101    	DWORD sector,	/* Start sector in LBA */
;;;102    	UINT count		/* Number of sectors to read */
;;;103    )
;;;104    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;105    	DRESULT res;
;;;106    	//int result;
;;;107    
;;;108    	switch (pdrv) {
000006  b124              CBZ      r4,|L3.18|
000008  2c01              CMP      r4,#1
00000a  d004              BEQ      |L3.22|
00000c  2c02              CMP      r4,#2
00000e  d106              BNE      |L3.30|
000010  e003              B        |L3.26|
                  |L3.18|
;;;109    	case DEV_RAM :
;;;110    		// translate the arguments here
;;;111    
;;;112    		//result = RAM_disk_read(buff, sector, count);
;;;113    
;;;114    		// translate the reslut code here
;;;115    
;;;116    		return res;
000012  4608              MOV      r0,r1
                  |L3.20|
;;;117    
;;;118    	case DEV_MMC :
;;;119    		// translate the arguments here
;;;120    
;;;121    		//result = MMC_disk_read(buff, sector, count);
;;;122    
;;;123    		// translate the reslut code here
;;;124    
;;;125    		return res;
;;;126    
;;;127    	case DEV_USB :
;;;128    		// translate the arguments here
;;;129    
;;;130    		//result = USB_disk_read(buff, sector, count);
;;;131    
;;;132    		// translate the reslut code here
;;;133    
;;;134    		return res;
;;;135    	}
;;;136    
;;;137    	return RES_PARERR;
;;;138    }
000014  bd30              POP      {r4,r5,pc}
                  |L3.22|
000016  4608              MOV      r0,r1                 ;125
000018  e7fc              B        |L3.20|
                  |L3.26|
00001a  4608              MOV      r0,r1                 ;134
00001c  e7fa              B        |L3.20|
                  |L3.30|
00001e  2004              MOVS     r0,#4                 ;137
000020  e7f8              B        |L3.20|
;;;139    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;21     
;;;22     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;23     	BYTE pdrv		/* Physical drive nmuber to identify the drive */
;;;24     )
;;;25     {
;;;26     	DSTATUS stat;
;;;27     	//int result;
;;;28     
;;;29     	switch (pdrv) {
000002  b121              CBZ      r1,|L4.14|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L4.18|
000008  2902              CMP      r1,#2
00000a  d106              BNE      |L4.26|
00000c  e003              B        |L4.22|
                  |L4.14|
;;;30     	case DEV_RAM :
;;;31     		//result = RAM_disk_status();
;;;32     
;;;33     		// translate the reslut code here
;;;34     
;;;35     		return stat;
00000e  4610              MOV      r0,r2
                  |L4.16|
;;;36     
;;;37     	case DEV_MMC :
;;;38     		//result = MMC_disk_status();
;;;39     
;;;40     		// translate the reslut code here
;;;41     
;;;42     		return stat;
;;;43     
;;;44     	case DEV_USB :
;;;45     		//result = USB_disk_status();
;;;46     
;;;47     		// translate the reslut code here
;;;48     
;;;49     		return stat;
;;;50     	}
;;;51     	return STA_NOINIT;
;;;52     }
000010  4770              BX       lr
                  |L4.18|
000012  4610              MOV      r0,r2                 ;42
000014  e7fc              B        |L4.16|
                  |L4.22|
000016  4610              MOV      r0,r2                 ;49
000018  e7fa              B        |L4.16|
                  |L4.26|
00001a  2001              MOVS     r0,#1                 ;51
00001c  e7f8              B        |L4.16|
;;;53     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;145    
;;;146    DRESULT disk_write (
000000  b530              PUSH     {r4,r5,lr}
;;;147    	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
;;;148    	const BYTE *buff,	/* Data to be written */
;;;149    	DWORD sector,		/* Start sector in LBA */
;;;150    	UINT count			/* Number of sectors to write */
;;;151    )
;;;152    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;153    	DRESULT res;
;;;154    	//int result;
;;;155    
;;;156    	switch (pdrv) {
000006  b124              CBZ      r4,|L5.18|
000008  2c01              CMP      r4,#1
00000a  d004              BEQ      |L5.22|
00000c  2c02              CMP      r4,#2
00000e  d106              BNE      |L5.30|
000010  e003              B        |L5.26|
                  |L5.18|
;;;157    	case DEV_RAM :
;;;158    		// translate the arguments here
;;;159    
;;;160    		//result = RAM_disk_write(buff, sector, count);
;;;161    
;;;162    		// translate the reslut code here
;;;163    
;;;164    		return res;
000012  4608              MOV      r0,r1
                  |L5.20|
;;;165    
;;;166    	case DEV_MMC :
;;;167    		// translate the arguments here
;;;168    
;;;169    		//result = MMC_disk_write(buff, sector, count);
;;;170    
;;;171    		// translate the reslut code here
;;;172    
;;;173    		return res;
;;;174    
;;;175    	case DEV_USB :
;;;176    		// translate the arguments here
;;;177    
;;;178    		//result = USB_disk_write(buff, sector, count);
;;;179    
;;;180    		// translate the reslut code here
;;;181    
;;;182    		return res;
;;;183    	}
;;;184    
;;;185    	return RES_PARERR;
;;;186    }
000014  bd30              POP      {r4,r5,pc}
                  |L5.22|
000016  4608              MOV      r0,r1                 ;173
000018  e7fc              B        |L5.20|
                  |L5.26|
00001a  4608              MOV      r0,r1                 ;182
00001c  e7fa              B        |L5.20|
                  |L5.30|
00001e  2004              MOVS     r0,#4                 ;185
000020  e7f8              B        |L5.20|
;;;187    
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;234    */
;;;235    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;236    {
;;;237    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2014-07-02 00:00:00 */
;;;238    #if 0
;;;239    	RTC_ReadClock();
;;;240    	return  ((DWORD)(g_tRTC.Year - 1980) << 25)		/* Year  */
;;;241    			| ((DWORD)g_tRTC.Mon << 21)				/* Month   */
;;;242    			| ((DWORD)g_tRTC.Day << 16)				/* Day_m  1*/
;;;243    			| ((DWORD)g_tRTC.Hour << 11)			/* Hour  */
;;;244    			| ((DWORD)g_tRTC.Min << 5)				/* Min  */
;;;245    			| ((DWORD)g_tRTC.Sec >> 1);				/* Sec  */
;;;246    	
;;;247    #else
;;;248    	return	  ((DWORD)(2014 - 1980) << 25)	/* Year = 2014 */
;;;249    			| ((DWORD)7 << 21)				/* Month = 7 */
;;;250    			| ((DWORD)2 << 16)				/* Day_m = 2*/
;;;251    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;252    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;253    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;254    #endif	
;;;255    }
000002  4770              BX       lr
;;;256    
                          ENDP

                  |L6.4|
                          DCD      0x44e20000
