; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_hash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_hash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_hash.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_hash.c]
                          THUMB

                          AREA ||i.HASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  HASH_ClearFlag PROC
;;;630      */
;;;631    void HASH_ClearFlag(uint16_t HASH_FLAG)
000000  43c1              MVNS     r1,r0
;;;632    {
;;;633      /* Check the parameters */
;;;634      assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
;;;635      
;;;636      /* Clear the selected HASH flags */
;;;637      HASH->SR = ~(uint32_t)HASH_FLAG;
000002  4a01              LDR      r2,|L1.8|
000004  6011              STR      r1,[r2,#0]
;;;638    }
000006  4770              BX       lr
;;;639    /**
                          ENDP

                  |L1.8|
                          DCD      0x50060424

                          AREA ||i.HASH_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  HASH_ClearITPendingBit PROC
;;;680      */
;;;681    void HASH_ClearITPendingBit(uint8_t HASH_IT)
000000  43c1              MVNS     r1,r0
;;;682    {
;;;683      /* Check the parameters */
;;;684      assert_param(IS_HASH_IT(HASH_IT));
;;;685    
;;;686      /* Clear the selected HASH interrupt pending bit */
;;;687      HASH->SR = (uint8_t)~HASH_IT;
000002  b2c9              UXTB     r1,r1
000004  4a01              LDR      r2,|L2.12|
000006  6011              STR      r1,[r2,#0]
;;;688    }
000008  4770              BX       lr
;;;689    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x50060424

                          AREA ||i.HASH_DMACmd||, CODE, READONLY, ALIGN=2

                  HASH_DMACmd PROC
;;;465      */
;;;466    void HASH_DMACmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L3.16|
;;;467    {
;;;468      /* Check the parameters */
;;;469      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;470    
;;;471      if (NewState != DISABLE)
;;;472      {
;;;473        /* Enable the HASH DMA request */
;;;474        HASH->CR |= HASH_CR_DMAE;
000002  4907              LDR      r1,|L3.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410108          ORR      r1,r1,#8
00000a  4a05              LDR      r2,|L3.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L3.28|
                  |L3.16|
;;;475      }
;;;476      else
;;;477      {
;;;478        /* Disable the HASH DMA request */
;;;479        HASH->CR &= ~HASH_CR_DMAE;
000010  4903              LDR      r1,|L3.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210108          BIC      r1,r1,#8
000018  4a01              LDR      r2,|L3.32|
00001a  6011              STR      r1,[r2,#0]
                  |L3.28|
;;;480      }
;;;481    }
00001c  4770              BX       lr
;;;482    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x50060400

                          AREA ||i.HASH_DataIn||, CODE, READONLY, ALIGN=2

                  HASH_DataIn PROC
;;;311      */
;;;312    void HASH_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L4.8|
;;;313    {
;;;314      /* Write in the DIN register a new data */
;;;315      HASH->DIN = Data;
000002  6008              STR      r0,[r1,#0]
;;;316    }
000004  4770              BX       lr
;;;317    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060404

                          AREA ||i.HASH_DeInit||, CODE, READONLY, ALIGN=1

                  HASH_DeInit PROC
;;;176      */
;;;177    void HASH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179      /* Enable HASH reset state */
;;;180      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;181      /* Release HASH from reset state */
;;;182      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;183    }
000012  bd10              POP      {r4,pc}
;;;184    
                          ENDP


                          AREA ||i.HASH_GetDigest||, CODE, READONLY, ALIGN=2

                  HASH_GetDigest PROC
;;;336      */
;;;337    void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
000000  4909              LDR      r1,|L6.40|
;;;338    {
;;;339      /* Get the data field */
;;;340      HASH_MessageDigest->Data[0] = HASH->HR[0];
000002  6809              LDR      r1,[r1,#0]
000004  6001              STR      r1,[r0,#0]
;;;341      HASH_MessageDigest->Data[1] = HASH->HR[1];
000006  4908              LDR      r1,|L6.40|
000008  390c              SUBS     r1,r1,#0xc
00000a  6909              LDR      r1,[r1,#0x10]
00000c  6041              STR      r1,[r0,#4]
;;;342      HASH_MessageDigest->Data[2] = HASH->HR[2];
00000e  4906              LDR      r1,|L6.40|
000010  390c              SUBS     r1,r1,#0xc
000012  6949              LDR      r1,[r1,#0x14]
000014  6081              STR      r1,[r0,#8]
;;;343      HASH_MessageDigest->Data[3] = HASH->HR[3];
000016  4904              LDR      r1,|L6.40|
000018  390c              SUBS     r1,r1,#0xc
00001a  6989              LDR      r1,[r1,#0x18]
00001c  60c1              STR      r1,[r0,#0xc]
;;;344      HASH_MessageDigest->Data[4] = HASH->HR[4];
00001e  4902              LDR      r1,|L6.40|
000020  390c              SUBS     r1,r1,#0xc
000022  69c9              LDR      r1,[r1,#0x1c]
000024  6101              STR      r1,[r0,#0x10]
;;;345    }
000026  4770              BX       lr
;;;346    
                          ENDP

                  |L6.40|
                          DCD      0x5006040c

                          AREA ||i.HASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetFlagStatus PROC
;;;589      */
;;;590    FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)
000000  4601              MOV      r1,r0
;;;591    {
;;;592      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;593      uint32_t tempreg = 0;
000004  2200              MOVS     r2,#0
;;;594    
;;;595      /* Check the parameters */
;;;596      assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
;;;597    
;;;598      /* check if the FLAG is in CR register */
;;;599      if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) 
000006  f4015380          AND      r3,r1,#0x1000
00000a  b113              CBZ      r3,|L7.18|
;;;600      {
;;;601        tempreg = HASH->CR;
00000c  4b06              LDR      r3,|L7.40|
00000e  681a              LDR      r2,[r3,#0]
000010  e002              B        |L7.24|
                  |L7.18|
;;;602      }
;;;603      else /* The FLAG is in SR register */
;;;604      {
;;;605        tempreg = HASH->SR;
000012  4b05              LDR      r3,|L7.40|
000014  3324              ADDS     r3,r3,#0x24
000016  681a              LDR      r2,[r3,#0]
                  |L7.24|
;;;606      }
;;;607    
;;;608      /* Check the status of the specified HASH flag */
;;;609      if ((tempreg & HASH_FLAG) != (uint16_t)RESET)
000018  ea020301          AND      r3,r2,r1
00001c  b10b              CBZ      r3,|L7.34|
;;;610      {
;;;611        /* HASH is set */
;;;612        bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L7.36|
                  |L7.34|
;;;613      }
;;;614      else
;;;615      {
;;;616        /* HASH_FLAG is reset */
;;;617        bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L7.36|
;;;618      }
;;;619    
;;;620      /* Return the HASH_FLAG status */
;;;621      return  bitstatus;
;;;622    }
000024  4770              BX       lr
;;;623    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x50060400

                          AREA ||i.HASH_GetITStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetITStatus PROC
;;;646      */
;;;647    ITStatus HASH_GetITStatus(uint8_t HASH_IT)
000000  4601              MOV      r1,r0
;;;648    {
;;;649      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;650      uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;651    
;;;652      /* Check the parameters */
;;;653      assert_param(IS_HASH_GET_IT(HASH_IT));  
;;;654    
;;;655    
;;;656      /* Check the status of the specified HASH interrupt */
;;;657      tmpreg =  HASH->SR;
000006  4b05              LDR      r3,|L8.28|
000008  681a              LDR      r2,[r3,#0]
;;;658    
;;;659      if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
00000a  1f1b              SUBS     r3,r3,#4
00000c  681b              LDR      r3,[r3,#0]
00000e  4013              ANDS     r3,r3,r2
000010  400b              ANDS     r3,r3,r1
000012  b10b              CBZ      r3,|L8.24|
;;;660      {
;;;661        /* HASH_IT is set */
;;;662        bitstatus = SET;
000014  2001              MOVS     r0,#1
000016  e000              B        |L8.26|
                  |L8.24|
;;;663      }
;;;664      else
;;;665      {
;;;666        /* HASH_IT is reset */
;;;667        bitstatus = RESET;
000018  2000              MOVS     r0,#0
                  |L8.26|
;;;668      }
;;;669      /* Return the HASH_IT status */
;;;670      return bitstatus;
;;;671    }
00001a  4770              BX       lr
;;;672    
                          ENDP

                  |L8.28|
                          DCD      0x50060424

                          AREA ||i.HASH_GetInFIFOWordsNbr||, CODE, READONLY, ALIGN=2

                  HASH_GetInFIFOWordsNbr PROC
;;;322      */
;;;323    uint8_t HASH_GetInFIFOWordsNbr(void)
000000  4802              LDR      r0,|L9.12|
;;;324    {
;;;325      /* Return the value of NBW bits */
;;;326      return ((HASH->CR & HASH_CR_NBW) >> 8);
000002  6800              LDR      r0,[r0,#0]
000004  f3c02003          UBFX     r0,r0,#8,#4
;;;327    }
000008  4770              BX       lr
;;;328    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x50060400

                          AREA ||i.HASH_ITConfig||, CODE, READONLY, ALIGN=2

                  HASH_ITConfig PROC
;;;560      */
;;;561    void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;562    {
;;;563      /* Check the parameters */
;;;564      assert_param(IS_HASH_IT(HASH_IT));
;;;565      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;566    
;;;567      if (NewState != DISABLE)
;;;568      {
;;;569        /* Enable the selected HASH interrupt */
;;;570        HASH->IMR |= HASH_IT;
000002  4a07              LDR      r2,|L10.32|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L10.32|
00000a  601a              STR      r2,[r3,#0]
00000c  e006              B        |L10.28|
                  |L10.14|
;;;571      }
;;;572      else
;;;573      {
;;;574        /* Disable the selected HASH interrupt */
;;;575        HASH->IMR &= (uint8_t) ~HASH_IT;
00000e  4a04              LDR      r2,|L10.32|
000010  6812              LDR      r2,[r2,#0]
000012  43c3              MVNS     r3,r0
000014  b2db              UXTB     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L10.32|
00001a  601a              STR      r2,[r3,#0]
                  |L10.28|
;;;576      }
;;;577    }
00001c  4770              BX       lr
;;;578    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x50060420

                          AREA ||i.HASH_Init||, CODE, READONLY, ALIGN=2

                  HASH_Init PROC
;;;196      */
;;;197    void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
000000  4912              LDR      r1,|L11.76|
;;;198    {
;;;199      /* Check the parameters */
;;;200      assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
;;;201      assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
;;;202      assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
;;;203      
;;;204      /* Configure the Algorithm used, algorithm mode and the datatype */
;;;205      HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
000002  6809              LDR      r1,[r1,#0]
000004  f02101f0          BIC      r1,r1,#0xf0
000008  4a10              LDR      r2,|L11.76|
00000a  6011              STR      r1,[r2,#0]
;;;206      HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
00000c  6882              LDR      r2,[r0,#8]
00000e  6801              LDR      r1,[r0,#0]
000010  4311              ORRS     r1,r1,r2
000012  6842              LDR      r2,[r0,#4]
000014  4311              ORRS     r1,r1,r2
000016  4a0d              LDR      r2,|L11.76|
000018  6812              LDR      r2,[r2,#0]
00001a  4311              ORRS     r1,r1,r2
00001c  4a0b              LDR      r2,|L11.76|
00001e  6011              STR      r1,[r2,#0]
;;;207                   HASH_InitStruct->HASH_DataType | \
;;;208                   HASH_InitStruct->HASH_AlgoMode);
;;;209      
;;;210      /* if algorithm mode is HMAC, set the Key */  
;;;211      if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
000020  6841              LDR      r1,[r0,#4]
000022  2940              CMP      r1,#0x40
000024  d10a              BNE      |L11.60|
;;;212      {
;;;213        assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
;;;214        HASH->CR &= ~HASH_CR_LKEY;
000026  4611              MOV      r1,r2
000028  6809              LDR      r1,[r1,#0]
00002a  f4213180          BIC      r1,r1,#0x10000
00002e  6011              STR      r1,[r2,#0]
;;;215        HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
000030  4611              MOV      r1,r2
000032  6809              LDR      r1,[r1,#0]
000034  68c2              LDR      r2,[r0,#0xc]
000036  4311              ORRS     r1,r1,r2
000038  4a04              LDR      r2,|L11.76|
00003a  6011              STR      r1,[r2,#0]
                  |L11.60|
;;;216      }
;;;217    
;;;218      /* Reset the HASH processor core, so that the HASH will be ready to compute 
;;;219         the message digest of a new message */
;;;220      HASH->CR |= HASH_CR_INIT;  
00003c  4903              LDR      r1,|L11.76|
00003e  6809              LDR      r1,[r1,#0]
000040  f0410104          ORR      r1,r1,#4
000044  4a01              LDR      r2,|L11.76|
000046  6011              STR      r1,[r2,#0]
;;;221    }
000048  4770              BX       lr
;;;222    
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x50060400

                          AREA ||i.HASH_Reset||, CODE, READONLY, ALIGN=2

                  HASH_Reset PROC
;;;254      */
;;;255    void HASH_Reset(void)
000000  4803              LDR      r0,|L12.16|
;;;256    {
;;;257      /* Reset the HASH processor core */
;;;258      HASH->CR |= HASH_CR_INIT;
000002  6800              LDR      r0,[r0,#0]
000004  f0400004          ORR      r0,r0,#4
000008  4901              LDR      r1,|L12.16|
00000a  6008              STR      r0,[r1,#0]
;;;259    }
00000c  4770              BX       lr
;;;260    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x50060400

                          AREA ||i.HASH_RestoreContext||, CODE, READONLY, ALIGN=2

                  HASH_RestoreContext PROC
;;;416      */
;;;417    void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
000000  2100              MOVS     r1,#0
;;;418    {
;;;419      uint8_t i = 0;
;;;420      
;;;421      /* restore context registers */
;;;422      HASH->IMR = HASH_ContextRestore->HASH_IMR;   
000002  4b0f              LDR      r3,|L13.64|
000004  6802              LDR      r2,[r0,#0]
000006  601a              STR      r2,[r3,#0]
;;;423      HASH->STR = HASH_ContextRestore->HASH_STR;     
000008  4b0d              LDR      r3,|L13.64|
00000a  3b18              SUBS     r3,r3,#0x18
00000c  6842              LDR      r2,[r0,#4]
00000e  601a              STR      r2,[r3,#0]
;;;424      HASH->CR = HASH_ContextRestore->HASH_CR;
000010  4b0b              LDR      r3,|L13.64|
000012  3b20              SUBS     r3,r3,#0x20
000014  6882              LDR      r2,[r0,#8]
000016  601a              STR      r2,[r3,#0]
;;;425      
;;;426      /* Initialize the hash processor */
;;;427      HASH->CR |= HASH_CR_INIT; 
000018  461a              MOV      r2,r3
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420204          ORR      r2,r2,#4
000020  601a              STR      r2,[r3,#0]
;;;428      
;;;429       /* continue restoring context registers */     
;;;430      for(i=0; i<=50;i++)
000022  bf00              NOP      
000024  e009              B        |L13.58|
                  |L13.38|
;;;431      {
;;;432         HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
000026  f100020c          ADD      r2,r0,#0xc
00002a  f8523021          LDR      r3,[r2,r1,LSL #2]
00002e  4a04              LDR      r2,|L13.64|
000030  32d8              ADDS     r2,r2,#0xd8
000032  f8423021          STR      r3,[r2,r1,LSL #2]
000036  1c4a              ADDS     r2,r1,#1              ;430
000038  b2d1              UXTB     r1,r2                 ;430
                  |L13.58|
00003a  2932              CMP      r1,#0x32              ;430
00003c  ddf3              BLE      |L13.38|
;;;433      }   
;;;434    }
00003e  4770              BX       lr
;;;435    /**
                          ENDP

                  |L13.64|
                          DCD      0x50060420

                          AREA ||i.HASH_SaveContext||, CODE, READONLY, ALIGN=2

                  HASH_SaveContext PROC
;;;394      */
;;;395    void HASH_SaveContext(HASH_Context* HASH_ContextSave)
000000  2100              MOVS     r1,#0
;;;396    {
;;;397      uint8_t i = 0;
;;;398      
;;;399      /* save context registers */
;;;400      HASH_ContextSave->HASH_IMR = HASH->IMR;  
000002  4a0d              LDR      r2,|L14.56|
000004  6812              LDR      r2,[r2,#0]
000006  6002              STR      r2,[r0,#0]
;;;401      HASH_ContextSave->HASH_STR = HASH->STR;      
000008  4a0b              LDR      r2,|L14.56|
00000a  3a18              SUBS     r2,r2,#0x18
00000c  6812              LDR      r2,[r2,#0]
00000e  6042              STR      r2,[r0,#4]
;;;402      HASH_ContextSave->HASH_CR  = HASH->CR;     
000010  4a09              LDR      r2,|L14.56|
000012  3a20              SUBS     r2,r2,#0x20
000014  6812              LDR      r2,[r2,#0]
000016  6082              STR      r2,[r0,#8]
;;;403      for(i=0; i<=50;i++)
000018  bf00              NOP      
00001a  e009              B        |L14.48|
                  |L14.28|
;;;404      {
;;;405         HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
00001c  4a06              LDR      r2,|L14.56|
00001e  32d8              ADDS     r2,r2,#0xd8
000020  f8523021          LDR      r3,[r2,r1,LSL #2]
000024  f100020c          ADD      r2,r0,#0xc
000028  f8423021          STR      r3,[r2,r1,LSL #2]
00002c  1c4a              ADDS     r2,r1,#1              ;403
00002e  b2d1              UXTB     r1,r2                 ;403
                  |L14.48|
000030  2932              CMP      r1,#0x32              ;403
000032  ddf3              BLE      |L14.28|
;;;406      }   
;;;407    }
000034  4770              BX       lr
;;;408    
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x50060420

                          AREA ||i.HASH_SetLastWordValidBitsNbr||, CODE, READONLY, ALIGN=2

                  HASH_SetLastWordValidBitsNbr PROC
;;;296      */
;;;297    void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
000000  4905              LDR      r1,|L15.24|
;;;298    {
;;;299      /* Check the parameters */
;;;300      assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
;;;301      
;;;302      /* Configure the Number of valid bits in last word of the message */
;;;303      HASH->STR &= ~(HASH_STR_NBW);
000002  6809              LDR      r1,[r1,#0]
000004  f021011f          BIC      r1,r1,#0x1f
000008  4a03              LDR      r2,|L15.24|
00000a  6011              STR      r1,[r2,#0]
;;;304      HASH->STR |= ValidNumber;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;305    }
000014  4770              BX       lr
;;;306    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x50060408

                          AREA ||i.HASH_StartDigest||, CODE, READONLY, ALIGN=2

                  HASH_StartDigest PROC
;;;351      */
;;;352    void HASH_StartDigest(void)
000000  4803              LDR      r0,|L16.16|
;;;353    {
;;;354      /* Start the Digest calculation */
;;;355      HASH->STR |= HASH_STR_DCAL;
000002  6800              LDR      r0,[r0,#0]
000004  f4407080          ORR      r0,r0,#0x100
000008  4901              LDR      r1,|L16.16|
00000a  6008              STR      r0,[r1,#0]
;;;356    }
00000c  4770              BX       lr
;;;357    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x50060408

                          AREA ||i.HASH_StructInit||, CODE, READONLY, ALIGN=1

                  HASH_StructInit PROC
;;;230      */
;;;231    void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
000000  2100              MOVS     r1,#0
;;;232    {
;;;233      /* Initialize the HASH_AlgoSelection member */
;;;234      HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000002  6001              STR      r1,[r0,#0]
;;;235    
;;;236      /* Initialize the HASH_AlgoMode member */
;;;237      HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
000004  6041              STR      r1,[r0,#4]
;;;238    
;;;239      /* Initialize the HASH_DataType member */
;;;240      HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
000006  6081              STR      r1,[r0,#8]
;;;241    
;;;242      /* Initialize the HASH_HMACKeyType member */
;;;243      HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000008  60c1              STR      r1,[r0,#0xc]
;;;244    }
00000a  4770              BX       lr
;;;245    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_hash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_hash_c_90573c7c____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_stm32f2xx_hash_c_90573c7c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_hash_c_90573c7c____REVSH|
#line 402
|__asm___16_stm32f2xx_hash_c_90573c7c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_hash_c_90573c7c____RRX|
#line 587
|__asm___16_stm32f2xx_hash_c_90573c7c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
