; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\bsp_cpu_rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bsp_cpu_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\bsp_cpu_rtc.crf ..\User\bsp\bsp_cpu_rtc.c]
                          THUMB

                          AREA ||i.IS_RTC_LeapYear||, CODE, READONLY, ALIGN=1

                  IS_RTC_LeapYear PROC
;;;134    */
;;;135    uint8_t IS_RTC_LeapYear(uint16_t _year)
000000  4601              MOV      r1,r0
;;;136    {                     
;;;137    	if (_year % 4 == 0) /* 必须能被4整除 */
000002  17ca              ASRS     r2,r1,#31
000004  eb017292          ADD      r2,r1,r2,LSR #30
000008  1092              ASRS     r2,r2,#2
00000a  eba10282          SUB      r2,r1,r2,LSL #2
00000e  b992              CBNZ     r2,|L1.54|
;;;138    	{ 
;;;139    		if (_year % 100 == 0) 
000010  2064              MOVS     r0,#0x64
000012  fb91f2f0          SDIV     r2,r1,r0
000016  fb001012          MLS      r0,r0,r2,r1
00001a  b950              CBNZ     r0,|L1.50|
;;;140    		{ 
;;;141    			if (_year % 400 == 0)
00001c  f44f70c8          MOV      r0,#0x190
000020  fb91f2f0          SDIV     r2,r1,r0
000024  fb001012          MLS      r0,r0,r2,r1
000028  b908              CBNZ     r0,|L1.46|
;;;142    			{
;;;143    				return 1;	/* 如果以00结尾,还要能被400整除 */
00002a  2001              MOVS     r0,#1
                  |L1.44|
;;;144    			}
;;;145    			else 
;;;146    			{
;;;147    				return 0;   
;;;148    			}
;;;149    
;;;150    		}
;;;151    		else 
;;;152    		{
;;;153    			return 1;   
;;;154    		}
;;;155    	}
;;;156    	else 
;;;157    	{
;;;158    		return 0; 
;;;159    	}
;;;160    }      
00002c  4770              BX       lr
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;147
000030  e7fc              B        |L1.44|
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;153
000034  e7fa              B        |L1.44|
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;158
000038  e7f8              B        |L1.44|
;;;161    
                          ENDP


                          AREA ||i.bsp_InitRTC||, CODE, READONLY, ALIGN=2

                  bsp_InitRTC PROC
;;;38     */
;;;39     void bsp_InitRTC(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;40     {
;;;41          uint16_t u16_WaitForOscSource = 0;
000002  2400              MOVS     r4,#0
;;;42          RTC_InitTypeDef   RTC_InitStructure;
;;;43     
;;;44          /* Enable the PWR clock */ /* PWR时钟（电源控制）与BKP时钟（RTC后备寄存器）使能 */  
;;;45          RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_AHB1Periph_BKPSRAM, ENABLE);
000004  2101              MOVS     r1,#1
000006  4830              LDR      r0,|L2.200|
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;46     
;;;47          /* Allow access to BKP Domain */ /*使能RTC和后备寄存器访问 */  
;;;48          PWR_BackupAccessCmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;49     
;;;50          /*
;;;51          我们在BKP的后备寄存器1中，存了一个特殊字符0xA5A5, 第一次上电或后备电源掉电后，该寄存器数据丢失，
;;;52          表明RTC数据丢失，需要重新配置
;;;53          */
;;;54         if (RTC_ReadBackupRegister(RTC_BKP_DR1) != 0xA5A5)
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       RTC_ReadBackupRegister
000018  f24a51a5          MOV      r1,#0xa5a5
00001c  4288              CMP      r0,r1
00001e  d039              BEQ      |L2.148|
;;;55         {
;;;56             //重新配置RTC
;;;57     	/* Calendar Configuration */
;;;58     	RTC_InitStructure.RTC_AsynchPrediv = 0x7F;
000020  207f              MOVS     r0,#0x7f
000022  9001              STR      r0,[sp,#4]
;;;59     	RTC_InitStructure.RTC_SynchPrediv =  0xFF;
000024  20ff              MOVS     r0,#0xff
000026  9002              STR      r0,[sp,#8]
;;;60     	RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
;;;61     	RTC_Init(&RTC_InitStructure);
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       RTC_Init
;;;62         
;;;63             /* Enable LSE */		
;;;64             RCC_LSEConfig(RCC_LSE_ON);
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       RCC_LSEConfig
;;;65             //while ((u16_WaitForOscSource++) < 5000) ;
;;;66     
;;;67             /* Wait till LSE is ready */ /* 等待外部晶振震荡稳定输出 */  
;;;68             while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);
000038  bf00              NOP      
                  |L2.58|
00003a  2041              MOVS     r0,#0x41
00003c  f7fffffe          BL       RCC_GetFlagStatus
000040  2800              CMP      r0,#0
000042  d0fa              BEQ      |L2.58|
;;;69     
;;;70             /* Select LSE as RTC Clock Source */ /*使用外部32.768KHz晶振作为RTC时钟 */ 
;;;71             RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000044  f44f7080          MOV      r0,#0x100
000048  f7fffffe          BL       RCC_RTCCLKConfig
;;;72             /* Enable RTC Clock */
;;;73             RCC_RTCCLKCmd(ENABLE);
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       RCC_RTCCLKCmd
;;;74             /* Wait for RTC registers synchronization */
;;;75             RTC_WaitForSynchro();
000052  f7fffffe          BL       RTC_WaitForSynchro
;;;76             /* Enable the RTC Second */
;;;77             //RTC_ITConfig(RTC_IT_TS, ENABLE);
;;;78     
;;;79             /* Default date: 2017-01-01 default time: 08:00:00 */
;;;80             bsp_RTC_SetDate(2017, RTC_Month_January, 1);//默认时间
000056  2201              MOVS     r2,#1
000058  4611              MOV      r1,r2
00005a  f24070e1          MOV      r0,#0x7e1
00005e  f7fffffe          BL       bsp_RTC_SetDate
;;;81             bsp_RTC_SetTime(8, 58, 0);
000062  2200              MOVS     r2,#0
000064  213a              MOVS     r1,#0x3a
000066  2008              MOVS     r0,#8
000068  f7fffffe          BL       bsp_RTC_SetTime
;;;82     
;;;83             /* Configure the RTC Wakeup Clock source and Counter (Wakeup event each 1 second) */
;;;84             RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);
00006c  2000              MOVS     r0,#0
00006e  f7fffffe          BL       RTC_WakeUpClockConfig
;;;85             RTC_SetWakeUpCounter(0x7FF);
000072  f24070ff          MOV      r0,#0x7ff
000076  f7fffffe          BL       RTC_SetWakeUpCounter
;;;86     
;;;87             /* Enable the Wakeup Interrupt */
;;;88             RTC_ITConfig(RTC_IT_WUT, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  0388              LSLS     r0,r1,#14
00007e  f7fffffe          BL       RTC_ITConfig
;;;89      
;;;90             /* Enable Wakeup Counter */
;;;91             RTC_WakeUpCmd(ENABLE);
000082  2001              MOVS     r0,#1
000084  f7fffffe          BL       RTC_WakeUpCmd
;;;92     		
;;;93             /* 配置完成后，向后备寄存器中写特殊字符0xA5A5 */
;;;94             RTC_WriteBackupRegister(RTC_BKP_DR1, 0xA5A5);
000088  f24a51a5          MOV      r1,#0xa5a5
00008c  2001              MOVS     r0,#1
00008e  f7fffffe          BL       RTC_WriteBackupRegister
000092  e018              B        |L2.198|
                  |L2.148|
;;;95         }
;;;96         else
;;;97         {
;;;98             while ((u16_WaitForOscSource++) < 5000) ;
000094  bf00              NOP      
                  |L2.150|
000096  4620              MOV      r0,r4
000098  1c61              ADDS     r1,r4,#1
00009a  b28c              UXTH     r4,r1
00009c  f2413188          MOV      r1,#0x1388
0000a0  4288              CMP      r0,r1
0000a2  dbf8              BLT      |L2.150|
;;;99             
;;;100            /* Wait for RTC APB registers synchronisation */
;;;101            RTC_WaitForSynchro();
0000a4  f7fffffe          BL       RTC_WaitForSynchro
;;;102            RTC_ClearITPendingBit(RTC_IT_WUT);
0000a8  f44f4080          MOV      r0,#0x4000
0000ac  f7fffffe          BL       RTC_ClearITPendingBit
;;;103            
;;;104            if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
0000b0  207b              MOVS     r0,#0x7b
0000b2  f7fffffe          BL       RCC_GetFlagStatus
0000b6  b910              CBNZ     r0,|L2.190|
;;;105            {
;;;106    			/* 上电复位 */
;;;107            }
;;;108            else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
0000b8  207a              MOVS     r0,#0x7a
0000ba  f7fffffe          BL       RCC_GetFlagStatus
                  |L2.190|
;;;109            {
;;;110                /* 外部RST管脚复位 */
;;;111            }
;;;112            /* 清除RCC中复位标志 */
;;;113            RCC_ClearFlag();
0000be  f7fffffe          BL       RCC_ClearFlag
;;;114            
;;;115            //虽然RTC模块不需要重新配置，且掉电后依靠后备电池依然运行
;;;116            //但是每次上电后，还是要使能RTCCLK???????
;;;117            //RCC_RTCCLKCmd(ENABLE);
;;;118            //等待RTC时钟与APB1时钟同步
;;;119            RTC_WaitForSynchro();
0000c2  f7fffffe          BL       RTC_WaitForSynchro
                  |L2.198|
;;;120            
;;;121            //使能秒中断
;;;122            //RTC_ITConfig(RTC_IT_SEC, ENABLE);
;;;123            }
;;;124    	return;
;;;125    }
0000c6  bd3e              POP      {r1-r5,pc}
;;;126    
                          ENDP

                  |L2.200|
                          DCD      0x10040000

                          AREA ||i.bsp_RTC_CalcWeek||, CODE, READONLY, ALIGN=1

                  bsp_RTC_CalcWeek PROC
;;;288    */
;;;289    uint8_t bsp_RTC_CalcWeek(uint16_t _year, uint8_t _mon, uint8_t _day)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;290    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;291    	/*
;;;292    	蔡勒（Zeller）公式
;;;293    		历史上的某一天是星期几？未来的某一天是星期几？关于这个问题，有很多计算公式（两个通用计算公式和
;;;294    	一些分段计算公式），其中最著名的是蔡勒（Zeller）公式。
;;;295    	    即w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1
;;;296    
;;;297    		公式中的符号含义如下，
;;;298    	     w：星期；
;;;299    	     c：年的高2位，即世纪-1
;;;300    	     y：年（两位数）；
;;;301    	     m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，
;;;302    	  	    比如2003年1月1日要看作2002年的13月1日来计算）；
;;;303    	     d：日；
;;;304    	     [ ]代表取整，即只要整数部分。
;;;305    
;;;306    	    算出来的W除以7，余数是几就是星期几。如果余数是0，则为星期日。
;;;307            如果结果是负数，负数求余数则需要特殊处理：
;;;308                负数不能按习惯的余数的概念求余数，只能按数论中的余数的定义求余。为了方便
;;;309            计算，我们可以给它加上一个7的整数倍，使它变为一个正数，然后再求余数
;;;310    
;;;311    		以2049年10月1日（100周年国庆）为例，用蔡勒（Zeller）公式进行计算，过程如下：
;;;312    		蔡勒（Zeller）公式：w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1
;;;313    		=49+[49/4]+[20/4]-2×20+[26× (10+1)/10]+1-1
;;;314    		=49+[12.25]+5-40+[28.6]
;;;315    		=49+12+5-40+28
;;;316    		=54 (除以7余5)
;;;317    		即2049年10月1日（100周年国庆）是星期5。
;;;318    	*/
;;;319    	uint8_t y, c, m, d;
;;;320    	int16_t w;
;;;321    
;;;322    	if (_mon >= 3)
00000a  2d03              CMP      r5,#3
00000c  db0c              BLT      |L3.40|
;;;323    	{
;;;324    		m = _mon;
00000e  46ac              MOV      r12,r5
;;;325    		y = _year % 100;
000010  2064              MOVS     r0,#0x64
000012  fb94f8f0          SDIV     r8,r4,r0
000016  fb004018          MLS      r0,r0,r8,r4
00001a  b2c2              UXTB     r2,r0
;;;326    		c = _year / 100;
00001c  2064              MOVS     r0,#0x64
00001e  fb94f0f0          SDIV     r0,r4,r0
000022  b2c3              UXTB     r3,r0
;;;327    		d = _day;
000024  4637              MOV      r7,r6
000026  e010              B        |L3.74|
                  |L3.40|
;;;328    	}
;;;329    	else	/* 某年的1、2月要看作上一年的13、14月来计算 */
;;;330    	{
;;;331    		m = _mon + 12;
000028  f105000c          ADD      r0,r5,#0xc
00002c  f0000cff          AND      r12,r0,#0xff
;;;332    		y = (_year - 1) % 100;
000030  1e60              SUBS     r0,r4,#1
000032  f04f0864          MOV      r8,#0x64
000036  fb90f9f8          SDIV     r9,r0,r8
00003a  fb080019          MLS      r0,r8,r9,r0
00003e  b2c2              UXTB     r2,r0
;;;333    		c = (_year - 1) / 100;
000040  1e60              SUBS     r0,r4,#1
000042  fb90f0f8          SDIV     r0,r0,r8
000046  b2c3              UXTB     r3,r0
;;;334    		d = _day;
000048  4637              MOV      r7,r6
                  |L3.74|
;;;335    	}
;;;336    
;;;337    	w = y + y / 4 +  c / 4 - 2 * c + ((uint16_t)26*(m+1))/10 + d - 1;
00004a  f10c0901          ADD      r9,r12,#1
00004e  f04f0a1a          MOV      r10,#0x1a
000052  fb09f90a          MUL      r9,r9,r10
000056  f04f0a0a          MOV      r10,#0xa
00005a  fb99f9fa          SDIV     r9,r9,r10
00005e  ea4f7ae2          ASR      r10,r2,#31
000062  eb027a9a          ADD      r10,r2,r10,LSR #30
000066  eb020aaa          ADD      r10,r2,r10,ASR #2
00006a  ea4f7be3          ASR      r11,r3,#31
00006e  eb037b9b          ADD      r11,r3,r11,LSR #30
000072  eb0a0aab          ADD      r10,r10,r11,ASR #2
000076  f04f0b02          MOV      r11,#2
00007a  fb0baa13          MLS      r10,r11,r3,r10
00007e  44d1              ADD      r9,r9,r10
000080  44b9              ADD      r9,r9,r7
000082  f1a90901          SUB      r9,r9,#1
000086  fa0ff189          SXTH     r1,r9
;;;338    	if (w == 0)
00008a  b909              CBNZ     r1,|L3.144|
;;;339    	{
;;;340    		w = 7;	/* 表示周日 */
00008c  2107              MOVS     r1,#7
00008e  e011              B        |L3.180|
                  |L3.144|
;;;341    	}
;;;342    	else if (w < 0)	/* 如果w是负数，则计算余数方式不同 */
000090  2900              CMP      r1,#0
000092  da0a              BGE      |L3.170|
;;;343    	{
;;;344    		w = 7 - (-w) % 7;
000094  4248              RSBS     r0,r1,#0
000096  f04f0807          MOV      r8,#7
00009a  fb90f9f8          SDIV     r9,r0,r8
00009e  fb080019          MLS      r0,r8,r9,r0
0000a2  f1c00007          RSB      r0,r0,#7
0000a6  b201              SXTH     r1,r0
0000a8  e004              B        |L3.180|
                  |L3.170|
;;;345    	}
;;;346    	else
;;;347    	{
;;;348    		w = w % 7;
0000aa  2007              MOVS     r0,#7
0000ac  fb91f8f0          SDIV     r8,r1,r0
0000b0  fb001118          MLS      r1,r0,r8,r1
                  |L3.180|
;;;349    	}
;;;350    
;;;351            if(w== 0) return RTC_Weekday_Sunday;
0000b4  b911              CBNZ     r1,|L3.188|
0000b6  2007              MOVS     r0,#7
                  |L3.184|
;;;352            else	return w;
;;;353    }
0000b8  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.188|
0000bc  b2c8              UXTB     r0,r1                 ;352
0000be  e7fb              B        |L3.184|
;;;354    
                          ENDP


                          AREA ||i.bsp_RTC_GetClock||, CODE, READONLY, ALIGN=2

                  bsp_RTC_GetClock PROC
;;;262    
;;;263    void bsp_RTC_GetClock(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;264    {
;;;265        RTC_DateTypeDef   RTC_DateStructure; 
;;;266        RTC_TimeTypeDef   RTC_TimeStructure;
;;;267    
;;;268        RTC_GetDate(RTC_Format_BIN, &RTC_DateStructure);
000002  a901              ADD      r1,sp,#4
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       RTC_GetDate
;;;269        RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       RTC_GetTime
;;;270    
;;;271        g_tRTC.Year = RTC_DateStructure.RTC_Year+2000;
000012  f89d0007          LDRB     r0,[sp,#7]
000016  f50060fa          ADD      r0,r0,#0x7d0
00001a  490a              LDR      r1,|L4.68|
00001c  8008              STRH     r0,[r1,#0]
;;;272        g_tRTC.Mon = RTC_DateStructure.RTC_Month;
00001e  f89d0005          LDRB     r0,[sp,#5]
000022  7088              STRB     r0,[r1,#2]
;;;273        g_tRTC.Day = RTC_DateStructure.RTC_Date;
000024  f89d0006          LDRB     r0,[sp,#6]
000028  70c8              STRB     r0,[r1,#3]
;;;274        g_tRTC.Week = RTC_DateStructure.RTC_WeekDay;
00002a  f89d0004          LDRB     r0,[sp,#4]
00002e  71c8              STRB     r0,[r1,#7]
;;;275    
;;;276        g_tRTC.Hour = RTC_TimeStructure.RTC_Hours;
000030  f89d0000          LDRB     r0,[sp,#0]
000034  7108              STRB     r0,[r1,#4]
;;;277        g_tRTC.Min = RTC_TimeStructure.RTC_Minutes;
000036  f89d0001          LDRB     r0,[sp,#1]
00003a  7148              STRB     r0,[r1,#5]
;;;278        g_tRTC.Sec = RTC_TimeStructure.RTC_Seconds;
00003c  f89d0002          LDRB     r0,[sp,#2]
000040  7188              STRB     r0,[r1,#6]
;;;279    }
000042  bd1c              POP      {r2-r4,pc}
;;;280    
                          ENDP

                  |L4.68|
                          DCD      g_tRTC

                          AREA ||i.bsp_RTC_GetSecond||, CODE, READONLY, ALIGN=2

                  bsp_RTC_GetSecond PROC
;;;198    */
;;;199    uint32_t bsp_RTC_GetSecond(uint16_t _year, uint8_t _mon, uint8_t _day, uint8_t _hour, uint8_t _min, uint8_t _sec)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;200    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a08          LDRD     r9,r10,[sp,#0x20]
;;;201    	uint16_t t;
;;;202    	uint32_t seccount=0;
000010  2300              MOVS     r3,#0
;;;203    
;;;204    
;;;205    	if (_year < 2000 || _year > 2099)
000012  f5b56ffa          CMP      r5,#0x7d0
000016  db03              BLT      |L5.32|
000018  f6400033          MOV      r0,#0x833
00001c  4285              CMP      r5,r0
00001e  dd02              BLE      |L5.38|
                  |L5.32|
;;;206    	{
;;;207    		return 0;	/* _year范围1970-2099，此处设置范围为2000-2099 */   
000020  2000              MOVS     r0,#0
                  |L5.34|
;;;208    	}		
;;;209    	
;;;210    	for (t = 1970; t < _year; t++) 	/* 把所有年份的秒钟相加 */
;;;211    	{
;;;212    		if (IS_RTC_LeapYear(t))		/* 判断是否为闰年 */
;;;213    		{
;;;214    			seccount += 31622400;	/* 闰年的秒钟数 */
;;;215    		}
;;;216    		else
;;;217    		{
;;;218    			seccount += 31536000; 	/* 平年的秒钟数 */
;;;219    		}
;;;220    	}
;;;221    
;;;222    	_mon -= 1;
;;;223    
;;;224    	for (t = 0; t < _mon; t++)         /* 把前面月份的秒钟数相加 */
;;;225    	{
;;;226    		seccount += (uint32_t)mon_table[t] * 86400;	/* 月份秒钟数相加 */
;;;227    
;;;228    		if (IS_RTC_LeapYear(_year) && t == 1)
;;;229    		{
;;;230    			seccount += 86400;	/* 闰年2月份增加一天的秒钟数 */
;;;231    		}			
;;;232    	}
;;;233    
;;;234    	seccount += (uint32_t)(_day - 1) * 86400;	/* 把前面日期的秒钟数相加 */
;;;235    
;;;236    	seccount += (uint32_t)_hour * 3600;		/* 小时秒钟数 */
;;;237    
;;;238    	seccount += (uint32_t)_min * 60;	/* 分钟秒钟数 */
;;;239    
;;;240    	seccount += _sec;	/* 最后的秒钟加上去 */
;;;241           
;;;242    	return seccount;      
;;;243    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L5.38|
000026  f24074b2          MOV      r4,#0x7b2             ;210
00002a  e00a              B        |L5.66|
                  |L5.44|
00002c  4620              MOV      r0,r4                 ;212
00002e  f7fffffe          BL       IS_RTC_LeapYear
000032  b110              CBZ      r0,|L5.58|
000034  4819              LDR      r0,|L5.156|
000036  4403              ADD      r3,r3,r0              ;214
000038  e001              B        |L5.62|
                  |L5.58|
00003a  4819              LDR      r0,|L5.160|
00003c  4403              ADD      r3,r3,r0              ;218
                  |L5.62|
00003e  1c60              ADDS     r0,r4,#1              ;210
000040  b284              UXTH     r4,r0                 ;210
                  |L5.66|
000042  42ac              CMP      r4,r5                 ;210
000044  dbf2              BLT      |L5.44|
000046  1e70              SUBS     r0,r6,#1              ;222
000048  b2c6              UXTB     r6,r0                 ;222
00004a  2400              MOVS     r4,#0                 ;224
00004c  e010              B        |L5.112|
                  |L5.78|
00004e  4815              LDR      r0,|L5.164|
000050  5d00              LDRB     r0,[r0,r4]            ;226
000052  f24021a3          MOV      r1,#0x2a3             ;226
000056  4348              MULS     r0,r1,r0              ;226
000058  eb0313c0          ADD      r3,r3,r0,LSL #7       ;226
00005c  4628              MOV      r0,r5                 ;228
00005e  f7fffffe          BL       IS_RTC_LeapYear
000062  b118              CBZ      r0,|L5.108|
000064  2c01              CMP      r4,#1                 ;228
000066  d101              BNE      |L5.108|
000068  480f              LDR      r0,|L5.168|
00006a  4403              ADD      r3,r3,r0              ;230
                  |L5.108|
00006c  1c60              ADDS     r0,r4,#1              ;224
00006e  b284              UXTH     r4,r0                 ;224
                  |L5.112|
000070  42b4              CMP      r4,r6                 ;224
000072  dbec              BLT      |L5.78|
000074  1e78              SUBS     r0,r7,#1              ;234
000076  f24021a3          MOV      r1,#0x2a3             ;234
00007a  4348              MULS     r0,r1,r0              ;234
00007c  eb0313c0          ADD      r3,r3,r0,LSL #7       ;234
000080  ebc81048          RSB      r0,r8,r8,LSL #5       ;236
000084  ebc02008          RSB      r0,r0,r8,LSL #8       ;236
000088  eb031300          ADD      r3,r3,r0,LSL #4       ;236
00008c  ebc91009          RSB      r0,r9,r9,LSL #4       ;238
000090  eb030380          ADD      r3,r3,r0,LSL #2       ;238
000094  4453              ADD      r3,r3,r10             ;240
000096  4618              MOV      r0,r3                 ;242
000098  e7c3              B        |L5.34|
;;;244    
                          ENDP

00009a  0000              DCW      0x0000
                  |L5.156|
                          DCD      0x01e28500
                  |L5.160|
                          DCD      0x01e13380
                  |L5.164|
                          DCD      mon_table
                  |L5.168|
                          DCD      0x00015180

                          AREA ||i.bsp_RTC_ReadClock||, CODE, READONLY, ALIGN=1

                  bsp_RTC_ReadClock PROC
;;;252    */
;;;253    void bsp_RTC_ReadClock(RTC_DateTypeDef *pDate, RTC_TimeTypeDef   *pTime)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;255    
;;;256        if(! pDate)
000006  b91c              CBNZ     r4,|L6.16|
;;;257            RTC_GetDate(RTC_Format_BIN, pDate);
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       RTC_GetDate
                  |L6.16|
;;;258    
;;;259        if(! pTime)
000010  b91d              CBNZ     r5,|L6.26|
;;;260            RTC_GetTime(RTC_Format_BIN, pTime);
000012  4629              MOV      r1,r5
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       RTC_GetTime
                  |L6.26|
;;;261    }   
00001a  bd70              POP      {r4-r6,pc}
;;;262    
                          ENDP


                          AREA ||i.bsp_RTC_SetDate||, CODE, READONLY, ALIGN=1

                  bsp_RTC_SetDate PROC
;;;174    
;;;175    void bsp_RTC_SetDate(uint16_t _year, uint8_t _mon, uint8_t _day)
000000  b5f8              PUSH     {r3-r7,lr}
;;;176    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;177    	RTC_DateTypeDef   RTC_DateStructure;
;;;178    
;;;179    	/* Set the Date */
;;;180    	RTC_DateStructure.RTC_Year = IS_RTC_YEAR(_year - 2000)? (_year - 2000) : 16; 
000008  f5a460fa          SUB      r0,r4,#0x7d0
00000c  2863              CMP      r0,#0x63
00000e  dc00              BGT      |L7.18|
000010  e000              B        |L7.20|
                  |L7.18|
000012  2010              MOVS     r0,#0x10
                  |L7.20|
000014  b2c0              UXTB     r0,r0
000016  f88d0003          STRB     r0,[sp,#3]
;;;181    	RTC_DateStructure.RTC_Month = IS_RTC_MONTH(_mon)? _mon : RTC_Month_January;
00001a  2d01              CMP      r5,#1
00001c  db03              BLT      |L7.38|
00001e  2d0c              CMP      r5,#0xc
000020  dc01              BGT      |L7.38|
000022  4628              MOV      r0,r5
000024  e000              B        |L7.40|
                  |L7.38|
000026  2001              MOVS     r0,#1
                  |L7.40|
000028  f88d0001          STRB     r0,[sp,#1]
;;;182    	RTC_DateStructure.RTC_Date = IS_RTC_DATE(_day)? _day : 0x01;  
00002c  2e01              CMP      r6,#1
00002e  db03              BLT      |L7.56|
000030  2e1f              CMP      r6,#0x1f
000032  dc01              BGT      |L7.56|
000034  4630              MOV      r0,r6
000036  e000              B        |L7.58|
                  |L7.56|
000038  2001              MOVS     r0,#1
                  |L7.58|
00003a  f88d0002          STRB     r0,[sp,#2]
;;;183    	RTC_DateStructure.RTC_WeekDay = bsp_RTC_CalcWeek(RTC_DateStructure.RTC_Year,
00003e  f89d2002          LDRB     r2,[sp,#2]
000042  f89d1001          LDRB     r1,[sp,#1]
000046  f89d0003          LDRB     r0,[sp,#3]
00004a  f7fffffe          BL       bsp_RTC_CalcWeek
00004e  f88d0000          STRB     r0,[sp,#0]
;;;184                                                                                                      RTC_DateStructure.RTC_Month,
;;;185                                                                                                      RTC_DateStructure.RTC_Date); 
;;;186        
;;;187    	/* Set Current Time and Date */
;;;188    	RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure);
000052  4669              MOV      r1,sp
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       RTC_SetDate
;;;189    }
00005a  bdf8              POP      {r3-r7,pc}
;;;190    
                          ENDP


                          AREA ||i.bsp_RTC_SetTime||, CODE, READONLY, ALIGN=1

                  bsp_RTC_SetTime PROC
;;;161    
;;;162    void bsp_RTC_SetTime(uint8_t _hour, uint8_t _min, uint8_t _sec)
000000  b5f8              PUSH     {r3-r7,lr}
;;;163    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;164    	RTC_TimeTypeDef   RTC_TimeStructure;
;;;165    
;;;166    	/* Set the Time */
;;;167    	RTC_TimeStructure.RTC_Hours   = IS_RTC_HOUR24(_hour)? _hour : 0x08;
000008  2e17              CMP      r6,#0x17
00000a  dc01              BGT      |L8.16|
00000c  4630              MOV      r0,r6
00000e  e000              B        |L8.18|
                  |L8.16|
000010  2008              MOVS     r0,#8
                  |L8.18|
000012  f88d0000          STRB     r0,[sp,#0]
;;;168    	RTC_TimeStructure.RTC_Minutes = IS_RTC_MINUTES(_min)? _min : 0x00;
000016  2c3b              CMP      r4,#0x3b
000018  dc01              BGT      |L8.30|
00001a  4620              MOV      r0,r4
00001c  e000              B        |L8.32|
                  |L8.30|
00001e  2000              MOVS     r0,#0
                  |L8.32|
000020  f88d0001          STRB     r0,[sp,#1]
;;;169    	RTC_TimeStructure.RTC_Seconds = IS_RTC_SECONDS(_sec)? _sec : 0x00;
000024  2d3b              CMP      r5,#0x3b
000026  dc01              BGT      |L8.44|
000028  4628              MOV      r0,r5
00002a  e000              B        |L8.46|
                  |L8.44|
00002c  2000              MOVS     r0,#0
                  |L8.46|
00002e  f88d0002          STRB     r0,[sp,#2]
;;;170        
;;;171    	/* Set Current Time and Date */
;;;172    	RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure);  
000032  4669              MOV      r1,sp
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       RTC_SetTime
;;;173    }
00003a  bdf8              POP      {r3-r7,pc}
;;;174    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  mon_table
000000  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000004  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000008  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=1

                  g_tRTC
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp\\bsp_cpu_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_bsp_cpu_rtc_c_54b4358b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____REVSH|
#line 402
|__asm___13_bsp_cpu_rtc_c_54b4358b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____RRX|
#line 587
|__asm___13_bsp_cpu_rtc_c_54b4358b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
