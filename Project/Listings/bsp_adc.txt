; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\bsp_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bsp_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\bsp_adc.crf ..\User\bsp\bsp_adc.c]
                          THUMB

                          AREA ||i.bsp_InitADC||, CODE, READONLY, ALIGN=2

                  bsp_InitADC PROC
;;;25     
;;;26     void bsp_InitADC(void)
000000  b500              PUSH     {lr}
;;;27     {
000002  b09b              SUB      sp,sp,#0x6c
;;;28           ADC_InitTypeDef       ADC_InitStructure;
;;;29           ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;30           DMA_InitTypeDef       DMA_InitStructure;
;;;31           GPIO_InitTypeDef      GPIO_InitStructure;
;;;32     
;;;33           /* 使能 ADC1， DMA 和 GPIOA 时钟 */
;;;34           RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4843              LDR      r0,|L1.276|
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;35           RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;36     
;;;37           /* Configure ADC1 Channel6 pin as analog input ******************************/
;;;38           GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_3;
000014  200b              MOVS     r0,#0xb
000016  9000              STR      r0,[sp,#0]
;;;39           GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000018  2003              MOVS     r0,#3
00001a  f88d0004          STRB     r0,[sp,#4]
;;;40           GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
00001e  2000              MOVS     r0,#0
000020  f88d0007          STRB     r0,[sp,#7]
;;;41           GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  483c              LDR      r0,|L1.280|
000028  f7fffffe          BL       GPIO_Init
;;;42     
;;;43         
;;;44           //DMA_DeInit(DMA2_Stream0);
;;;45           /* DMA2 Stream0 channe0 configuration **************************************/
;;;46           //DMA_DeInit(DMA2_Stream0);
;;;47           DMA_InitStructure.DMA_Channel = DMA_Channel_0;  
00002c  2000              MOVS     r0,#0
00002e  9002              STR      r0,[sp,#8]
;;;48           DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;//外设地址
000030  483a              LDR      r0,|L1.284|
000032  9003              STR      r0,[sp,#0xc]
;;;49           DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_ConvertedValue;//内存地址
000034  483a              LDR      r0,|L1.288|
000036  9004              STR      r0,[sp,#0x10]
;;;50           DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;//DMA传输方向
000038  2000              MOVS     r0,#0
00003a  9005              STR      r0,[sp,#0x14]
;;;51           DMA_InitStructure.DMA_BufferSize = 4;//设置DMA在传输时缓冲区的长度 word,根据通道数来定
00003c  2004              MOVS     r0,#4
00003e  9006              STR      r0,[sp,#0x18]
;;;52           DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//设置DMA的外设递增模式
000040  2000              MOVS     r0,#0
000042  9007              STR      r0,[sp,#0x1c]
;;;53           DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//设置DMA的内存递增模式
000044  f44f6080          MOV      r0,#0x400
000048  9008              STR      r0,[sp,#0x20]
;;;54           DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//外设数据字长
00004a  0040              LSLS     r0,r0,#1
00004c  9009              STR      r0,[sp,#0x24]
;;;55           DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//内存数据字长
00004e  0080              LSLS     r0,r0,#2
000050  900a              STR      r0,[sp,#0x28]
;;;56           DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//设置DMA的传输模式：连续不断的循环模式
000052  1140              ASRS     r0,r0,#5
000054  900b              STR      r0,[sp,#0x2c]
;;;57           DMA_InitStructure.DMA_Priority = DMA_Priority_High;//设置DMA的优先级别
000056  0240              LSLS     r0,r0,#9
000058  900c              STR      r0,[sp,#0x30]
;;;58           DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;  //       
00005a  2000              MOVS     r0,#0
00005c  900d              STR      r0,[sp,#0x34]
;;;59           DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
00005e  2001              MOVS     r0,#1
000060  900e              STR      r0,[sp,#0x38]
;;;60           DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
000062  2000              MOVS     r0,#0
000064  900f              STR      r0,[sp,#0x3c]
;;;61           DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
000066  9010              STR      r0,[sp,#0x40]
;;;62           DMA_Init(DMA2_Stream0, &DMA_InitStructure);
000068  a902              ADD      r1,sp,#8
00006a  482e              LDR      r0,|L1.292|
00006c  f7fffffe          BL       DMA_Init
;;;63           DMA_Cmd(DMA2_Stream0, ENABLE);
000070  2101              MOVS     r1,#1
000072  482c              LDR      r0,|L1.292|
000074  f7fffffe          BL       DMA_Cmd
;;;64         
;;;65           /****************************************************************************   
;;;66             PCLK2 = HCLK / 2 
;;;67             下面选择的是2分频
;;;68             ADCCLK = PCLK2 /8 = HCLK / 8 = 168 / 8 = 21M
;;;69             ADC采样频率： Sampling Time + Conversion Time = 480 + 12 cycles = 492cyc
;;;70                           Conversion Time = 21MHz / 492cyc = 42.6ksps. 
;;;71           *****************************************************************************/
;;;72     
;;;73         
;;;74           /* ADC Common Init **********************************************************/
;;;75           ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
000078  2000              MOVS     r0,#0
00007a  9011              STR      r0,[sp,#0x44]
;;;76           ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;//预分频
00007c  9012              STR      r0,[sp,#0x48]
;;;77           ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
00007e  9013              STR      r0,[sp,#0x4c]
;;;78           ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
000080  9014              STR      r0,[sp,#0x50]
;;;79           ADC_CommonInit(&ADC_CommonInitStructure);
000082  a811              ADD      r0,sp,#0x44
000084  f7fffffe          BL       ADC_CommonInit
;;;80         
;;;81           /* ADC1 Init ****************************************************************/
;;;82           ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b; //设置12bit的分辨率
000088  2000              MOVS     r0,#0
00008a  9015              STR      r0,[sp,#0x54]
;;;83           ADC_InitStructure.ADC_ScanConvMode = ENABLE;//扫描模式，以单通道和多通道来区分
00008c  2001              MOVS     r0,#1
00008e  f88d0058          STRB     r0,[sp,#0x58]
;;;84           ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//连续模式
000092  f88d0059          STRB     r0,[sp,#0x59]
;;;85           ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//外部触发禁止
000096  2000              MOVS     r0,#0
000098  9017              STR      r0,[sp,#0x5c]
;;;86           ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//数据对齐
00009a  9019              STR      r0,[sp,#0x64]
;;;87           ADC_InitStructure.ADC_NbrOfConversion = 4;//设置ADC转换通道数
00009c  2004              MOVS     r0,#4
00009e  f88d0068          STRB     r0,[sp,#0x68]
;;;88           ADC_Init(ADC1, &ADC_InitStructure);
0000a2  a915              ADD      r1,sp,#0x54
0000a4  481d              LDR      r0,|L1.284|
0000a6  384c              SUBS     r0,r0,#0x4c
0000a8  f7fffffe          BL       ADC_Init
;;;89     
;;;90          /* Enable ADC3 DMA */
;;;91           ADC_DMACmd(ADC1, ENABLE);
0000ac  2101              MOVS     r1,#1
0000ae  481b              LDR      r0,|L1.284|
0000b0  384c              SUBS     r0,r0,#0x4c
0000b2  f7fffffe          BL       ADC_DMACmd
;;;92          
;;;93           /* ADC1 regular channe6 configuration *************************************/
;;;94           ADC_RegularChannelConfig(ADC1, ADC_Channel_TempSensor, 1, ADC_SampleTime_480Cycles);
0000b6  2307              MOVS     r3,#7
0000b8  2201              MOVS     r2,#1
0000ba  2110              MOVS     r1,#0x10
0000bc  4817              LDR      r0,|L1.284|
0000be  384c              SUBS     r0,r0,#0x4c
0000c0  f7fffffe          BL       ADC_RegularChannelConfig
;;;95           ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_480Cycles);
0000c4  2307              MOVS     r3,#7
0000c6  2202              MOVS     r2,#2
0000c8  2101              MOVS     r1,#1
0000ca  4814              LDR      r0,|L1.284|
0000cc  384c              SUBS     r0,r0,#0x4c
0000ce  f7fffffe          BL       ADC_RegularChannelConfig
;;;96           ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 3, ADC_SampleTime_3Cycles);
0000d2  2300              MOVS     r3,#0
0000d4  2203              MOVS     r2,#3
0000d6  4619              MOV      r1,r3
0000d8  4810              LDR      r0,|L1.284|
0000da  384c              SUBS     r0,r0,#0x4c
0000dc  f7fffffe          BL       ADC_RegularChannelConfig
;;;97           ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_480Cycles);
0000e0  2307              MOVS     r3,#7
0000e2  2204              MOVS     r2,#4
0000e4  2103              MOVS     r1,#3
0000e6  480d              LDR      r0,|L1.284|
0000e8  384c              SUBS     r0,r0,#0x4c
0000ea  f7fffffe          BL       ADC_RegularChannelConfig
;;;98     
;;;99           ADC_TempSensorVrefintCmd(ENABLE);
0000ee  2001              MOVS     r0,#1
0000f0  f7fffffe          BL       ADC_TempSensorVrefintCmd
;;;100    
;;;101         /* Enable DMA request after last transfer (Single-ADC mode) */
;;;102          ADC_DMARequestAfterLastTransferCmd(ADC1, ENABLE);
0000f4  2101              MOVS     r1,#1
0000f6  4809              LDR      r0,|L1.284|
0000f8  384c              SUBS     r0,r0,#0x4c
0000fa  f7fffffe          BL       ADC_DMARequestAfterLastTransferCmd
;;;103    
;;;104          /* Enable ADC3 */
;;;105          ADC_Cmd(ADC1, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  4806              LDR      r0,|L1.284|
000102  384c              SUBS     r0,r0,#0x4c
000104  f7fffffe          BL       ADC_Cmd
;;;106    
;;;107          ADC_SoftwareStartConv(ADC1);
000108  4804              LDR      r0,|L1.284|
00010a  384c              SUBS     r0,r0,#0x4c
00010c  f7fffffe          BL       ADC_SoftwareStartConv
;;;108    
;;;109    }
000110  b01b              ADD      sp,sp,#0x6c
000112  bd00              POP      {pc}
;;;110    
                          ENDP

                  |L1.276|
                          DCD      0x00400001
                  |L1.280|
                          DCD      0x40020000
                  |L1.284|
                          DCD      0x4001204c
                  |L1.288|
                          DCD      ADC_ConvertedValue
                  |L1.292|
                          DCD      0x40026410

                          AREA ||i.getCurent_ExtTempValue||, CODE, READONLY, ALIGN=2

                  getCurent_ExtTempValue PROC
;;;147    #define UP_R_VALUE 20 //20K
;;;148    int8_t getCurent_ExtTempValue(void)
000000  b530              PUSH     {r4,r5,lr}
;;;149    {
;;;150        uint32_t Vtemp_ExtSeneor;
;;;151        uint32_t Rtemp_Value;
;;;152        int8_t Current_ExtTemp = 125;
000002  207d              MOVS     r0,#0x7d
;;;153        uint8_t i = 0;
000004  2200              MOVS     r2,#0
;;;154    
;;;155        /* 得到ADC采集的电压 */
;;;156        Vtemp_ExtSeneor = ADC_ConvertedValue[1] * 3300 / 4095;
000006  4c1d              LDR      r4,|L2.124|
000008  8864              LDRH     r4,[r4,#2]  ; ADC_ConvertedValue
00000a  f64045e4          MOV      r5,#0xce4
00000e  436c              MULS     r4,r5,r4
000010  f64075ff          MOV      r5,#0xfff
000014  fb94f3f5          SDIV     r3,r4,r5
;;;157    
;;;158        /* 计算当前温度传感器的阻值 */
;;;159        Rtemp_Value = Vtemp_ExtSeneor * UP_R_VALUE * 100 / (3300 - Vtemp_ExtSeneor);
000018  eb030483          ADD      r4,r3,r3,LSL #2
00001c  00a4              LSLS     r4,r4,#2
00001e  2564              MOVS     r5,#0x64
000020  436c              MULS     r4,r5,r4
000022  f64045e4          MOV      r5,#0xce4
000026  1aed              SUBS     r5,r5,r3
000028  fbb4f1f5          UDIV     r1,r4,r5
;;;160    
;;;161        /* 根据温度传感器的阻值查表获得当前温度 */
;;;162        if(Rtemp_Value <= ExtTempValue[0] && Rtemp_Value > ExtTempValue[151])
00002c  4c14              LDR      r4,|L2.128|
00002e  8824              LDRH     r4,[r4,#0]  ; ExtTempValue
000030  428c              CMP      r4,r1
000032  d31a              BCC      |L2.106|
000034  4c12              LDR      r4,|L2.128|
000036  f8b4412e          LDRH     r4,[r4,#0x12e]  ; ExtTempValue
00003a  428c              CMP      r4,r1
00003c  d215              BCS      |L2.106|
;;;163        {
;;;164            for(i = 0; i < 151 ; i++ )
00003e  bf00              NOP      
000040  e010              B        |L2.100|
                  |L2.66|
;;;165            {
;;;166                if( Rtemp_Value <= ExtTempValue[i] && Rtemp_Value > ExtTempValue[i+1] )
000042  4c0f              LDR      r4,|L2.128|
000044  f8344012          LDRH     r4,[r4,r2,LSL #1]
000048  428c              CMP      r4,r1
00004a  d309              BCC      |L2.96|
00004c  4d0c              LDR      r5,|L2.128|
00004e  1c54              ADDS     r4,r2,#1
000050  f8354014          LDRH     r4,[r5,r4,LSL #1]
000054  428c              CMP      r4,r1
000056  d203              BCS      |L2.96|
;;;167                {
;;;168                    Current_ExtTemp = i - 30;
000058  f1a2041e          SUB      r4,r2,#0x1e
00005c  b260              SXTB     r0,r4
;;;169                    break;
00005e  e003              B        |L2.104|
                  |L2.96|
000060  1c54              ADDS     r4,r2,#1              ;164
000062  b2e2              UXTB     r2,r4                 ;164
                  |L2.100|
000064  2a97              CMP      r2,#0x97              ;164
000066  dbec              BLT      |L2.66|
                  |L2.104|
000068  e007              B        |L2.122|
                  |L2.106|
;;;170                }
;;;171            }
;;;172        }
;;;173        else if(Rtemp_Value > ExtTempValue[0])
00006a  4c05              LDR      r4,|L2.128|
00006c  8824              LDRH     r4,[r4,#0]  ; ExtTempValue
00006e  428c              CMP      r4,r1
000070  d202              BCS      |L2.120|
;;;174            Current_ExtTemp = -30;
000072  f06f001d          MVN      r0,#0x1d
000076  e000              B        |L2.122|
                  |L2.120|
;;;175        else 
;;;176            Current_ExtTemp = 125;
000078  207d              MOVS     r0,#0x7d
                  |L2.122|
;;;177    
;;;178        return Current_ExtTemp;
;;;179    }
00007a  bd30              POP      {r4,r5,pc}
;;;180    
                          ENDP

                  |L2.124|
                          DCD      ADC_ConvertedValue
                  |L2.128|
                          DCD      ExtTempValue

                          AREA ||i.getCurent_IntTempValue||, CODE, READONLY, ALIGN=2

                  getCurent_IntTempValue PROC
;;;124    */
;;;125    int8_t getCurent_IntTempValue(void)
000000  bf00              NOP      
;;;126    {
;;;127    #if 0
;;;128    
;;;129        float Vtemp_IntSensor;
;;;130        float Current_IntTemp = 0.0;
;;;131        
;;;132        Vtemp_IntSensor = ADC_ConvertedValue[0] * 3.3f / 4095;  				           
;;;133        Current_IntTemp = (Vtemp_IntSensor - 0.76f) /0.0025f + 25;  
;;;134     
;;;135    #else
;;;136    
;;;137        uint32_t Vtemp_IntSensor;
;;;138        int8_t Current_IntTemp = 0.0;
;;;139        
;;;140        Vtemp_IntSensor = ADC_ConvertedValue[0] * 33000 / 4095;                             
000002  4a09              LDR      r2,|L3.40|
000004  8812              LDRH     r2,[r2,#0]  ; ADC_ConvertedValue
000006  f24803e8          MOV      r3,#0x80e8
00000a  435a              MULS     r2,r3,r2
00000c  f64073ff          MOV      r3,#0xfff
000010  fb92f1f3          SDIV     r1,r2,r3
;;;141        Current_IntTemp = (Vtemp_IntSensor - 7600) / 25 + 25; 
000014  f5a152e8          SUB      r2,r1,#0x1d00
000018  3ab0              SUBS     r2,r2,#0xb0
00001a  2319              MOVS     r3,#0x19
00001c  fbb2f2f3          UDIV     r2,r2,r3
000020  3219              ADDS     r2,r2,#0x19
000022  b250              SXTB     r0,r2
;;;142    
;;;143    #endif
;;;144        return Current_IntTemp;
;;;145    }
000024  4770              BX       lr
;;;146    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      ADC_ConvertedValue

                          AREA ||i.getLightVLuxValue||, CODE, READONLY, ALIGN=2

                  getLightVLuxValue PROC
;;;181    #define R19_VALUE 2 // 2K
;;;182    uint8_t getLightVLuxValue(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184        uint32_t VLight_Sensor; // mA
;;;185        uint16_t ILight_Sensor; // uA
;;;186        uint8_t LightToLuxConvValue = 0; // Lux
000002  2000              MOVS     r0,#0
;;;187        
;;;188        VLight_Sensor = ADC_ConvertedValue[2] * 3300 / 4095;
000004  4b2f              LDR      r3,|L4.196|
000006  889b              LDRH     r3,[r3,#4]  ; ADC_ConvertedValue
000008  f64044e4          MOV      r4,#0xce4
00000c  4363              MULS     r3,r4,r3
00000e  f64074ff          MOV      r4,#0xfff
000012  fb93f2f4          SDIV     r2,r3,r4
;;;189        ILight_Sensor = (3300 - VLight_Sensor)  /R19_VALUE;
000016  f64043e4          MOV      r3,#0xce4
00001a  1a9b              SUBS     r3,r3,r2
00001c  f3c3014f          UBFX     r1,r3,#1,#16
;;;190    
;;;191        if(ILight_Sensor < 10 ) LightToLuxConvValue = 0;
000020  290a              CMP      r1,#0xa
000022  da00              BGE      |L4.38|
000024  e04c              B        |L4.192|
                  |L4.38|
;;;192        else if(ILight_Sensor < 10 ) LightToLuxConvValue = 0;
000026  290a              CMP      r1,#0xa
000028  da01              BGE      |L4.46|
00002a  2000              MOVS     r0,#0
00002c  e048              B        |L4.192|
                  |L4.46|
;;;193        else if(ILight_Sensor < 20 ) LightToLuxConvValue = 1;
00002e  2914              CMP      r1,#0x14
000030  da01              BGE      |L4.54|
000032  2001              MOVS     r0,#1
000034  e044              B        |L4.192|
                  |L4.54|
;;;194        else if(ILight_Sensor < 30 ) LightToLuxConvValue = 2;
000036  291e              CMP      r1,#0x1e
000038  da01              BGE      |L4.62|
00003a  2002              MOVS     r0,#2
00003c  e040              B        |L4.192|
                  |L4.62|
;;;195        else if(ILight_Sensor < 40 ) LightToLuxConvValue = 3;
00003e  2928              CMP      r1,#0x28
000040  da01              BGE      |L4.70|
000042  2003              MOVS     r0,#3
000044  e03c              B        |L4.192|
                  |L4.70|
;;;196        else if(ILight_Sensor < 48 ) LightToLuxConvValue = 4;
000046  2930              CMP      r1,#0x30
000048  da01              BGE      |L4.78|
00004a  2004              MOVS     r0,#4
00004c  e038              B        |L4.192|
                  |L4.78|
;;;197        else if(ILight_Sensor < 55 ) LightToLuxConvValue = 5;
00004e  2937              CMP      r1,#0x37
000050  da01              BGE      |L4.86|
000052  2005              MOVS     r0,#5
000054  e034              B        |L4.192|
                  |L4.86|
;;;198        else if(ILight_Sensor < 58 ) LightToLuxConvValue = 6;
000056  293a              CMP      r1,#0x3a
000058  da01              BGE      |L4.94|
00005a  2006              MOVS     r0,#6
00005c  e030              B        |L4.192|
                  |L4.94|
;;;199        else if(ILight_Sensor < 63 ) LightToLuxConvValue = 7;
00005e  293f              CMP      r1,#0x3f
000060  da01              BGE      |L4.102|
000062  2007              MOVS     r0,#7
000064  e02c              B        |L4.192|
                  |L4.102|
;;;200        else if(ILight_Sensor < 69 ) LightToLuxConvValue = 8;
000066  2945              CMP      r1,#0x45
000068  da01              BGE      |L4.110|
00006a  2008              MOVS     r0,#8
00006c  e028              B        |L4.192|
                  |L4.110|
;;;201        else if(ILight_Sensor < 74 ) LightToLuxConvValue = 9;
00006e  294a              CMP      r1,#0x4a
000070  da01              BGE      |L4.118|
000072  2009              MOVS     r0,#9
000074  e024              B        |L4.192|
                  |L4.118|
;;;202        else if(ILight_Sensor < 80 ) LightToLuxConvValue = 10;
000076  2950              CMP      r1,#0x50
000078  da01              BGE      |L4.126|
00007a  200a              MOVS     r0,#0xa
00007c  e020              B        |L4.192|
                  |L4.126|
;;;203        else if(ILight_Sensor < 90 ) LightToLuxConvValue = 12;
00007e  295a              CMP      r1,#0x5a
000080  da01              BGE      |L4.134|
000082  200c              MOVS     r0,#0xc
000084  e01c              B        |L4.192|
                  |L4.134|
;;;204        else if(ILight_Sensor < 100 ) LightToLuxConvValue = 15;
000086  2964              CMP      r1,#0x64
000088  da01              BGE      |L4.142|
00008a  200f              MOVS     r0,#0xf
00008c  e018              B        |L4.192|
                  |L4.142|
;;;205        else if(ILight_Sensor < 200 ) LightToLuxConvValue = 30;
00008e  29c8              CMP      r1,#0xc8
000090  da01              BGE      |L4.150|
000092  201e              MOVS     r0,#0x1e
000094  e014              B        |L4.192|
                  |L4.150|
;;;206        else if(ILight_Sensor < 300 ) LightToLuxConvValue = 48;
000096  f5b17f96          CMP      r1,#0x12c
00009a  da01              BGE      |L4.160|
00009c  2030              MOVS     r0,#0x30
00009e  e00f              B        |L4.192|
                  |L4.160|
;;;207        else if(ILight_Sensor < 400 ) LightToLuxConvValue = 68;
0000a0  f5b17fc8          CMP      r1,#0x190
0000a4  da01              BGE      |L4.170|
0000a6  2044              MOVS     r0,#0x44
0000a8  e00a              B        |L4.192|
                  |L4.170|
;;;208        else if(ILight_Sensor < 500 ) LightToLuxConvValue = 88;
0000aa  f5b17ffa          CMP      r1,#0x1f4
0000ae  da01              BGE      |L4.180|
0000b0  2058              MOVS     r0,#0x58
0000b2  e005              B        |L4.192|
                  |L4.180|
;;;209        else if(ILight_Sensor < 600 ) LightToLuxConvValue = 95;
0000b4  f5b17f16          CMP      r1,#0x258
0000b8  da01              BGE      |L4.190|
0000ba  205f              MOVS     r0,#0x5f
0000bc  e000              B        |L4.192|
                  |L4.190|
;;;210        else  LightToLuxConvValue = 100;
0000be  2064              MOVS     r0,#0x64
                  |L4.192|
;;;211        
;;;212        return (LightToLuxConvValue);
;;;213    }
0000c0  bd10              POP      {r4,pc}
;;;214    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L4.196|
                          DCD      ADC_ConvertedValue

                          AREA ||i.getMicAmp_dBValue||, CODE, READONLY, ALIGN=2

                  getMicAmp_dBValue PROC
;;;214    
;;;215    uint16_t getMicAmp_dBValue(void)
000000  4805              LDR      r0,|L5.24|
;;;216    {
;;;217        return (ADC_ConvertedValue[3] * 3300 / 4095);
000002  88c0              LDRH     r0,[r0,#6]  ; ADC_ConvertedValue
000004  f64041e4          MOV      r1,#0xce4
000008  4348              MULS     r0,r1,r0
00000a  f64071ff          MOV      r1,#0xfff
00000e  fb90f0f1          SDIV     r0,r0,r1
000012  b280              UXTH     r0,r0
;;;218    }
000014  4770              BX       lr
;;;219    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      ADC_ConvertedValue

                          AREA ||.data||, DATA, ALIGN=1

                  ADC_ConvertedValue
                          %        8
                  ExtTempValue
000008  a63f9bf1          DCW      0xa63f,0x9bf1
00000c  92588965          DCW      0x9258,0x8965
000010  810c7943          DCW      0x810c,0x7943
000014  71fe6b34          DCW      0x71fe,0x6b34
000018  64dd5eef          DCW      0x64dd,0x5eef
00001c  59645435          DCW      0x5964,0x5435
000020  4f5b4acf          DCW      0x4f5b,0x4acf
000024  468e4291          DCW      0x468e,0x4291
000028  3ed43b53          DCW      0x3ed4,0x3b53
00002c  380934f2          DCW      0x3809,0x34f2
000030  320c2f54          DCW      0x320c,0x2f54
000034  2cc52a5d          DCW      0x2cc5,0x2a5d
000038  281a25fa          DCW      0x281a,0x25fa
00003c  23f92217          DCW      0x23f9,0x2217
000040  20511ea5          DCW      0x2051,0x1ea5
000044  1d111b95          DCW      0x1d11,0x1b95
000048  1a2f18dc          DCW      0x1a2f,0x18dc
00004c  179d1670          DCW      0x179d,0x1670
000050  15531446          DCW      0x1553,0x1446
000054  13481258          DCW      0x1348,0x1258
000058  1175109e          DCW      0x1175,0x109e
00005c  0fd30f12          DCW      0x0fd3,0x0f12
000060  0e5c0daf          DCW      0x0e5c,0x0daf
000064  0d0c0c71          DCW      0x0d0c,0x0c71
000068  0bde0b53          DCW      0x0bde,0x0b53
00006c  0acf0a51          DCW      0x0acf,0x0a51
000070  09da0969          DCW      0x09da,0x0969
000074  08fe0898          DCW      0x08fe,0x0898
000078  083707db          DCW      0x0837,0x07db
00007c  07840730          DCW      0x0784,0x0730
000080  06e10696          DCW      0x06e1,0x0696
000084  064e060a          DCW      0x064e,0x060a
000088  05c9058b          DCW      0x05c9,0x058b
00008c  05500518          DCW      0x0550,0x0518
000090  04e204af          DCW      0x04e2,0x04af
000094  047e0450          DCW      0x047e,0x0450
000098  042303f9          DCW      0x0423,0x03f9
00009c  03d003aa          DCW      0x03d0,0x03aa
0000a0  03850362          DCW      0x0385,0x0362
0000a4  03400320          DCW      0x0340,0x0320
0000a8  030102e4          DCW      0x0301,0x02e4
0000ac  02c702ac          DCW      0x02c7,0x02ac
0000b0  0293027a          DCW      0x0293,0x027a
0000b4  0262024c          DCW      0x0262,0x024c
0000b8  02360221          DCW      0x0236,0x0221
0000bc  020d01fa          DCW      0x020d,0x01fa
0000c0  01e801d6          DCW      0x01e8,0x01d6
0000c4  01c601b6          DCW      0x01c6,0x01b6
0000c8  01a60197          DCW      0x01a6,0x0197
0000cc  0189017b          DCW      0x0189,0x017b
0000d0  016e0162          DCW      0x016e,0x0162
0000d4  0155014a          DCW      0x0155,0x014a
0000d8  013f0134          DCW      0x013f,0x0134
0000dc  012a0120          DCW      0x012a,0x0120
0000e0  0116010d          DCW      0x0116,0x010d
0000e4  010400fb          DCW      0x0104,0x00fb
0000e8  00f300eb          DCW      0x00f3,0x00eb
0000ec  00e400dc          DCW      0x00e4,0x00dc
0000f0  00d500cf          DCW      0x00d5,0x00cf
0000f4  00c800c2          DCW      0x00c8,0x00c2
0000f8  00bc00b6          DCW      0x00bc,0x00b6
0000fc  00b000ab          DCW      0x00b0,0x00ab
000100  00a600a0          DCW      0x00a6,0x00a0
000104  009c0097          DCW      0x009c,0x0097
000108  0092008e          DCW      0x0092,0x008e
00010c  008a0086          DCW      0x008a,0x0086
000110  0082007e          DCW      0x0082,0x007e
000114  007a0077          DCW      0x007a,0x0077
000118  00730070          DCW      0x0073,0x0070
00011c  006d006a          DCW      0x006d,0x006a
000120  00670064          DCW      0x0067,0x0064
000124  0061005e          DCW      0x0061,0x005e
000128  005c0059          DCW      0x005c,0x0059
00012c  00560054          DCW      0x0056,0x0054
000130  00520050          DCW      0x0052,0x0050
000134  004d0044          DCW      0x004d,0x0044

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp\\bsp_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_24348eb7____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_bsp_adc_c_24348eb7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_24348eb7____REVSH|
#line 402
|__asm___9_bsp_adc_c_24348eb7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_24348eb7____RRX|
#line 587
|__asm___9_bsp_adc_c_24348eb7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
