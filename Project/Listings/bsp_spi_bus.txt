; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\bsp_spi_bus.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bsp_spi_bus.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\bsp_spi_bus.crf ..\User\bsp\bsp_spi_bus.c]
                          THUMB

                          AREA ||i.SPI_disk_initialize||, CODE, READONLY, ALIGN=1

                  SPI_disk_initialize PROC
;;;474    
;;;475    uint8_t SPI_disk_initialize(void)
000000  2000              MOVS     r0,#0
;;;476    {
;;;477    
;;;478        return 0;
;;;479    }
000002  4770              BX       lr
;;;480    
                          ENDP


                          AREA ||i.SPI_disk_ioctl||, CODE, READONLY, ALIGN=1

                  SPI_disk_ioctl PROC
;;;498    
;;;499    DRESULT SPI_disk_ioctl(
000000  4602              MOV      r2,r0
;;;500    	uint8_t cmd,		/* Control code */
;;;501    	void *buff)		/* Buffer to send/receive control data */
;;;502    {
;;;503    
;;;504        return RES_OK;
000002  2000              MOVS     r0,#0
;;;505    }
000004  4770              BX       lr
;;;506    /***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/
                          ENDP


                          AREA ||i.SPI_disk_read||, CODE, READONLY, ALIGN=1

                  SPI_disk_read PROC
;;;480    
;;;481    DRESULT SPI_disk_read(
000000  4603              MOV      r3,r0
;;;482        uint8_t *buff,		/* Data buffer to store read data */
;;;483    	uint32_t sector,	/* Start sector in LBA */
;;;484    	uint32_t count	)	/* Number of sectors to read */
;;;485    {
;;;486    
;;;487        return RES_OK;
000002  2000              MOVS     r0,#0
;;;488    }
000004  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.SPI_disk_status||, CODE, READONLY, ALIGN=1

                  SPI_disk_status PROC
;;;468    //////////////////////////////////////////////////////////////////////////////////////////
;;;469    uint8_t SPI_disk_status(void)
000000  2000              MOVS     r0,#0
;;;470    {
;;;471    
;;;472        return 0;
;;;473    }
000002  4770              BX       lr
;;;474    
                          ENDP


                          AREA ||i.SPI_disk_write||, CODE, READONLY, ALIGN=1

                  SPI_disk_write PROC
;;;489    
;;;490    DRESULT SPI_disk_write(
000000  4603              MOV      r3,r0
;;;491       	const uint8_t *buff,		/* Data buffer to store read data */
;;;492    	uint32_t sector,	/* Start sector in LBA */
;;;493    	uint32_t count	)	/* Number of sectors to read */
;;;494    {
;;;495    
;;;496        return RES_OK;
000002  2000              MOVS     r0,#0
;;;497    }
000004  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.bsp_InitSPIBus||, CODE, READONLY, ALIGN=2

                  bsp_InitSPIBus PROC
;;;98     */
;;;99     void bsp_InitSPIBus(void)
000000  b500              PUSH     {lr}
;;;100    {
000002  b087              SUB      sp,sp,#0x1c
;;;101    #ifdef SOFT_SPI		/* 软件SPI */
;;;102    	GPIO_InitTypeDef  GPIO_InitStructure;
;;;103    
;;;104    	/* 打开GPIO时钟 */
;;;105    	RCC_APB2PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);	
;;;106    
;;;107    	/* 配置SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;108    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;109    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;	/* 推挽输出模式 */
;;;110            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;111    	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
;;;112    	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
;;;113    
;;;114    	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;
;;;115    	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);	
;;;116    
;;;117    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;		/* MISO 设置为输入上拉 */
;;;118    	GPIO_InitStructure.GPIO_Pin = PIN_MISO;
;;;119    	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
;;;120    #endif
;;;121    
;;;122    #ifdef HARD_SPI		/* 硬件SPI */
;;;123    	GPIO_InitTypeDef GPIO_InitStructure;
;;;124    	SPI_InitTypeDef SPI_InitStructure;	
;;;125    
;;;126    	/* 开启 SPI 时钟 */
;;;127    	//RCC_APB2PeriphClockCmd(RCC_SPI, ENABLE);
;;;128    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;129    	
;;;130    	/* 使能 GPIO 时钟 */
;;;131    	RCC_APB1PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);	
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;132    
;;;133    	/* 配置 SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;134    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000014  2002              MOVS     r0,#2
000016  f88d0018          STRB     r0,[sp,#0x18]
;;;135    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001a  2000              MOVS     r0,#0
00001c  f88d001a          STRB     r0,[sp,#0x1a]
;;;136    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2002              MOVS     r0,#2
000022  f88d0019          STRB     r0,[sp,#0x19]
;;;137    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
000026  f88d001b          STRB     r0,[sp,#0x1b]
;;;138    	GPIO_InitStructure.GPIO_Pin = PIN_SCK;	
00002a  2020              MOVS     r0,#0x20
00002c  9005              STR      r0,[sp,#0x14]
;;;139    	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
00002e  a905              ADD      r1,sp,#0x14
000030  482c              LDR      r0,|L6.228|
000032  f7fffffe          BL       GPIO_Init
;;;140    	GPIO_PinAFConfig(PORT_SCK,SOURCE_SCK, GPIO_AF_SCK);
000036  2205              MOVS     r2,#5
000038  4611              MOV      r1,r2
00003a  482a              LDR      r0,|L6.228|
00003c  f7fffffe          BL       GPIO_PinAFConfig
;;;141    	
;;;142    	GPIO_InitStructure.GPIO_Pin = PIN_MISO;	
000040  2040              MOVS     r0,#0x40
000042  9005              STR      r0,[sp,#0x14]
;;;143    	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
000044  a905              ADD      r1,sp,#0x14
000046  4827              LDR      r0,|L6.228|
000048  f7fffffe          BL       GPIO_Init
;;;144    	GPIO_PinAFConfig(PORT_MISO,SOURCE_MISO, GPIO_AF_MISO);
00004c  2205              MOVS     r2,#5
00004e  2106              MOVS     r1,#6
000050  4824              LDR      r0,|L6.228|
000052  f7fffffe          BL       GPIO_PinAFConfig
;;;145    
;;;146    	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;	
000056  2080              MOVS     r0,#0x80
000058  9005              STR      r0,[sp,#0x14]
;;;147    	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);
00005a  a905              ADD      r1,sp,#0x14
00005c  4821              LDR      r0,|L6.228|
00005e  f7fffffe          BL       GPIO_Init
;;;148    	GPIO_PinAFConfig(PORT_MOSI,SOURCE_MOSI, GPIO_AF_MOSI);
000062  2205              MOVS     r2,#5
000064  2107              MOVS     r1,#7
000066  481f              LDR      r0,|L6.228|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;149    
;;;150    	GPIO_InitStructure.GPIO_Pin = PIN_CS;
00006c  2010              MOVS     r0,#0x10
00006e  9005              STR      r0,[sp,#0x14]
;;;151    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000070  2001              MOVS     r0,#1
000072  f88d0018          STRB     r0,[sp,#0x18]
;;;152    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000076  2000              MOVS     r0,#0
000078  f88d001a          STRB     r0,[sp,#0x1a]
;;;153    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00007c  2002              MOVS     r0,#2
00007e  f88d0019          STRB     r0,[sp,#0x19]
;;;154    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000082  2000              MOVS     r0,#0
000084  f88d001b          STRB     r0,[sp,#0x1b]
;;;155    	GPIO_Init(PORT_CS, &GPIO_InitStructure);
000088  a905              ADD      r1,sp,#0x14
00008a  4816              LDR      r0,|L6.228|
00008c  f7fffffe          BL       GPIO_Init
;;;156    
;;;157    	bsp_SPI_CS_HIGH();
000090  2110              MOVS     r1,#0x10
000092  4814              LDR      r0,|L6.228|
000094  f7fffffe          BL       GPIO_SetBits
;;;158    
;;;159    	/*!< SPI configuration */
;;;160    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000098  2000              MOVS     r0,#0
00009a  f8ad0000          STRH     r0,[sp,#0]
;;;161    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
00009e  f44f7082          MOV      r0,#0x104
0000a2  f8ad0002          STRH     r0,[sp,#2]
;;;162    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
0000a6  2000              MOVS     r0,#0
0000a8  f8ad0004          STRH     r0,[sp,#4]
;;;163    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
0000ac  2002              MOVS     r0,#2
0000ae  f8ad0006          STRH     r0,[sp,#6]
;;;164    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
0000b2  2001              MOVS     r0,#1
0000b4  f8ad0008          STRH     r0,[sp,#8]
;;;165    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
0000b8  0240              LSLS     r0,r0,#9
0000ba  f8ad000a          STRH     r0,[sp,#0xa]
;;;166    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
0000be  2008              MOVS     r0,#8
0000c0  f8ad000c          STRH     r0,[sp,#0xc]
;;;167    
;;;168    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
0000c4  2000              MOVS     r0,#0
0000c6  f8ad000e          STRH     r0,[sp,#0xe]
;;;169    	SPI_InitStructure.SPI_CRCPolynomial = 7;
0000ca  2007              MOVS     r0,#7
0000cc  f8ad0010          STRH     r0,[sp,#0x10]
;;;170    	SPI_Init(SPI_BUS, &SPI_InitStructure);
0000d0  4669              MOV      r1,sp
0000d2  4805              LDR      r0,|L6.232|
0000d4  f7fffffe          BL       SPI_Init
;;;171    
;;;172    	/*!< Enable the sFLASH_SPI  */
;;;173    	SPI_Cmd(SPI_BUS, ENABLE);		/* 使能SPI  */
0000d8  2101              MOVS     r1,#1
0000da  4803              LDR      r0,|L6.232|
0000dc  f7fffffe          BL       SPI_Cmd
;;;174    #endif
;;;175    }
0000e0  b007              ADD      sp,sp,#0x1c
0000e2  bd00              POP      {pc}
;;;176    
                          ENDP

                  |L6.228|
                          DCD      0x40020000
                  |L6.232|
                          DCD      0x40013000

                          AREA ||i.bsp_SPI_Init||, CODE, READONLY, ALIGN=2

                  bsp_SPI_Init PROC
;;;185    #ifdef HARD_SPI		/* 硬件SPI */
;;;186    void bsp_SPI_Init(uint16_t _cr1)
000000  4909              LDR      r1,|L7.40|
;;;187    {
;;;188    	SPI_HARD->CR1 = ((SPI_HARD->CR1 & CR1_CLEAR_Mask) | _cr1);
000002  8809              LDRH     r1,[r1,#0]
000004  f4015141          AND      r1,r1,#0x3040
000008  4301              ORRS     r1,r1,r0
00000a  4a07              LDR      r2,|L7.40|
00000c  8011              STRH     r1,[r2,#0]
;;;189    	  
;;;190    	//SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */	    
;;;191        SPI_HARD->CR1 &= CR1_SPE_Reset;	/* Disable the selected SPI peripheral */
00000e  4611              MOV      r1,r2
000010  8809              LDRH     r1,[r1,#0]
000012  f64f72bf          MOV      r2,#0xffbf
000016  4011              ANDS     r1,r1,r2
000018  4a03              LDR      r2,|L7.40|
00001a  8011              STRH     r1,[r2,#0]
;;;192    
;;;193    	//SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */		    
;;;194        SPI_HARD->CR1 |= CR1_SPE_Set;	  /* Enable the selected SPI peripheral */
00001c  4611              MOV      r1,r2
00001e  8809              LDRH     r1,[r1,#0]
000020  f0410140          ORR      r1,r1,#0x40
000024  8011              STRH     r1,[r2,#0]
;;;195    }
000026  4770              BX       lr
;;;196    #endif
                          ENDP

                  |L7.40|
                          DCD      0x40013000

                          AREA ||i.bsp_SpiBusBusy||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy PROC
;;;440    */
;;;441    uint8_t bsp_SpiBusBusy(void)
000000  4801              LDR      r0,|L8.8|
;;;442    {
;;;443    	return g_spi_busy;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy
;;;444    }
000004  4770              BX       lr
;;;445    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusEnter||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter PROC
;;;414    */
;;;415    void bsp_SpiBusEnter(void)
000000  2001              MOVS     r0,#1
;;;416    {
;;;417    	g_spi_busy = 1;
000002  4901              LDR      r1,|L9.8|
000004  7008              STRB     r0,[r1,#0]
;;;418    }
000006  4770              BX       lr
;;;419    
                          ENDP

                  |L9.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusExit||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit PROC
;;;427    */
;;;428    void bsp_SpiBusExit(void)
000000  2000              MOVS     r0,#0
;;;429    {
;;;430    	g_spi_busy = 0;
000002  4901              LDR      r1,|L10.8|
000004  7008              STRB     r0,[r1,#0]
;;;431    }
000006  4770              BX       lr
;;;432    
                          ENDP

                  |L10.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_spiReadByte0||, CODE, READONLY, ALIGN=2

                  bsp_spiReadByte0 PROC
;;;269    */
;;;270    uint8_t bsp_spiReadByte0(void)
000000  b510              PUSH     {r4,lr}
;;;271    {
;;;272    #ifdef SOFT_SPI		/* 软件SPI */
;;;273    	uint8_t i;
;;;274    	uint8_t read = 0;
;;;275    
;;;276    	for (i = 0; i < 8; i++)
;;;277    	{
;;;278    		read = read<<1;
;;;279    
;;;280    		if (MISO_IS_HIGH())
;;;281    		{
;;;282    			read++;
;;;283    		}
;;;284    		SCK_1();
;;;285    		bsp_spiDelay();
;;;286    		SCK_0();
;;;287    		bsp_spiDelay();
;;;288    	}
;;;289    	return read;
;;;290    #endif
;;;291    
;;;292    #ifdef HARD_SPI		/* 硬件SPI */
;;;293    	uint8_t read;
;;;294    
;;;295    	/* 等待发送缓冲区空 */
;;;296    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L11.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L11.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L11.4|
;;;297    
;;;298    	/* 发送一个字节 */
;;;299    	SPI_I2S_SendData(SPI1, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L11.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;300    
;;;301    	/* 等待数据接收完毕 */
;;;302    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L11.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L11.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L11.26|
;;;303    
;;;304    	/* 读取接收到的数据 */
;;;305    	read = SPI_I2S_ReceiveData(SPI1);
000026  4803              LDR      r0,|L11.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;306    
;;;307    	/* 返回读到的数据 */
;;;308    	return read;
00002e  4620              MOV      r0,r4
;;;309    #endif
;;;310    }
000030  bd10              POP      {r4,pc}
;;;311    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40013000

                          AREA ||i.bsp_spiReadByte1||, CODE, READONLY, ALIGN=2

                  bsp_spiReadByte1 PROC
;;;365    */
;;;366    uint8_t bsp_spiReadByte1(void)
000000  b510              PUSH     {r4,lr}
;;;367    {
;;;368    #ifdef SOFT_SPI		/* 软件SPI */
;;;369    	uint8_t i;
;;;370    	uint8_t read = 0;
;;;371    
;;;372    	for (i = 0; i < 8; i++)
;;;373    	{
;;;374    		SCK_0();
;;;375    		bsp_spiDelay();
;;;376    		read = read << 1;
;;;377    		if (MISO_IS_HIGH())
;;;378    		{
;;;379    			read++;
;;;380    		}
;;;381    		SCK_1();
;;;382    		bsp_spiDelay();
;;;383    	}
;;;384    	return read;
;;;385    #endif
;;;386    
;;;387    #ifdef HARD_SPI		/* 硬件SPI */
;;;388    	uint8_t read;
;;;389    
;;;390    	/* 等待发送缓冲区空 */
;;;391    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L12.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L12.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L12.4|
;;;392    
;;;393    	/* 发送一个字节 */
;;;394    	SPI_I2S_SendData(SPI1, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L12.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;395    
;;;396    	/* 等待数据接收完毕 */
;;;397    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L12.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L12.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L12.26|
;;;398    
;;;399    	/* 读取接收到的数据 */
;;;400    	read = SPI_I2S_ReceiveData(SPI1);
000026  4803              LDR      r0,|L12.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;401    
;;;402    	/* 返回读到的数据 */
;;;403    	return read;
00002e  4620              MOV      r0,r4
;;;404    #endif
;;;405    }
000030  bd10              POP      {r4,pc}
;;;406    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0x40013000

                          AREA ||i.bsp_spiWriteByte0||, CODE, READONLY, ALIGN=2

                  bsp_spiWriteByte0 PROC
;;;222    */
;;;223    void bsp_spiWriteByte0(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;224    {
000002  4604              MOV      r4,r0
;;;225    #ifdef SOFT_SPI		/* 软件SPI */
;;;226    	uint8_t i;
;;;227    
;;;228    	for(i = 0; i < 8; i++)
;;;229    	{
;;;230    		if (_ucByte & 0x80)
;;;231    		{
;;;232    			MOSI_1();
;;;233    		}
;;;234    		else
;;;235    		{
;;;236    			MOSI_0();
;;;237    		}
;;;238    		bsp_spiDelay();
;;;239    		SCK_1();
;;;240    		_ucByte <<= 1;
;;;241    		bsp_spiDelay();
;;;242    		SCK_0();
;;;243    	}
;;;244    	bsp_spiDelay();
;;;245    #endif
;;;246    
;;;247    #ifdef HARD_SPI		/* 硬件SPI */
;;;248    	/* 等待发送缓冲区空 */
;;;249    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L13.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L13.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L13.6|
;;;250    
;;;251    	/* 发送一个字节 */
;;;252    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L13.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;253    
;;;254    	/* 等待数据接收完毕 */
;;;255    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L13.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L13.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L13.28|
;;;256    
;;;257    	/* 读取接收到的数据 */
;;;258    	SPI_I2S_ReceiveData(SPI1);
000028  4801              LDR      r0,|L13.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;259    #endif
;;;260    }
00002e  bd10              POP      {r4,pc}
;;;261    
                          ENDP

                  |L13.48|
                          DCD      0x40013000

                          AREA ||i.bsp_spiWriteByte1||, CODE, READONLY, ALIGN=2

                  bsp_spiWriteByte1 PROC
;;;319    */
;;;320    void bsp_spiWriteByte1(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;321    {
000002  4604              MOV      r4,r0
;;;322    #ifdef SOFT_SPI		/* 软件SPI */
;;;323    	uint8_t i;
;;;324    
;;;325    	for(i = 0; i < 8; i++)
;;;326    	{
;;;327    		if (_ucByte & 0x80)
;;;328    		{
;;;329    			MOSI_1();
;;;330    		}
;;;331    		else
;;;332    		{
;;;333    			MOSI_0();
;;;334    		}
;;;335    		SCK_0();
;;;336    		_ucByte <<= 1;
;;;337    		bsp_spiDelay();
;;;338    		SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
;;;339    		bsp_spiDelay();
;;;340    	}
;;;341    #endif
;;;342    
;;;343    #ifdef HARD_SPI		/* 硬件SPI */
;;;344    	/* 等待发送缓冲区空 */
;;;345    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L14.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L14.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L14.6|
;;;346    
;;;347    	/* 发送一个字节 */
;;;348    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L14.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;349    
;;;350    	/* 等待数据接收完毕 */
;;;351    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L14.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L14.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L14.28|
;;;352    
;;;353    	/* 读取接收到的数据 */
;;;354    	SPI_I2S_ReceiveData(SPI1);
000028  4801              LDR      r0,|L14.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;355    #endif
;;;356    }
00002e  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  |L14.48|
                          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\bsp\\bsp_spi_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_bsp_spi_bus_c_c88bcf96____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REVSH|
#line 402
|__asm___13_bsp_spi_bus_c_c88bcf96____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____RRX|
#line 587
|__asm___13_bsp_spi_bus_c_c88bcf96____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
