; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_cryp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_cryp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_cryp.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_cryp.c]
                          THUMB

                          AREA ||i.CRYP_Cmd||, CODE, READONLY, ALIGN=2

                  CRYP_Cmd PROC
;;;375      */
;;;376    void CRYP_Cmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L1.16|
;;;377    {
;;;378      /* Check the parameters */
;;;379      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;380    
;;;381      if (NewState != DISABLE)
;;;382      {
;;;383        /* Enable the Cryptographic processor */
;;;384        CRYP->CR |= CRYP_CR_CRYPEN;
000002  4907              LDR      r1,|L1.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4414100          ORR      r1,r1,#0x8000
00000a  4a05              LDR      r2,|L1.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;385      }
;;;386      else
;;;387      {
;;;388        /* Disable the Cryptographic processor */
;;;389        CRYP->CR &= ~CRYP_CR_CRYPEN;
000010  4903              LDR      r1,|L1.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4214100          BIC      r1,r1,#0x8000
000018  4a01              LDR      r2,|L1.32|
00001a  6011              STR      r1,[r2,#0]
                  |L1.28|
;;;390      }
;;;391    }
00001c  4770              BX       lr
;;;392    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x50060000

                          AREA ||i.CRYP_DMACmd||, CODE, READONLY, ALIGN=2

                  CRYP_DMACmd PROC
;;;617      */
;;;618    void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;619    {
;;;620      /* Check the parameters */
;;;621      assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
;;;622      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;623    
;;;624      if (NewState != DISABLE)
;;;625      {
;;;626        /* Enable the selected CRYP DMA request */
;;;627        CRYP->DMACR |= CRYP_DMAReq;
000002  4a07              LDR      r2,|L2.32|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L2.32|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e006              B        |L2.28|
                  |L2.14|
;;;628      }
;;;629      else
;;;630      {
;;;631        /* Disable the selected CRYP DMA request */
;;;632        CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
00000e  4a04              LDR      r2,|L2.32|
000010  6912              LDR      r2,[r2,#0x10]
000012  43c3              MVNS     r3,r0
000014  b2db              UXTB     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L2.32|
00001a  611a              STR      r2,[r3,#0x10]
                  |L2.28|
;;;633      }
;;;634    }
00001c  4770              BX       lr
;;;635    /**
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataIn||, CODE, READONLY, ALIGN=2

                  CRYP_DataIn PROC
;;;418      */
;;;419    void CRYP_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L3.8|
;;;420    {
;;;421      CRYP->DR = Data;
000002  6088              STR      r0,[r1,#8]
;;;422    }
000004  4770              BX       lr
;;;423    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataOut||, CODE, READONLY, ALIGN=2

                  CRYP_DataOut PROC
;;;428      */
;;;429    uint32_t CRYP_DataOut(void)
000000  4801              LDR      r0,|L4.8|
;;;430    {
;;;431      return CRYP->DOUT;
000002  68c0              LDR      r0,[r0,#0xc]
;;;432    }
000004  4770              BX       lr
;;;433    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DeInit||, CODE, READONLY, ALIGN=1

                  CRYP_DeInit PROC
;;;220      */
;;;221    void CRYP_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;222    {
;;;223      /* Enable CRYP reset state */
;;;224      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;225    
;;;226      /* Release CRYP from reset state */
;;;227      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;228    }
000012  bd10              POP      {r4,pc}
;;;229    
                          ENDP


                          AREA ||i.CRYP_FIFOFlush||, CODE, READONLY, ALIGN=2

                  CRYP_FIFOFlush PROC
;;;363      */
;;;364    void CRYP_FIFOFlush(void)
000000  4803              LDR      r0,|L6.16|
;;;365    {
;;;366      /* Reset the read and write pointers of the FIFOs */
;;;367      CRYP->CR |= CRYP_CR_FFLUSH;
000002  6800              LDR      r0,[r0,#0]
000004  f4404080          ORR      r0,r0,#0x4000
000008  4901              LDR      r1,|L6.16|
00000a  6008              STR      r0,[r1,#0]
;;;368    }
00000c  4770              BX       lr
;;;369    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetFlagStatus PROC
;;;804      */
;;;805    FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
000000  4601              MOV      r1,r0
;;;806    {
;;;807      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;808      uint32_t tempreg = 0;
000004  2200              MOVS     r2,#0
;;;809    
;;;810      /* Check the parameters */
;;;811      assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
;;;812    
;;;813      /* check if the FLAG is in RISR register */
;;;814      if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
000006  f0010320          AND      r3,r1,#0x20
00000a  b113              CBZ      r3,|L7.18|
;;;815      {
;;;816        tempreg = CRYP->RISR;
00000c  4b05              LDR      r3,|L7.36|
00000e  699a              LDR      r2,[r3,#0x18]
000010  e001              B        |L7.22|
                  |L7.18|
;;;817      }
;;;818      else  /* The FLAG is in SR register */
;;;819      {
;;;820        tempreg = CRYP->SR;
000012  4b04              LDR      r3,|L7.36|
000014  685a              LDR      r2,[r3,#4]
                  |L7.22|
;;;821      }
;;;822    
;;;823    
;;;824      /* Check the status of the specified CRYP flag */
;;;825      if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
000016  ea020301          AND      r3,r2,r1
00001a  b10b              CBZ      r3,|L7.32|
;;;826      {
;;;827        /* CRYP_FLAG is set */
;;;828        bitstatus = SET;
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L7.34|
                  |L7.32|
;;;829      }
;;;830      else
;;;831      {
;;;832        /* CRYP_FLAG is reset */
;;;833        bitstatus = RESET;
000020  2000              MOVS     r0,#0
                  |L7.34|
;;;834      }
;;;835    
;;;836      /* Return the CRYP_FLAG status */
;;;837      return  bitstatus;
;;;838    }
000022  4770              BX       lr
;;;839    
                          ENDP

                  |L7.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetITStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetITStatus PROC
;;;770      */
;;;771    ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
000000  4601              MOV      r1,r0
;;;772    {
;;;773      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;774      /* Check the parameters */
;;;775      assert_param(IS_CRYP_GET_IT(CRYP_IT));
;;;776    
;;;777      /* Check the status of the specified CRYP interrupt */
;;;778      if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
000004  4a03              LDR      r2,|L8.20|
000006  69d2              LDR      r2,[r2,#0x1c]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L8.16|
;;;779      {
;;;780        /* CRYP_IT is set */
;;;781        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L8.18|
                  |L8.16|
;;;782      }
;;;783      else
;;;784      {
;;;785        /* CRYP_IT is reset */
;;;786        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;787      }
;;;788      /* Return the CRYP_IT status */
;;;789      return bitstatus;
;;;790    }
000012  4770              BX       lr
;;;791    
                          ENDP

                  |L8.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_ITConfig||, CODE, READONLY, ALIGN=2

                  CRYP_ITConfig PROC
;;;742      */
;;;743    void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;744    {
;;;745      /* Check the parameters */
;;;746      assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
;;;747      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;748    
;;;749      if (NewState != DISABLE)
;;;750      {
;;;751        /* Enable the selected CRYP interrupt */
;;;752        CRYP->IMSCR |= CRYP_IT;
000002  4a07              LDR      r2,|L9.32|
000004  6952              LDR      r2,[r2,#0x14]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L9.32|
00000a  615a              STR      r2,[r3,#0x14]
00000c  e006              B        |L9.28|
                  |L9.14|
;;;753      }
;;;754      else
;;;755      {
;;;756        /* Disable the selected CRYP interrupt */
;;;757        CRYP->IMSCR &= (uint8_t)~CRYP_IT;
00000e  4a04              LDR      r2,|L9.32|
000010  6952              LDR      r2,[r2,#0x14]
000012  43c3              MVNS     r3,r0
000014  b2db              UXTB     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L9.32|
00001a  615a              STR      r2,[r3,#0x14]
                  |L9.28|
;;;758      }
;;;759    }
00001c  4770              BX       lr
;;;760    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVInit||, CODE, READONLY, ALIGN=2

                  CRYP_IVInit PROC
;;;334      */
;;;335    void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  4a04              LDR      r2,|L10.20|
;;;336    {
;;;337      CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
000002  6801              LDR      r1,[r0,#0]
000004  6411              STR      r1,[r2,#0x40]
;;;338      CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
000006  6841              LDR      r1,[r0,#4]
000008  6451              STR      r1,[r2,#0x44]
;;;339      CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
00000a  6881              LDR      r1,[r0,#8]
00000c  6491              STR      r1,[r2,#0x48]
;;;340      CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
00000e  68c1              LDR      r1,[r0,#0xc]
000010  64d1              STR      r1,[r2,#0x4c]
;;;341    }
000012  4770              BX       lr
;;;342    
                          ENDP

                  |L10.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_IVStructInit PROC
;;;348      */
;;;349    void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;350    {
;;;351      CRYP_IVInitStruct->CRYP_IV0Left  = 0;
000002  6001              STR      r1,[r0,#0]
;;;352      CRYP_IVInitStruct->CRYP_IV0Right = 0;
000004  6041              STR      r1,[r0,#4]
;;;353      CRYP_IVInitStruct->CRYP_IV1Left  = 0;
000006  6081              STR      r1,[r0,#8]
;;;354      CRYP_IVInitStruct->CRYP_IV1Right = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;355    }
00000a  4770              BX       lr
;;;356    
                          ENDP


                          AREA ||i.CRYP_Init||, CODE, READONLY, ALIGN=2

                  CRYP_Init PROC
;;;236      */
;;;237    void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
000000  491d              LDR      r1,|L12.120|
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
;;;241      assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
;;;242      assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
;;;243    
;;;244      /* Select Algorithm mode*/  
;;;245      CRYP->CR &= ~CRYP_CR_ALGOMODE;
000002  6809              LDR      r1,[r1,#0]
000004  f0210138          BIC      r1,r1,#0x38
000008  4a1b              LDR      r2,|L12.120|
00000a  6011              STR      r1,[r2,#0]
;;;246      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  8842              LDRH     r2,[r0,#2]
000012  4311              ORRS     r1,r1,r2
000014  4a18              LDR      r2,|L12.120|
000016  6011              STR      r1,[r2,#0]
;;;247    
;;;248      /* Select dataType */ 
;;;249      CRYP->CR &= ~CRYP_CR_DATATYPE;
000018  4611              MOV      r1,r2
00001a  6809              LDR      r1,[r1,#0]
00001c  f02101c0          BIC      r1,r1,#0xc0
000020  6011              STR      r1,[r2,#0]
;;;250      CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
000022  4611              MOV      r1,r2
000024  6809              LDR      r1,[r1,#0]
000026  8882              LDRH     r2,[r0,#4]
000028  4311              ORRS     r1,r1,r2
00002a  4a13              LDR      r2,|L12.120|
00002c  6011              STR      r1,[r2,#0]
;;;251    
;;;252      /* select Key size (used only with AES algorithm) */
;;;253      if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
00002e  8841              LDRH     r1,[r0,#2]
000030  2920              CMP      r1,#0x20
000032  d008              BEQ      |L12.70|
;;;254          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
000034  8841              LDRH     r1,[r0,#2]
000036  2928              CMP      r1,#0x28
000038  d005              BEQ      |L12.70|
;;;255          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
00003a  8841              LDRH     r1,[r0,#2]
00003c  2930              CMP      r1,#0x30
00003e  d002              BEQ      |L12.70|
;;;256          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
000040  8841              LDRH     r1,[r0,#2]
000042  2938              CMP      r1,#0x38
000044  d10b              BNE      |L12.94|
                  |L12.70|
;;;257      {
;;;258        assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
;;;259        CRYP->CR &= ~CRYP_CR_KEYSIZE;
000046  490c              LDR      r1,|L12.120|
000048  6809              LDR      r1,[r1,#0]
00004a  f4217140          BIC      r1,r1,#0x300
00004e  4a0a              LDR      r2,|L12.120|
000050  6011              STR      r1,[r2,#0]
;;;260        CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
000052  4611              MOV      r1,r2
000054  6809              LDR      r1,[r1,#0]
000056  88c2              LDRH     r2,[r0,#6]
000058  4311              ORRS     r1,r1,r2
00005a  4a07              LDR      r2,|L12.120|
00005c  6011              STR      r1,[r2,#0]
                  |L12.94|
;;;261                                                      configured once the key has 
;;;262                                                      been prepared */
;;;263      }
;;;264    
;;;265      /* Select data Direction */ 
;;;266      CRYP->CR &= ~CRYP_CR_ALGODIR;
00005e  4906              LDR      r1,|L12.120|
000060  6809              LDR      r1,[r1,#0]
000062  f0210104          BIC      r1,r1,#4
000066  4a04              LDR      r2,|L12.120|
000068  6011              STR      r1,[r2,#0]
;;;267      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
00006a  4611              MOV      r1,r2
00006c  6809              LDR      r1,[r1,#0]
00006e  8802              LDRH     r2,[r0,#0]
000070  4311              ORRS     r1,r1,r2
000072  4a01              LDR      r2,|L12.120|
000074  6011              STR      r1,[r2,#0]
;;;268    }
000076  4770              BX       lr
;;;269    
                          ENDP

                  |L12.120|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyInit||, CODE, READONLY, ALIGN=2

                  CRYP_KeyInit PROC
;;;297      */
;;;298    void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  4a08              LDR      r2,|L13.36|
;;;299    {
;;;300      /* Key Initialisation */
;;;301      CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
000002  6801              LDR      r1,[r0,#0]
000004  6211              STR      r1,[r2,#0x20]
;;;302      CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
000006  6841              LDR      r1,[r0,#4]
000008  6251              STR      r1,[r2,#0x24]
;;;303      CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
00000a  6881              LDR      r1,[r0,#8]
00000c  6291              STR      r1,[r2,#0x28]
;;;304      CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
00000e  68c1              LDR      r1,[r0,#0xc]
000010  62d1              STR      r1,[r2,#0x2c]
;;;305      CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
000012  6901              LDR      r1,[r0,#0x10]
000014  6311              STR      r1,[r2,#0x30]
;;;306      CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
000016  6941              LDR      r1,[r0,#0x14]
000018  6351              STR      r1,[r2,#0x34]
;;;307      CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
00001a  6981              LDR      r1,[r0,#0x18]
00001c  6391              STR      r1,[r2,#0x38]
;;;308      CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
00001e  69c1              LDR      r1,[r0,#0x1c]
000020  63d1              STR      r1,[r2,#0x3c]
;;;309    }
000022  4770              BX       lr
;;;310    
                          ENDP

                  |L13.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_KeyStructInit PROC
;;;316      */
;;;317    void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;318    {
;;;319      CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
000002  6001              STR      r1,[r0,#0]
;;;320      CRYP_KeyInitStruct->CRYP_Key0Right = 0;
000004  6041              STR      r1,[r0,#4]
;;;321      CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
000006  6081              STR      r1,[r0,#8]
;;;322      CRYP_KeyInitStruct->CRYP_Key1Right = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;323      CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;324      CRYP_KeyInitStruct->CRYP_Key2Right = 0;
00000c  6141              STR      r1,[r0,#0x14]
;;;325      CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
00000e  6181              STR      r1,[r0,#0x18]
;;;326      CRYP_KeyInitStruct->CRYP_Key3Right = 0;
000010  61c1              STR      r1,[r0,#0x1c]
;;;327    }
000012  4770              BX       lr
;;;328    /**
                          ENDP


                          AREA ||i.CRYP_RestoreContext||, CODE, READONLY, ALIGN=2

                  CRYP_RestoreContext PROC
;;;556      */
;;;557    void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
000000  4a10              LDR      r2,|L15.68|
;;;558    {
;;;559    
;;;560      /* Configure the processor with the saved configuration */
;;;561      CRYP->CR = CRYP_ContextRestore->CR_bits9to2;
000002  6801              LDR      r1,[r0,#0]
000004  6011              STR      r1,[r2,#0]
;;;562    
;;;563      /* restore The key value */
;;;564      CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
000006  6941              LDR      r1,[r0,#0x14]
000008  6211              STR      r1,[r2,#0x20]
;;;565      CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
00000a  6981              LDR      r1,[r0,#0x18]
00000c  6251              STR      r1,[r2,#0x24]
;;;566      CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
00000e  69c1              LDR      r1,[r0,#0x1c]
000010  6291              STR      r1,[r2,#0x28]
;;;567      CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
000012  6a01              LDR      r1,[r0,#0x20]
000014  62d1              STR      r1,[r2,#0x2c]
;;;568      CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
000016  6a41              LDR      r1,[r0,#0x24]
000018  6311              STR      r1,[r2,#0x30]
;;;569      CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  6351              STR      r1,[r2,#0x34]
;;;570      CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
00001e  6ac1              LDR      r1,[r0,#0x2c]
000020  6391              STR      r1,[r2,#0x38]
;;;571      CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
000022  6b01              LDR      r1,[r0,#0x30]
000024  63d1              STR      r1,[r2,#0x3c]
;;;572    
;;;573      /* and the initialization vectors. */
;;;574      CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
000026  6841              LDR      r1,[r0,#4]
000028  6411              STR      r1,[r2,#0x40]
;;;575      CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
00002a  6881              LDR      r1,[r0,#8]
00002c  6451              STR      r1,[r2,#0x44]
;;;576      CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
00002e  68c1              LDR      r1,[r0,#0xc]
000030  6491              STR      r1,[r2,#0x48]
;;;577      CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
000032  6901              LDR      r1,[r0,#0x10]
000034  64d1              STR      r1,[r2,#0x4c]
;;;578    
;;;579      /* Enable the cryptographic processor */
;;;580      CRYP->CR |= CRYP_CR_CRYPEN;
000036  4611              MOV      r1,r2
000038  6809              LDR      r1,[r1,#0]
00003a  f4414100          ORR      r1,r1,#0x8000
00003e  6011              STR      r1,[r2,#0]
;;;581    }
000040  4770              BX       lr
;;;582    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L15.68|
                          DCD      0x50060000

                          AREA ||i.CRYP_SaveContext||, CODE, READONLY, ALIGN=2

                  CRYP_SaveContext PROC
;;;471      */
;;;472    ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
000000  b578              PUSH     {r3-r6,lr}
;;;473                                 CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
;;;474    {
000002  4602              MOV      r2,r0
;;;475      __IO uint32_t timeout = 0;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;476      uint32_t ckeckmask = 0, bitstatus;    
000008  2300              MOVS     r3,#0
;;;477      ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;478    
;;;479      /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
;;;480      CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
00000c  4d28              LDR      r5,|L16.176|
00000e  692d              LDR      r5,[r5,#0x10]
000010  f0250501          BIC      r5,r5,#1
000014  4e26              LDR      r6,|L16.176|
000016  6135              STR      r5,[r6,#0x10]
;;;481        
;;;482      /* Wait until both the IN and OUT FIFOs are empty  
;;;483        (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
;;;484         BUSY bit is cleared. */
;;;485    
;;;486      if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
000018  4635              MOV      r5,r6
00001a  682d              LDR      r5,[r5,#0]
00001c  f0050508          AND      r5,r5,#8
000020  b10d              CBZ      r5,|L16.38|
;;;487      { 
;;;488        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
000022  2311              MOVS     r3,#0x11
000024  e000              B        |L16.40|
                  |L16.38|
;;;489      }
;;;490      else /* AES or DES */
;;;491      {
;;;492        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
000026  2315              MOVS     r3,#0x15
                  |L16.40|
;;;493      }           
;;;494       
;;;495      do 
000028  bf00              NOP      
                  |L16.42|
;;;496      {
;;;497        bitstatus = CRYP->SR & ckeckmask;
00002a  4d21              LDR      r5,|L16.176|
00002c  686d              LDR      r5,[r5,#4]
00002e  ea050403          AND      r4,r5,r3
;;;498        timeout++;
000032  9d00              LDR      r5,[sp,#0]
000034  1c6d              ADDS     r5,r5,#1
000036  9500              STR      r5,[sp,#0]
;;;499      }
;;;500      while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
000038  f64f76ff          MOV      r6,#0xffff
00003c  9d00              LDR      r5,[sp,#0]
00003e  42b5              CMP      r5,r6
000040  d001              BEQ      |L16.70|
000042  2c01              CMP      r4,#1
000044  d1f1              BNE      |L16.42|
                  |L16.70|
;;;501         
;;;502      if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
000046  4d1a              LDR      r5,|L16.176|
000048  686d              LDR      r5,[r5,#4]
00004a  401d              ANDS     r5,r5,r3
00004c  2d01              CMP      r5,#1
00004e  d001              BEQ      |L16.84|
;;;503      {
;;;504        status = ERROR;
000050  2000              MOVS     r0,#0
000052  e02c              B        |L16.174|
                  |L16.84|
;;;505      }
;;;506      else
;;;507      {      
;;;508        /* Stop DMA transfers on the OUT FIFO by 
;;;509           - writing the DOEN bit to 0 in the CRYP_DMACR register 
;;;510           - and clear the CRYPEN bit. */
;;;511    
;;;512        CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
000054  4d16              LDR      r5,|L16.176|
000056  692d              LDR      r5,[r5,#0x10]
000058  f0250502          BIC      r5,r5,#2
00005c  4e14              LDR      r6,|L16.176|
00005e  6135              STR      r5,[r6,#0x10]
;;;513        CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
000060  4635              MOV      r5,r6
000062  682d              LDR      r5,[r5,#0]
000064  f4254500          BIC      r5,r5,#0x8000
000068  6035              STR      r5,[r6,#0]
;;;514    
;;;515        /* Save the current configuration (bits [9:2] in the CRYP_CR register) */
;;;516        CRYP_ContextSave->CR_bits9to2  = CRYP->CR & (CRYP_CR_KEYSIZE  | 
00006a  4635              MOV      r5,r6
00006c  682d              LDR      r5,[r5,#0]
00006e  f405757f          AND      r5,r5,#0x3fc
000072  6015              STR      r5,[r2,#0]
;;;517                                                     CRYP_CR_DATATYPE | 
;;;518                                                     CRYP_CR_ALGOMODE |
;;;519                                                     CRYP_CR_ALGODIR); 
;;;520    
;;;521        /* and, if not in ECB mode, the initialization vectors. */
;;;522        CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
000074  4635              MOV      r5,r6
000076  6c2d              LDR      r5,[r5,#0x40]
000078  6055              STR      r5,[r2,#4]
;;;523        CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
00007a  4635              MOV      r5,r6
00007c  6c6d              LDR      r5,[r5,#0x44]
00007e  6095              STR      r5,[r2,#8]
;;;524        CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
000080  4635              MOV      r5,r6
000082  6cad              LDR      r5,[r5,#0x48]
000084  60d5              STR      r5,[r2,#0xc]
;;;525        CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
000086  4635              MOV      r5,r6
000088  6ced              LDR      r5,[r5,#0x4c]
00008a  6115              STR      r5,[r2,#0x10]
;;;526    
;;;527        /* save The key value */
;;;528        CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
00008c  680d              LDR      r5,[r1,#0]
00008e  6155              STR      r5,[r2,#0x14]
;;;529        CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
000090  684d              LDR      r5,[r1,#4]
000092  6195              STR      r5,[r2,#0x18]
;;;530        CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
000094  688d              LDR      r5,[r1,#8]
000096  61d5              STR      r5,[r2,#0x1c]
;;;531        CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
000098  68cd              LDR      r5,[r1,#0xc]
00009a  6215              STR      r5,[r2,#0x20]
;;;532        CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
00009c  690d              LDR      r5,[r1,#0x10]
00009e  6255              STR      r5,[r2,#0x24]
;;;533        CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
0000a0  694d              LDR      r5,[r1,#0x14]
0000a2  6295              STR      r5,[r2,#0x28]
;;;534        CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
0000a4  698d              LDR      r5,[r1,#0x18]
0000a6  62d5              STR      r5,[r2,#0x2c]
;;;535        CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
0000a8  69cd              LDR      r5,[r1,#0x1c]
0000aa  6315              STR      r5,[r2,#0x30]
;;;536    
;;;537       /* When needed, save the DMA status (pointers for IN and OUT messages, 
;;;538          number of remaining bytes, etc.) */
;;;539         
;;;540        status = SUCCESS;
0000ac  2001              MOVS     r0,#1
                  |L16.174|
;;;541      }
;;;542    
;;;543       return status;
;;;544    }
0000ae  bd78              POP      {r3-r6,pc}
;;;545    
                          ENDP

                  |L16.176|
                          DCD      0x50060000

                          AREA ||i.CRYP_StructInit||, CODE, READONLY, ALIGN=1

                  CRYP_StructInit PROC
;;;275      */
;;;276    void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
000000  2100              MOVS     r1,#0
;;;277    {
;;;278      /* Initialize the CRYP_AlgoDir member */
;;;279      CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000002  8001              STRH     r1,[r0,#0]
;;;280    
;;;281      /* initialize the CRYP_AlgoMode member */
;;;282      CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
000004  8041              STRH     r1,[r0,#2]
;;;283    
;;;284      /* initialize the CRYP_DataType member */
;;;285      CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
000006  8081              STRH     r1,[r0,#4]
;;;286      
;;;287      /* Initialize the CRYP_KeySize member */
;;;288      CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
000008  80c1              STRH     r1,[r0,#6]
;;;289    }
00000a  4770              BX       lr
;;;290    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_cryp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_cryp_c_459f21d3____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_stm32f2xx_cryp_c_459f21d3____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_cryp_c_459f21d3____REVSH|
#line 402
|__asm___16_stm32f2xx_cryp_c_459f21d3____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f2xx_cryp_c_459f21d3____RRX|
#line 587
|__asm___16_stm32f2xx_cryp_c_459f21d3____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
