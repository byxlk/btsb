; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\stm32f2xx_dac.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f2xx_dac.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\RTOS\Template -I..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\FatFS\src -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\User -I..\User\bsp -I..\User\emWinTask -I..\STemWin\Config -I..\STemWin\DisplayDriver -I..\STemWin\inc -I..\STemWin\OS -IH:\BluetoothSoundBox\Project_BtSB\SZ_VIPIN_BTSB_Project\Project\RTE -IC:\Keil_v521a\ARM\PACK\Keil\STM32F2xx_DFP\2.6.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -IC:\Keil_v521a\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DSTM32F205xx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f2xx_dac.crf ..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_dac.c]
                          THUMB

                          AREA ||i.DAC_ClearFlag||, CODE, READONLY, ALIGN=2

                  DAC_ClearFlag PROC
;;;617      */
;;;618    void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
000000  fa01f200          LSL      r2,r1,r0
;;;619    {
;;;620      /* Check the parameters */
;;;621      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;622      assert_param(IS_DAC_FLAG(DAC_FLAG));
;;;623    
;;;624      /* Clear the selected DAC flags */
;;;625      DAC->SR = (DAC_FLAG << DAC_Channel);
000004  4b01              LDR      r3,|L1.12|
000006  601a              STR      r2,[r3,#0]
;;;626    }
000008  4770              BX       lr
;;;627    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x40007434

                          AREA ||i.DAC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DAC_ClearITPendingBit PROC
;;;680      */
;;;681    void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
000000  fa01f200          LSL      r2,r1,r0
;;;682    {
;;;683      /* Check the parameters */
;;;684      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;685      assert_param(IS_DAC_IT(DAC_IT)); 
;;;686    
;;;687      /* Clear the selected DAC interrupt pending bits */
;;;688      DAC->SR = (DAC_IT << DAC_Channel);
000004  4b01              LDR      r3,|L2.12|
000006  601a              STR      r2,[r3,#0]
;;;689    }
000008  4770              BX       lr
;;;690    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40007434

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;258      */
;;;259    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b139              CBZ      r1,|L3.18|
;;;260    {
;;;261      /* Check the parameters */
;;;262      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;263      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;264    
;;;265      if (NewState != DISABLE)
;;;266      {
;;;267        /* Enable the selected DAC channel */
;;;268        DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
000002  4a08              LDR      r2,|L3.36|
000004  6812              LDR      r2,[r2,#0]
000006  2301              MOVS     r3,#1
000008  4083              LSLS     r3,r3,r0
00000a  431a              ORRS     r2,r2,r3
00000c  4b05              LDR      r3,|L3.36|
00000e  601a              STR      r2,[r3,#0]
000010  e006              B        |L3.32|
                  |L3.18|
;;;269      }
;;;270      else
;;;271      {
;;;272        /* Disable the selected DAC channel */
;;;273        DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
000012  4a04              LDR      r2,|L3.36|
000014  6812              LDR      r2,[r2,#0]
000016  2301              MOVS     r3,#1
000018  4083              LSLS     r3,r3,r0
00001a  439a              BICS     r2,r2,r3
00001c  4b01              LDR      r3,|L3.36|
00001e  601a              STR      r2,[r3,#0]
                  |L3.32|
;;;274      }
;;;275    }
000020  4770              BX       lr
;;;276    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x40007400

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;502      */
;;;503    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b141              CBZ      r1,|L4.20|
;;;504    {
;;;505      /* Check the parameters */
;;;506      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;507      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;508    
;;;509      if (NewState != DISABLE)
;;;510      {
;;;511        /* Enable the selected DAC channel DMA request */
;;;512        DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
000002  4a09              LDR      r2,|L4.40|
000004  6812              LDR      r2,[r2,#0]
000006  f44f5380          MOV      r3,#0x1000
00000a  4083              LSLS     r3,r3,r0
00000c  431a              ORRS     r2,r2,r3
00000e  4b06              LDR      r3,|L4.40|
000010  601a              STR      r2,[r3,#0]
000012  e007              B        |L4.36|
                  |L4.20|
;;;513      }
;;;514      else
;;;515      {
;;;516        /* Disable the selected DAC channel DMA request */
;;;517        DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
000014  4a04              LDR      r2,|L4.40|
000016  6812              LDR      r2,[r2,#0]
000018  f44f5380          MOV      r3,#0x1000
00001c  4083              LSLS     r3,r3,r0
00001e  439a              BICS     r2,r2,r3
000020  4b01              LDR      r3,|L4.40|
000022  601a              STR      r2,[r3,#0]
                  |L4.36|
;;;518      }
;;;519    }
000024  4770              BX       lr
;;;520    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40007400

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;179      */
;;;180    void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;181    {
;;;182      /* Enable DAC reset state */
;;;183      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;184      /* Release DAC from reset state */
;;;185      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;186    }
000014  bd10              POP      {r4,pc}
;;;187    
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;310      */
;;;311    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L6.16|
;;;312    {
;;;313      /* Check the parameters */
;;;314      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;315    
;;;316      if (NewState != DISABLE)
;;;317      {
;;;318        /* Enable software trigger for both DAC channels */
;;;319        DAC->SWTRIGR |= DUAL_SWTRIG_SET;
000002  4907              LDR      r1,|L6.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410103          ORR      r1,r1,#3
00000a  4a05              LDR      r2,|L6.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L6.28|
                  |L6.16|
;;;320      }
;;;321      else
;;;322      {
;;;323        /* Disable software trigger for both DAC channels */
;;;324        DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
000010  4903              LDR      r1,|L6.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210103          BIC      r1,r1,#3
000018  4a01              LDR      r2,|L6.32|
00001a  6011              STR      r1,[r2,#0]
                  |L6.28|
;;;325      }
;;;326    }
00001c  4770              BX       lr
;;;327    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40007404

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;457      */
;;;458    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000000  b508              PUSH     {r3,lr}
;;;459    {
000002  4601              MOV      r1,r0
;;;460      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;461      
;;;462      /* Check the parameters */
;;;463      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;464      
;;;465      tmp = (uint32_t) DAC_BASE ;
000008  4805              LDR      r0,|L7.32|
00000a  9000              STR      r0,[sp,#0]
;;;466      tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
00000c  202c              MOVS     r0,#0x2c
00000e  eb000091          ADD      r0,r0,r1,LSR #2
000012  9a00              LDR      r2,[sp,#0]
000014  4410              ADD      r0,r0,r2
000016  9000              STR      r0,[sp,#0]
;;;467      
;;;468      /* Returns the DAC channel data output register value */
;;;469      return (uint16_t) (*(__IO uint32_t*) tmp);
000018  9800              LDR      r0,[sp,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  b280              UXTH     r0,r0
;;;470    }
00001e  bd08              POP      {r3,pc}
;;;471    /**
                          ENDP

                  |L7.32|
                          DCD      0x40007400

                          AREA ||i.DAC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DAC_GetFlagStatus PROC
;;;582      */
;;;583    FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;584    {
000002  4602              MOV      r2,r0
;;;585      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;586      /* Check the parameters */
;;;587      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;588      assert_param(IS_DAC_FLAG(DAC_FLAG));
;;;589    
;;;590      /* Check the status of the specified DAC flag */
;;;591      if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
000006  4b05              LDR      r3,|L8.28|
000008  681b              LDR      r3,[r3,#0]
00000a  fa01f402          LSL      r4,r1,r2
00000e  4023              ANDS     r3,r3,r4
000010  b10b              CBZ      r3,|L8.22|
;;;592      {
;;;593        /* DAC_FLAG is set */
;;;594        bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e000              B        |L8.24|
                  |L8.22|
;;;595      }
;;;596      else
;;;597      {
;;;598        /* DAC_FLAG is reset */
;;;599        bitstatus = RESET;
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;600      }
;;;601      /* Return the DAC_FLAG status */
;;;602      return  bitstatus;
;;;603    }
000018  bd10              POP      {r4,pc}
;;;604    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40007434

                          AREA ||i.DAC_GetITStatus||, CODE, READONLY, ALIGN=2

                  DAC_GetITStatus PROC
;;;640      */
;;;641    ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;642    {
000002  4602              MOV      r2,r0
;;;643      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;644      uint32_t enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;645      
;;;646      /* Check the parameters */
;;;647      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;648      assert_param(IS_DAC_IT(DAC_IT));
;;;649    
;;;650      /* Get the DAC_IT enable bit status */
;;;651      enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
000008  4c08              LDR      r4,|L9.44|
00000a  6824              LDR      r4,[r4,#0]
00000c  fa01f502          LSL      r5,r1,r2
000010  ea040305          AND      r3,r4,r5
;;;652      
;;;653      /* Check the status of the specified DAC interrupt */
;;;654      if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
000014  4c05              LDR      r4,|L9.44|
000016  3434              ADDS     r4,r4,#0x34
000018  6824              LDR      r4,[r4,#0]
00001a  fa01f502          LSL      r5,r1,r2
00001e  402c              ANDS     r4,r4,r5
000020  b114              CBZ      r4,|L9.40|
000022  b10b              CBZ      r3,|L9.40|
;;;655      {
;;;656        /* DAC_IT is set */
;;;657        bitstatus = SET;
000024  2001              MOVS     r0,#1
000026  e000              B        |L9.42|
                  |L9.40|
;;;658      }
;;;659      else
;;;660      {
;;;661        /* DAC_IT is reset */
;;;662        bitstatus = RESET;
000028  2000              MOVS     r0,#0
                  |L9.42|
;;;663      }
;;;664      /* Return the DAC_IT status */
;;;665      return  bitstatus;
;;;666    }
00002a  bd30              POP      {r4,r5,pc}
;;;667    
                          ENDP

                  |L9.44|
                          DCD      0x40007400

                          AREA ||i.DAC_ITConfig||, CODE, READONLY, ALIGN=2

                  DAC_ITConfig PROC
;;;550      */ 
;;;551    void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
000000  b510              PUSH     {r4,lr}
;;;552    {
;;;553      /* Check the parameters */
;;;554      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;555      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;556      assert_param(IS_DAC_IT(DAC_IT)); 
;;;557    
;;;558      if (NewState != DISABLE)
000002  b13a              CBZ      r2,|L10.20|
;;;559      {
;;;560        /* Enable the selected DAC interrupts */
;;;561        DAC->CR |=  (DAC_IT << DAC_Channel);
000004  4b07              LDR      r3,|L10.36|
000006  681b              LDR      r3,[r3,#0]
000008  fa01f400          LSL      r4,r1,r0
00000c  4323              ORRS     r3,r3,r4
00000e  4c05              LDR      r4,|L10.36|
000010  6023              STR      r3,[r4,#0]
000012  e006              B        |L10.34|
                  |L10.20|
;;;562      }
;;;563      else
;;;564      {
;;;565        /* Disable the selected DAC interrupts */
;;;566        DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
000014  4b03              LDR      r3,|L10.36|
000016  681b              LDR      r3,[r3,#0]
000018  fa01f400          LSL      r4,r1,r0
00001c  43a3              BICS     r3,r3,r4
00001e  4c01              LDR      r4,|L10.36|
000020  6023              STR      r3,[r4,#0]
                  |L10.34|
;;;567      }
;;;568    }
000022  bd10              POP      {r4,pc}
;;;569    
                          ENDP

                  |L10.36|
                          DCD      0x40007400

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;198      */
;;;199    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;200    {
;;;201      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;202    
;;;203      /* Check the DAC parameters */
;;;204      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;205      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;206      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;207      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;208    
;;;209    /*---------------------------- DAC CR Configuration --------------------------*/
;;;210      /* Get the DAC CR value */
;;;211      tmpreg1 = DAC->CR;
000006  4c0a              LDR      r4,|L11.48|
000008  6822              LDR      r2,[r4,#0]
;;;212      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;213      tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
00000a  f64074fe          MOV      r4,#0xffe
00000e  4084              LSLS     r4,r4,r0
000010  43a2              BICS     r2,r2,r4
;;;214      /* Configure for the selected DAC channel: buffer output, trigger, 
;;;215         wave generation, mask/amplitude for wave generation */
;;;216      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;217      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;218      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;219      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;220      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000012  e9d14500          LDRD     r4,r5,[r1,#0]
000016  432c              ORRS     r4,r4,r5
000018  688d              LDR      r5,[r1,#8]
00001a  432c              ORRS     r4,r4,r5
00001c  68cd              LDR      r5,[r1,#0xc]
00001e  ea440305          ORR      r3,r4,r5
;;;221                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
;;;222                 DAC_InitStruct->DAC_OutputBuffer);
;;;223      /* Calculate CR register value depending on DAC_Channel */
;;;224      tmpreg1 |= tmpreg2 << DAC_Channel;
000022  fa03f400          LSL      r4,r3,r0
000026  4322              ORRS     r2,r2,r4
;;;225      /* Write to DAC CR */
;;;226      DAC->CR = tmpreg1;
000028  4c01              LDR      r4,|L11.48|
00002a  6022              STR      r2,[r4,#0]
;;;227    }
00002c  bd30              POP      {r4,r5,pc}
;;;228    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel1Data PROC
;;;370      */
;;;371    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000000  b508              PUSH     {r3,lr}
;;;372    {  
;;;373      __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;374      
;;;375      /* Check the parameters */
;;;376      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;377      assert_param(IS_DAC_DATA(Data));
;;;378      
;;;379      tmp = (uint32_t)DAC_BASE; 
000006  4a05              LDR      r2,|L12.28|
000008  9200              STR      r2,[sp,#0]
;;;380      tmp += DHR12R1_OFFSET + DAC_Align;
00000a  f1000208          ADD      r2,r0,#8
00000e  9b00              LDR      r3,[sp,#0]
000010  441a              ADD      r2,r2,r3
000012  9200              STR      r2,[sp,#0]
;;;381    
;;;382      /* Set the DAC channel1 selected data holding register */
;;;383      *(__IO uint32_t *) tmp = Data;
000014  9a00              LDR      r2,[sp,#0]
000016  6011              STR      r1,[r2,#0]
;;;384    }
000018  bd08              POP      {r3,pc}
;;;385    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=2

                  DAC_SetChannel2Data PROC
;;;395      */
;;;396    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000000  b508              PUSH     {r3,lr}
;;;397    {
;;;398      __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;399    
;;;400      /* Check the parameters */
;;;401      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;402      assert_param(IS_DAC_DATA(Data));
;;;403      
;;;404      tmp = (uint32_t)DAC_BASE;
000006  4a05              LDR      r2,|L13.28|
000008  9200              STR      r2,[sp,#0]
;;;405      tmp += DHR12R2_OFFSET + DAC_Align;
00000a  f1000214          ADD      r2,r0,#0x14
00000e  9b00              LDR      r3,[sp,#0]
000010  441a              ADD      r2,r2,r3
000012  9200              STR      r2,[sp,#0]
;;;406    
;;;407      /* Set the DAC channel2 selected data holding register */
;;;408      *(__IO uint32_t *)tmp = Data;
000014  9a00              LDR      r2,[sp,#0]
000016  6011              STR      r1,[r2,#0]
;;;409    }
000018  bd08              POP      {r3,pc}
;;;410    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40007400

                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=2

                  DAC_SetDualChannelData PROC
;;;423      */
;;;424    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000000  b530              PUSH     {r4,r5,lr}
;;;425    {
;;;426      uint32_t data = 0, tmp = 0;
000002  2400              MOVS     r4,#0
000004  2300              MOVS     r3,#0
;;;427      
;;;428      /* Check the parameters */
;;;429      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;430      assert_param(IS_DAC_DATA(Data1));
;;;431      assert_param(IS_DAC_DATA(Data2));
;;;432      
;;;433      /* Calculate and set dual DAC data holding register value */
;;;434      if (DAC_Align == DAC_Align_8b_R)
000006  2808              CMP      r0,#8
000008  d102              BNE      |L14.16|
;;;435      {
;;;436        data = ((uint32_t)Data2 << 8) | Data1; 
00000a  ea422401          ORR      r4,r2,r1,LSL #8
00000e  e001              B        |L14.20|
                  |L14.16|
;;;437      }
;;;438      else
;;;439      {
;;;440        data = ((uint32_t)Data2 << 16) | Data1;
000010  ea424401          ORR      r4,r2,r1,LSL #16
                  |L14.20|
;;;441      }
;;;442      
;;;443      tmp = (uint32_t)DAC_BASE;
000014  4b02              LDR      r3,|L14.32|
;;;444      tmp += DHR12RD_OFFSET + DAC_Align;
000016  f1000520          ADD      r5,r0,#0x20
00001a  442b              ADD      r3,r3,r5
;;;445    
;;;446      /* Set the dual DAC selected data holding register */
;;;447      *(__IO uint32_t *)tmp = data;
00001c  601c              STR      r4,[r3,#0]
;;;448    }
00001e  bd30              POP      {r4,r5,pc}
;;;449    
                          ENDP

                  |L14.32|
                          DCD      0x40007400

                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;286      */
;;;287    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;288    {
;;;289      /* Check the parameters */
;;;290      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;291      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;292    
;;;293      if (NewState != DISABLE)
000002  b141              CBZ      r1,|L15.22|
;;;294      {
;;;295        /* Enable software trigger for the selected DAC channel */
;;;296        DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
000004  4a08              LDR      r2,|L15.40|
000006  6812              LDR      r2,[r2,#0]
000008  0904              LSRS     r4,r0,#4
00000a  2301              MOVS     r3,#1
00000c  40a3              LSLS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  4b05              LDR      r3,|L15.40|
000012  601a              STR      r2,[r3,#0]
000014  e007              B        |L15.38|
                  |L15.22|
;;;297      }
;;;298      else
;;;299      {
;;;300        /* Disable software trigger for the selected DAC channel */
;;;301        DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
000016  4a04              LDR      r2,|L15.40|
000018  6812              LDR      r2,[r2,#0]
00001a  0904              LSRS     r4,r0,#4
00001c  2301              MOVS     r3,#1
00001e  40a3              LSLS     r3,r3,r4
000020  439a              BICS     r2,r2,r3
000022  4b01              LDR      r3,|L15.40|
000024  601a              STR      r2,[r3,#0]
                  |L15.38|
;;;302      }
;;;303    }
000026  bd10              POP      {r4,pc}
;;;304    
                          ENDP

                  |L15.40|
                          DCD      0x40007404

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;234      */
;;;235    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;236    {
;;;237    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;238      /* Initialize the DAC_Trigger member */
;;;239      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000002  6001              STR      r1,[r0,#0]
;;;240      /* Initialize the DAC_WaveGeneration member */
;;;241      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000004  6041              STR      r1,[r0,#4]
;;;242      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;243      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000006  6081              STR      r1,[r0,#8]
;;;244      /* Initialize the DAC_OutputBuffer member */
;;;245      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000008  60c1              STR      r1,[r0,#0xc]
;;;246    }
00000a  4770              BX       lr
;;;247    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;341      */
;;;342    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;346      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;347      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;348    
;;;349      if (NewState != DISABLE)
000002  b13a              CBZ      r2,|L17.20|
;;;350      {
;;;351        /* Enable the selected wave generation for the selected DAC channel */
;;;352        DAC->CR |= DAC_Wave << DAC_Channel;
000004  4b07              LDR      r3,|L17.36|
000006  681b              LDR      r3,[r3,#0]
000008  fa01f400          LSL      r4,r1,r0
00000c  4323              ORRS     r3,r3,r4
00000e  4c05              LDR      r4,|L17.36|
000010  6023              STR      r3,[r4,#0]
000012  e006              B        |L17.34|
                  |L17.20|
;;;353      }
;;;354      else
;;;355      {
;;;356        /* Disable the selected wave generation for the selected DAC channel */
;;;357        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000014  4b03              LDR      r3,|L17.36|
000016  681b              LDR      r3,[r3,#0]
000018  fa01f400          LSL      r4,r1,r0
00001c  43a3              BICS     r3,r3,r4
00001e  4c01              LDR      r4,|L17.36|
000020  6023              STR      r3,[r4,#0]
                  |L17.34|
;;;358      }
;;;359    }
000022  bd10              POP      {r4,pc}
;;;360    
                          ENDP

                  |L17.36|
                          DCD      0x40007400

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_dac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_dac_c_4da4a0a9____REV16|
#line 388 "..\\Libraries\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f2xx_dac_c_4da4a0a9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_dac_c_4da4a0a9____REVSH|
#line 402
|__asm___15_stm32f2xx_dac_c_4da4a0a9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_dac_c_4da4a0a9____RRX|
#line 587
|__asm___15_stm32f2xx_dac_c_4da4a0a9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
